
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model p2pTransfer
 * 
 */
export type p2pTransfer = $Result.DefaultSelection<Prisma.$p2pTransferPayload>
/**
 * Model FraudLog
 * 
 */
export type FraudLog = $Result.DefaultSelection<Prisma.$FraudLogPayload>
/**
 * Model Merchant
 * 
 */
export type Merchant = $Result.DefaultSelection<Prisma.$MerchantPayload>
/**
 * Model MerchantPayment
 * 
 */
export type MerchantPayment = $Result.DefaultSelection<Prisma.$MerchantPaymentPayload>
/**
 * Model OnRampTransaction
 * 
 */
export type OnRampTransaction = $Result.DefaultSelection<Prisma.$OnRampTransactionPayload>
/**
 * Model P2PRequest
 * 
 */
export type P2PRequest = $Result.DefaultSelection<Prisma.$P2PRequestPayload>
/**
 * Model BillSchedule
 * 
 */
export type BillSchedule = $Result.DefaultSelection<Prisma.$BillSchedulePayload>
/**
 * Model RechargePlan
 * 
 */
export type RechargePlan = $Result.DefaultSelection<Prisma.$RechargePlanPayload>
/**
 * Model RechargeOrder
 * 
 */
export type RechargeOrder = $Result.DefaultSelection<Prisma.$RechargeOrderPayload>
/**
 * Model Reward
 * 
 */
export type Reward = $Result.DefaultSelection<Prisma.$RewardPayload>
/**
 * Model Referral
 * 
 */
export type Referral = $Result.DefaultSelection<Prisma.$ReferralPayload>
/**
 * Model WrongSendRequest
 * 
 */
export type WrongSendRequest = $Result.DefaultSelection<Prisma.$WrongSendRequestPayload>
/**
 * Model BillSplitGroup
 * 
 */
export type BillSplitGroup = $Result.DefaultSelection<Prisma.$BillSplitGroupPayload>
/**
 * Model BillSplitMember
 * 
 */
export type BillSplitMember = $Result.DefaultSelection<Prisma.$BillSplitMemberPayload>
/**
 * Model BillSplitPayment
 * 
 */
export type BillSplitPayment = $Result.DefaultSelection<Prisma.$BillSplitPaymentPayload>
/**
 * Model Balance
 * 
 */
export type Balance = $Result.DefaultSelection<Prisma.$BalancePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const WrongSendStatus: {
  PENDING: 'PENDING',
  RETURNED: 'RETURNED',
  EXPIRED: 'EXPIRED'
};

export type WrongSendStatus = (typeof WrongSendStatus)[keyof typeof WrongSendStatus]


export const BillType: {
  ELECTRICITY: 'ELECTRICITY',
  WATER: 'WATER',
  GAS: 'GAS',
  PHONE_RECHARGE: 'PHONE_RECHARGE',
  DTH: 'DTH'
};

export type BillType = (typeof BillType)[keyof typeof BillType]


export const RewardType: {
  CASHBACK: 'CASHBACK',
  SCRATCH: 'SCRATCH',
  REFERRAL: 'REFERRAL',
  MILESTONE: 'MILESTONE'
};

export type RewardType = (typeof RewardType)[keyof typeof RewardType]


export const RewardStatus: {
  PENDING: 'PENDING',
  CLAIMED: 'CLAIMED',
  EXPIRED: 'EXPIRED'
};

export type RewardStatus = (typeof RewardStatus)[keyof typeof RewardStatus]


export const P2PRequestStatus: {
  PENDING: 'PENDING',
  SETTLED: 'SETTLED',
  EXPIRED: 'EXPIRED',
  CANCELLED: 'CANCELLED'
};

export type P2PRequestStatus = (typeof P2PRequestStatus)[keyof typeof P2PRequestStatus]


export const AuthType: {
  Google: 'Google',
  Github: 'Github'
};

export type AuthType = (typeof AuthType)[keyof typeof AuthType]


export const OnRampStatus: {
  Success: 'Success',
  Failure: 'Failure',
  Processing: 'Processing'
};

export type OnRampStatus = (typeof OnRampStatus)[keyof typeof OnRampStatus]

}

export type WrongSendStatus = $Enums.WrongSendStatus

export const WrongSendStatus: typeof $Enums.WrongSendStatus

export type BillType = $Enums.BillType

export const BillType: typeof $Enums.BillType

export type RewardType = $Enums.RewardType

export const RewardType: typeof $Enums.RewardType

export type RewardStatus = $Enums.RewardStatus

export const RewardStatus: typeof $Enums.RewardStatus

export type P2PRequestStatus = $Enums.P2PRequestStatus

export const P2PRequestStatus: typeof $Enums.P2PRequestStatus

export type AuthType = $Enums.AuthType

export const AuthType: typeof $Enums.AuthType

export type OnRampStatus = $Enums.OnRampStatus

export const OnRampStatus: typeof $Enums.OnRampStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.p2pTransfer`: Exposes CRUD operations for the **p2pTransfer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more P2pTransfers
    * const p2pTransfers = await prisma.p2pTransfer.findMany()
    * ```
    */
  get p2pTransfer(): Prisma.p2pTransferDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fraudLog`: Exposes CRUD operations for the **FraudLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FraudLogs
    * const fraudLogs = await prisma.fraudLog.findMany()
    * ```
    */
  get fraudLog(): Prisma.FraudLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.merchant`: Exposes CRUD operations for the **Merchant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Merchants
    * const merchants = await prisma.merchant.findMany()
    * ```
    */
  get merchant(): Prisma.MerchantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.merchantPayment`: Exposes CRUD operations for the **MerchantPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MerchantPayments
    * const merchantPayments = await prisma.merchantPayment.findMany()
    * ```
    */
  get merchantPayment(): Prisma.MerchantPaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.onRampTransaction`: Exposes CRUD operations for the **OnRampTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OnRampTransactions
    * const onRampTransactions = await prisma.onRampTransaction.findMany()
    * ```
    */
  get onRampTransaction(): Prisma.OnRampTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.p2PRequest`: Exposes CRUD operations for the **P2PRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more P2PRequests
    * const p2PRequests = await prisma.p2PRequest.findMany()
    * ```
    */
  get p2PRequest(): Prisma.P2PRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.billSchedule`: Exposes CRUD operations for the **BillSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BillSchedules
    * const billSchedules = await prisma.billSchedule.findMany()
    * ```
    */
  get billSchedule(): Prisma.BillScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rechargePlan`: Exposes CRUD operations for the **RechargePlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RechargePlans
    * const rechargePlans = await prisma.rechargePlan.findMany()
    * ```
    */
  get rechargePlan(): Prisma.RechargePlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rechargeOrder`: Exposes CRUD operations for the **RechargeOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RechargeOrders
    * const rechargeOrders = await prisma.rechargeOrder.findMany()
    * ```
    */
  get rechargeOrder(): Prisma.RechargeOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reward`: Exposes CRUD operations for the **Reward** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rewards
    * const rewards = await prisma.reward.findMany()
    * ```
    */
  get reward(): Prisma.RewardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.referral`: Exposes CRUD operations for the **Referral** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Referrals
    * const referrals = await prisma.referral.findMany()
    * ```
    */
  get referral(): Prisma.ReferralDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wrongSendRequest`: Exposes CRUD operations for the **WrongSendRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WrongSendRequests
    * const wrongSendRequests = await prisma.wrongSendRequest.findMany()
    * ```
    */
  get wrongSendRequest(): Prisma.WrongSendRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.billSplitGroup`: Exposes CRUD operations for the **BillSplitGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BillSplitGroups
    * const billSplitGroups = await prisma.billSplitGroup.findMany()
    * ```
    */
  get billSplitGroup(): Prisma.BillSplitGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.billSplitMember`: Exposes CRUD operations for the **BillSplitMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BillSplitMembers
    * const billSplitMembers = await prisma.billSplitMember.findMany()
    * ```
    */
  get billSplitMember(): Prisma.BillSplitMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.billSplitPayment`: Exposes CRUD operations for the **BillSplitPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BillSplitPayments
    * const billSplitPayments = await prisma.billSplitPayment.findMany()
    * ```
    */
  get billSplitPayment(): Prisma.BillSplitPaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.balance`: Exposes CRUD operations for the **Balance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Balances
    * const balances = await prisma.balance.findMany()
    * ```
    */
  get balance(): Prisma.BalanceDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.2.0
   * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    p2pTransfer: 'p2pTransfer',
    FraudLog: 'FraudLog',
    Merchant: 'Merchant',
    MerchantPayment: 'MerchantPayment',
    OnRampTransaction: 'OnRampTransaction',
    P2PRequest: 'P2PRequest',
    BillSchedule: 'BillSchedule',
    RechargePlan: 'RechargePlan',
    RechargeOrder: 'RechargeOrder',
    Reward: 'Reward',
    Referral: 'Referral',
    WrongSendRequest: 'WrongSendRequest',
    BillSplitGroup: 'BillSplitGroup',
    BillSplitMember: 'BillSplitMember',
    BillSplitPayment: 'BillSplitPayment',
    Balance: 'Balance'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "p2pTransfer" | "fraudLog" | "merchant" | "merchantPayment" | "onRampTransaction" | "p2PRequest" | "billSchedule" | "rechargePlan" | "rechargeOrder" | "reward" | "referral" | "wrongSendRequest" | "billSplitGroup" | "billSplitMember" | "billSplitPayment" | "balance"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      p2pTransfer: {
        payload: Prisma.$p2pTransferPayload<ExtArgs>
        fields: Prisma.p2pTransferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.p2pTransferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2pTransferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.p2pTransferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2pTransferPayload>
          }
          findFirst: {
            args: Prisma.p2pTransferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2pTransferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.p2pTransferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2pTransferPayload>
          }
          findMany: {
            args: Prisma.p2pTransferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2pTransferPayload>[]
          }
          create: {
            args: Prisma.p2pTransferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2pTransferPayload>
          }
          createMany: {
            args: Prisma.p2pTransferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.p2pTransferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2pTransferPayload>[]
          }
          delete: {
            args: Prisma.p2pTransferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2pTransferPayload>
          }
          update: {
            args: Prisma.p2pTransferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2pTransferPayload>
          }
          deleteMany: {
            args: Prisma.p2pTransferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.p2pTransferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.p2pTransferUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2pTransferPayload>[]
          }
          upsert: {
            args: Prisma.p2pTransferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$p2pTransferPayload>
          }
          aggregate: {
            args: Prisma.P2pTransferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateP2pTransfer>
          }
          groupBy: {
            args: Prisma.p2pTransferGroupByArgs<ExtArgs>
            result: $Utils.Optional<P2pTransferGroupByOutputType>[]
          }
          count: {
            args: Prisma.p2pTransferCountArgs<ExtArgs>
            result: $Utils.Optional<P2pTransferCountAggregateOutputType> | number
          }
        }
      }
      FraudLog: {
        payload: Prisma.$FraudLogPayload<ExtArgs>
        fields: Prisma.FraudLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FraudLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FraudLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FraudLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FraudLogPayload>
          }
          findFirst: {
            args: Prisma.FraudLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FraudLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FraudLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FraudLogPayload>
          }
          findMany: {
            args: Prisma.FraudLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FraudLogPayload>[]
          }
          create: {
            args: Prisma.FraudLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FraudLogPayload>
          }
          createMany: {
            args: Prisma.FraudLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FraudLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FraudLogPayload>[]
          }
          delete: {
            args: Prisma.FraudLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FraudLogPayload>
          }
          update: {
            args: Prisma.FraudLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FraudLogPayload>
          }
          deleteMany: {
            args: Prisma.FraudLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FraudLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FraudLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FraudLogPayload>[]
          }
          upsert: {
            args: Prisma.FraudLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FraudLogPayload>
          }
          aggregate: {
            args: Prisma.FraudLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFraudLog>
          }
          groupBy: {
            args: Prisma.FraudLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<FraudLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.FraudLogCountArgs<ExtArgs>
            result: $Utils.Optional<FraudLogCountAggregateOutputType> | number
          }
        }
      }
      Merchant: {
        payload: Prisma.$MerchantPayload<ExtArgs>
        fields: Prisma.MerchantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MerchantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MerchantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>
          }
          findFirst: {
            args: Prisma.MerchantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MerchantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>
          }
          findMany: {
            args: Prisma.MerchantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>[]
          }
          create: {
            args: Prisma.MerchantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>
          }
          createMany: {
            args: Prisma.MerchantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MerchantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>[]
          }
          delete: {
            args: Prisma.MerchantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>
          }
          update: {
            args: Prisma.MerchantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>
          }
          deleteMany: {
            args: Prisma.MerchantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MerchantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MerchantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>[]
          }
          upsert: {
            args: Prisma.MerchantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>
          }
          aggregate: {
            args: Prisma.MerchantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMerchant>
          }
          groupBy: {
            args: Prisma.MerchantGroupByArgs<ExtArgs>
            result: $Utils.Optional<MerchantGroupByOutputType>[]
          }
          count: {
            args: Prisma.MerchantCountArgs<ExtArgs>
            result: $Utils.Optional<MerchantCountAggregateOutputType> | number
          }
        }
      }
      MerchantPayment: {
        payload: Prisma.$MerchantPaymentPayload<ExtArgs>
        fields: Prisma.MerchantPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MerchantPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MerchantPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPaymentPayload>
          }
          findFirst: {
            args: Prisma.MerchantPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MerchantPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPaymentPayload>
          }
          findMany: {
            args: Prisma.MerchantPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPaymentPayload>[]
          }
          create: {
            args: Prisma.MerchantPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPaymentPayload>
          }
          createMany: {
            args: Prisma.MerchantPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MerchantPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPaymentPayload>[]
          }
          delete: {
            args: Prisma.MerchantPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPaymentPayload>
          }
          update: {
            args: Prisma.MerchantPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPaymentPayload>
          }
          deleteMany: {
            args: Prisma.MerchantPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MerchantPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MerchantPaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPaymentPayload>[]
          }
          upsert: {
            args: Prisma.MerchantPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPaymentPayload>
          }
          aggregate: {
            args: Prisma.MerchantPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMerchantPayment>
          }
          groupBy: {
            args: Prisma.MerchantPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<MerchantPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.MerchantPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<MerchantPaymentCountAggregateOutputType> | number
          }
        }
      }
      OnRampTransaction: {
        payload: Prisma.$OnRampTransactionPayload<ExtArgs>
        fields: Prisma.OnRampTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OnRampTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnRampTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OnRampTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnRampTransactionPayload>
          }
          findFirst: {
            args: Prisma.OnRampTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnRampTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OnRampTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnRampTransactionPayload>
          }
          findMany: {
            args: Prisma.OnRampTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnRampTransactionPayload>[]
          }
          create: {
            args: Prisma.OnRampTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnRampTransactionPayload>
          }
          createMany: {
            args: Prisma.OnRampTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OnRampTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnRampTransactionPayload>[]
          }
          delete: {
            args: Prisma.OnRampTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnRampTransactionPayload>
          }
          update: {
            args: Prisma.OnRampTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnRampTransactionPayload>
          }
          deleteMany: {
            args: Prisma.OnRampTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OnRampTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OnRampTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnRampTransactionPayload>[]
          }
          upsert: {
            args: Prisma.OnRampTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnRampTransactionPayload>
          }
          aggregate: {
            args: Prisma.OnRampTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOnRampTransaction>
          }
          groupBy: {
            args: Prisma.OnRampTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<OnRampTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.OnRampTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<OnRampTransactionCountAggregateOutputType> | number
          }
        }
      }
      P2PRequest: {
        payload: Prisma.$P2PRequestPayload<ExtArgs>
        fields: Prisma.P2PRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.P2PRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$P2PRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.P2PRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$P2PRequestPayload>
          }
          findFirst: {
            args: Prisma.P2PRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$P2PRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.P2PRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$P2PRequestPayload>
          }
          findMany: {
            args: Prisma.P2PRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$P2PRequestPayload>[]
          }
          create: {
            args: Prisma.P2PRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$P2PRequestPayload>
          }
          createMany: {
            args: Prisma.P2PRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.P2PRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$P2PRequestPayload>[]
          }
          delete: {
            args: Prisma.P2PRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$P2PRequestPayload>
          }
          update: {
            args: Prisma.P2PRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$P2PRequestPayload>
          }
          deleteMany: {
            args: Prisma.P2PRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.P2PRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.P2PRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$P2PRequestPayload>[]
          }
          upsert: {
            args: Prisma.P2PRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$P2PRequestPayload>
          }
          aggregate: {
            args: Prisma.P2PRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateP2PRequest>
          }
          groupBy: {
            args: Prisma.P2PRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<P2PRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.P2PRequestCountArgs<ExtArgs>
            result: $Utils.Optional<P2PRequestCountAggregateOutputType> | number
          }
        }
      }
      BillSchedule: {
        payload: Prisma.$BillSchedulePayload<ExtArgs>
        fields: Prisma.BillScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSchedulePayload>
          }
          findFirst: {
            args: Prisma.BillScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSchedulePayload>
          }
          findMany: {
            args: Prisma.BillScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSchedulePayload>[]
          }
          create: {
            args: Prisma.BillScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSchedulePayload>
          }
          createMany: {
            args: Prisma.BillScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BillScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSchedulePayload>[]
          }
          delete: {
            args: Prisma.BillScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSchedulePayload>
          }
          update: {
            args: Prisma.BillScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSchedulePayload>
          }
          deleteMany: {
            args: Prisma.BillScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BillScheduleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSchedulePayload>[]
          }
          upsert: {
            args: Prisma.BillScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSchedulePayload>
          }
          aggregate: {
            args: Prisma.BillScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBillSchedule>
          }
          groupBy: {
            args: Prisma.BillScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<BillScheduleCountAggregateOutputType> | number
          }
        }
      }
      RechargePlan: {
        payload: Prisma.$RechargePlanPayload<ExtArgs>
        fields: Prisma.RechargePlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RechargePlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RechargePlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RechargePlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RechargePlanPayload>
          }
          findFirst: {
            args: Prisma.RechargePlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RechargePlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RechargePlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RechargePlanPayload>
          }
          findMany: {
            args: Prisma.RechargePlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RechargePlanPayload>[]
          }
          create: {
            args: Prisma.RechargePlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RechargePlanPayload>
          }
          createMany: {
            args: Prisma.RechargePlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RechargePlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RechargePlanPayload>[]
          }
          delete: {
            args: Prisma.RechargePlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RechargePlanPayload>
          }
          update: {
            args: Prisma.RechargePlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RechargePlanPayload>
          }
          deleteMany: {
            args: Prisma.RechargePlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RechargePlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RechargePlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RechargePlanPayload>[]
          }
          upsert: {
            args: Prisma.RechargePlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RechargePlanPayload>
          }
          aggregate: {
            args: Prisma.RechargePlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRechargePlan>
          }
          groupBy: {
            args: Prisma.RechargePlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<RechargePlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.RechargePlanCountArgs<ExtArgs>
            result: $Utils.Optional<RechargePlanCountAggregateOutputType> | number
          }
        }
      }
      RechargeOrder: {
        payload: Prisma.$RechargeOrderPayload<ExtArgs>
        fields: Prisma.RechargeOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RechargeOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RechargeOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RechargeOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RechargeOrderPayload>
          }
          findFirst: {
            args: Prisma.RechargeOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RechargeOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RechargeOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RechargeOrderPayload>
          }
          findMany: {
            args: Prisma.RechargeOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RechargeOrderPayload>[]
          }
          create: {
            args: Prisma.RechargeOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RechargeOrderPayload>
          }
          createMany: {
            args: Prisma.RechargeOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RechargeOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RechargeOrderPayload>[]
          }
          delete: {
            args: Prisma.RechargeOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RechargeOrderPayload>
          }
          update: {
            args: Prisma.RechargeOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RechargeOrderPayload>
          }
          deleteMany: {
            args: Prisma.RechargeOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RechargeOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RechargeOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RechargeOrderPayload>[]
          }
          upsert: {
            args: Prisma.RechargeOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RechargeOrderPayload>
          }
          aggregate: {
            args: Prisma.RechargeOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRechargeOrder>
          }
          groupBy: {
            args: Prisma.RechargeOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<RechargeOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.RechargeOrderCountArgs<ExtArgs>
            result: $Utils.Optional<RechargeOrderCountAggregateOutputType> | number
          }
        }
      }
      Reward: {
        payload: Prisma.$RewardPayload<ExtArgs>
        fields: Prisma.RewardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RewardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RewardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>
          }
          findFirst: {
            args: Prisma.RewardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RewardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>
          }
          findMany: {
            args: Prisma.RewardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>[]
          }
          create: {
            args: Prisma.RewardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>
          }
          createMany: {
            args: Prisma.RewardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RewardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>[]
          }
          delete: {
            args: Prisma.RewardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>
          }
          update: {
            args: Prisma.RewardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>
          }
          deleteMany: {
            args: Prisma.RewardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RewardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RewardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>[]
          }
          upsert: {
            args: Prisma.RewardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>
          }
          aggregate: {
            args: Prisma.RewardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReward>
          }
          groupBy: {
            args: Prisma.RewardGroupByArgs<ExtArgs>
            result: $Utils.Optional<RewardGroupByOutputType>[]
          }
          count: {
            args: Prisma.RewardCountArgs<ExtArgs>
            result: $Utils.Optional<RewardCountAggregateOutputType> | number
          }
        }
      }
      Referral: {
        payload: Prisma.$ReferralPayload<ExtArgs>
        fields: Prisma.ReferralFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferralFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferralFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          findFirst: {
            args: Prisma.ReferralFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferralFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          findMany: {
            args: Prisma.ReferralFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          create: {
            args: Prisma.ReferralCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          createMany: {
            args: Prisma.ReferralCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReferralCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          delete: {
            args: Prisma.ReferralDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          update: {
            args: Prisma.ReferralUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          deleteMany: {
            args: Prisma.ReferralDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferralUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReferralUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          upsert: {
            args: Prisma.ReferralUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          aggregate: {
            args: Prisma.ReferralAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferral>
          }
          groupBy: {
            args: Prisma.ReferralGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferralGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferralCountArgs<ExtArgs>
            result: $Utils.Optional<ReferralCountAggregateOutputType> | number
          }
        }
      }
      WrongSendRequest: {
        payload: Prisma.$WrongSendRequestPayload<ExtArgs>
        fields: Prisma.WrongSendRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WrongSendRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WrongSendRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WrongSendRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WrongSendRequestPayload>
          }
          findFirst: {
            args: Prisma.WrongSendRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WrongSendRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WrongSendRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WrongSendRequestPayload>
          }
          findMany: {
            args: Prisma.WrongSendRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WrongSendRequestPayload>[]
          }
          create: {
            args: Prisma.WrongSendRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WrongSendRequestPayload>
          }
          createMany: {
            args: Prisma.WrongSendRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WrongSendRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WrongSendRequestPayload>[]
          }
          delete: {
            args: Prisma.WrongSendRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WrongSendRequestPayload>
          }
          update: {
            args: Prisma.WrongSendRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WrongSendRequestPayload>
          }
          deleteMany: {
            args: Prisma.WrongSendRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WrongSendRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WrongSendRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WrongSendRequestPayload>[]
          }
          upsert: {
            args: Prisma.WrongSendRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WrongSendRequestPayload>
          }
          aggregate: {
            args: Prisma.WrongSendRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWrongSendRequest>
          }
          groupBy: {
            args: Prisma.WrongSendRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<WrongSendRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.WrongSendRequestCountArgs<ExtArgs>
            result: $Utils.Optional<WrongSendRequestCountAggregateOutputType> | number
          }
        }
      }
      BillSplitGroup: {
        payload: Prisma.$BillSplitGroupPayload<ExtArgs>
        fields: Prisma.BillSplitGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillSplitGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSplitGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillSplitGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSplitGroupPayload>
          }
          findFirst: {
            args: Prisma.BillSplitGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSplitGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillSplitGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSplitGroupPayload>
          }
          findMany: {
            args: Prisma.BillSplitGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSplitGroupPayload>[]
          }
          create: {
            args: Prisma.BillSplitGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSplitGroupPayload>
          }
          createMany: {
            args: Prisma.BillSplitGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BillSplitGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSplitGroupPayload>[]
          }
          delete: {
            args: Prisma.BillSplitGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSplitGroupPayload>
          }
          update: {
            args: Prisma.BillSplitGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSplitGroupPayload>
          }
          deleteMany: {
            args: Prisma.BillSplitGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillSplitGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BillSplitGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSplitGroupPayload>[]
          }
          upsert: {
            args: Prisma.BillSplitGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSplitGroupPayload>
          }
          aggregate: {
            args: Prisma.BillSplitGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBillSplitGroup>
          }
          groupBy: {
            args: Prisma.BillSplitGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillSplitGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillSplitGroupCountArgs<ExtArgs>
            result: $Utils.Optional<BillSplitGroupCountAggregateOutputType> | number
          }
        }
      }
      BillSplitMember: {
        payload: Prisma.$BillSplitMemberPayload<ExtArgs>
        fields: Prisma.BillSplitMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillSplitMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSplitMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillSplitMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSplitMemberPayload>
          }
          findFirst: {
            args: Prisma.BillSplitMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSplitMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillSplitMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSplitMemberPayload>
          }
          findMany: {
            args: Prisma.BillSplitMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSplitMemberPayload>[]
          }
          create: {
            args: Prisma.BillSplitMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSplitMemberPayload>
          }
          createMany: {
            args: Prisma.BillSplitMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BillSplitMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSplitMemberPayload>[]
          }
          delete: {
            args: Prisma.BillSplitMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSplitMemberPayload>
          }
          update: {
            args: Prisma.BillSplitMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSplitMemberPayload>
          }
          deleteMany: {
            args: Prisma.BillSplitMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillSplitMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BillSplitMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSplitMemberPayload>[]
          }
          upsert: {
            args: Prisma.BillSplitMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSplitMemberPayload>
          }
          aggregate: {
            args: Prisma.BillSplitMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBillSplitMember>
          }
          groupBy: {
            args: Prisma.BillSplitMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillSplitMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillSplitMemberCountArgs<ExtArgs>
            result: $Utils.Optional<BillSplitMemberCountAggregateOutputType> | number
          }
        }
      }
      BillSplitPayment: {
        payload: Prisma.$BillSplitPaymentPayload<ExtArgs>
        fields: Prisma.BillSplitPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillSplitPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSplitPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillSplitPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSplitPaymentPayload>
          }
          findFirst: {
            args: Prisma.BillSplitPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSplitPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillSplitPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSplitPaymentPayload>
          }
          findMany: {
            args: Prisma.BillSplitPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSplitPaymentPayload>[]
          }
          create: {
            args: Prisma.BillSplitPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSplitPaymentPayload>
          }
          createMany: {
            args: Prisma.BillSplitPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BillSplitPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSplitPaymentPayload>[]
          }
          delete: {
            args: Prisma.BillSplitPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSplitPaymentPayload>
          }
          update: {
            args: Prisma.BillSplitPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSplitPaymentPayload>
          }
          deleteMany: {
            args: Prisma.BillSplitPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillSplitPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BillSplitPaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSplitPaymentPayload>[]
          }
          upsert: {
            args: Prisma.BillSplitPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillSplitPaymentPayload>
          }
          aggregate: {
            args: Prisma.BillSplitPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBillSplitPayment>
          }
          groupBy: {
            args: Prisma.BillSplitPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillSplitPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillSplitPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<BillSplitPaymentCountAggregateOutputType> | number
          }
        }
      }
      Balance: {
        payload: Prisma.$BalancePayload<ExtArgs>
        fields: Prisma.BalanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BalanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BalanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>
          }
          findFirst: {
            args: Prisma.BalanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BalanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>
          }
          findMany: {
            args: Prisma.BalanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>[]
          }
          create: {
            args: Prisma.BalanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>
          }
          createMany: {
            args: Prisma.BalanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BalanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>[]
          }
          delete: {
            args: Prisma.BalanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>
          }
          update: {
            args: Prisma.BalanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>
          }
          deleteMany: {
            args: Prisma.BalanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BalanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BalanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>[]
          }
          upsert: {
            args: Prisma.BalanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>
          }
          aggregate: {
            args: Prisma.BalanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBalance>
          }
          groupBy: {
            args: Prisma.BalanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<BalanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.BalanceCountArgs<ExtArgs>
            result: $Utils.Optional<BalanceCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    p2pTransfer?: p2pTransferOmit
    fraudLog?: FraudLogOmit
    merchant?: MerchantOmit
    merchantPayment?: MerchantPaymentOmit
    onRampTransaction?: OnRampTransactionOmit
    p2PRequest?: P2PRequestOmit
    billSchedule?: BillScheduleOmit
    rechargePlan?: RechargePlanOmit
    rechargeOrder?: RechargeOrderOmit
    reward?: RewardOmit
    referral?: ReferralOmit
    wrongSendRequest?: WrongSendRequestOmit
    billSplitGroup?: BillSplitGroupOmit
    billSplitMember?: BillSplitMemberOmit
    billSplitPayment?: BillSplitPaymentOmit
    balance?: BalanceOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    OnRampTransaction: number
    Balance: number
    sentTransfers: number
    receivedTransfers: number
    sentRequests: number
    receivedRequests: number
    billSchedules: number
    merchantPayments: number
    rechargeOrders: number
    rewards: number
    referralsAsReferrer: number
    referralsAsReferred: number
    wrongSendRequests: number
    createdGroups: number
    billSplitMembers: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OnRampTransaction?: boolean | UserCountOutputTypeCountOnRampTransactionArgs
    Balance?: boolean | UserCountOutputTypeCountBalanceArgs
    sentTransfers?: boolean | UserCountOutputTypeCountSentTransfersArgs
    receivedTransfers?: boolean | UserCountOutputTypeCountReceivedTransfersArgs
    sentRequests?: boolean | UserCountOutputTypeCountSentRequestsArgs
    receivedRequests?: boolean | UserCountOutputTypeCountReceivedRequestsArgs
    billSchedules?: boolean | UserCountOutputTypeCountBillSchedulesArgs
    merchantPayments?: boolean | UserCountOutputTypeCountMerchantPaymentsArgs
    rechargeOrders?: boolean | UserCountOutputTypeCountRechargeOrdersArgs
    rewards?: boolean | UserCountOutputTypeCountRewardsArgs
    referralsAsReferrer?: boolean | UserCountOutputTypeCountReferralsAsReferrerArgs
    referralsAsReferred?: boolean | UserCountOutputTypeCountReferralsAsReferredArgs
    wrongSendRequests?: boolean | UserCountOutputTypeCountWrongSendRequestsArgs
    createdGroups?: boolean | UserCountOutputTypeCountCreatedGroupsArgs
    billSplitMembers?: boolean | UserCountOutputTypeCountBillSplitMembersArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOnRampTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OnRampTransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBalanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BalanceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: p2pTransferWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: p2pTransferWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: P2PRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: P2PRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBillSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillScheduleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMerchantPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MerchantPaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRechargeOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RechargeOrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RewardWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReferralsAsReferrerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReferralsAsReferredArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWrongSendRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WrongSendRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillSplitGroupWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBillSplitMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillSplitMemberWhereInput
  }


  /**
   * Count Type MerchantCountOutputType
   */

  export type MerchantCountOutputType = {
    billSchedules: number
    payments: number
  }

  export type MerchantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    billSchedules?: boolean | MerchantCountOutputTypeCountBillSchedulesArgs
    payments?: boolean | MerchantCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * MerchantCountOutputType without action
   */
  export type MerchantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantCountOutputType
     */
    select?: MerchantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MerchantCountOutputType without action
   */
  export type MerchantCountOutputTypeCountBillSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillScheduleWhereInput
  }

  /**
   * MerchantCountOutputType without action
   */
  export type MerchantCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MerchantPaymentWhereInput
  }


  /**
   * Count Type RechargePlanCountOutputType
   */

  export type RechargePlanCountOutputType = {
    rechargeOrders: number
  }

  export type RechargePlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rechargeOrders?: boolean | RechargePlanCountOutputTypeCountRechargeOrdersArgs
  }

  // Custom InputTypes
  /**
   * RechargePlanCountOutputType without action
   */
  export type RechargePlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RechargePlanCountOutputType
     */
    select?: RechargePlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RechargePlanCountOutputType without action
   */
  export type RechargePlanCountOutputTypeCountRechargeOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RechargeOrderWhereInput
  }


  /**
   * Count Type BillSplitGroupCountOutputType
   */

  export type BillSplitGroupCountOutputType = {
    members: number
    payments: number
    rewards: number
  }

  export type BillSplitGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | BillSplitGroupCountOutputTypeCountMembersArgs
    payments?: boolean | BillSplitGroupCountOutputTypeCountPaymentsArgs
    rewards?: boolean | BillSplitGroupCountOutputTypeCountRewardsArgs
  }

  // Custom InputTypes
  /**
   * BillSplitGroupCountOutputType without action
   */
  export type BillSplitGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitGroupCountOutputType
     */
    select?: BillSplitGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BillSplitGroupCountOutputType without action
   */
  export type BillSplitGroupCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillSplitMemberWhereInput
  }

  /**
   * BillSplitGroupCountOutputType without action
   */
  export type BillSplitGroupCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillSplitPaymentWhereInput
  }

  /**
   * BillSplitGroupCountOutputType without action
   */
  export type BillSplitGroupCountOutputTypeCountRewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RewardWhereInput
  }


  /**
   * Count Type BillSplitMemberCountOutputType
   */

  export type BillSplitMemberCountOutputType = {
    payments: number
  }

  export type BillSplitMemberCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | BillSplitMemberCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * BillSplitMemberCountOutputType without action
   */
  export type BillSplitMemberCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitMemberCountOutputType
     */
    select?: BillSplitMemberCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BillSplitMemberCountOutputType without action
   */
  export type BillSplitMemberCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillSplitPaymentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    number: string | null
    password: string | null
    sessionToken: string | null
    image: string | null
    userpin: string | null
    resetOtp: string | null
    resetExpires: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    number: string | null
    password: string | null
    sessionToken: string | null
    image: string | null
    userpin: string | null
    resetOtp: string | null
    resetExpires: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    number: number
    password: number
    sessionToken: number
    image: number
    userpin: number
    resetOtp: number
    resetExpires: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    number?: true
    password?: true
    sessionToken?: true
    image?: true
    userpin?: true
    resetOtp?: true
    resetExpires?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    number?: true
    password?: true
    sessionToken?: true
    image?: true
    userpin?: true
    resetOtp?: true
    resetExpires?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    number?: true
    password?: true
    sessionToken?: true
    image?: true
    userpin?: true
    resetOtp?: true
    resetExpires?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string | null
    name: string | null
    number: string
    password: string
    sessionToken: string | null
    image: string | null
    userpin: string
    resetOtp: string | null
    resetExpires: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    number?: boolean
    password?: boolean
    sessionToken?: boolean
    image?: boolean
    userpin?: boolean
    resetOtp?: boolean
    resetExpires?: boolean
    OnRampTransaction?: boolean | User$OnRampTransactionArgs<ExtArgs>
    Balance?: boolean | User$BalanceArgs<ExtArgs>
    sentTransfers?: boolean | User$sentTransfersArgs<ExtArgs>
    receivedTransfers?: boolean | User$receivedTransfersArgs<ExtArgs>
    sentRequests?: boolean | User$sentRequestsArgs<ExtArgs>
    receivedRequests?: boolean | User$receivedRequestsArgs<ExtArgs>
    billSchedules?: boolean | User$billSchedulesArgs<ExtArgs>
    merchantPayments?: boolean | User$merchantPaymentsArgs<ExtArgs>
    rechargeOrders?: boolean | User$rechargeOrdersArgs<ExtArgs>
    rewards?: boolean | User$rewardsArgs<ExtArgs>
    referralsAsReferrer?: boolean | User$referralsAsReferrerArgs<ExtArgs>
    referralsAsReferred?: boolean | User$referralsAsReferredArgs<ExtArgs>
    wrongSendRequests?: boolean | User$wrongSendRequestsArgs<ExtArgs>
    createdGroups?: boolean | User$createdGroupsArgs<ExtArgs>
    billSplitMembers?: boolean | User$billSplitMembersArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    number?: boolean
    password?: boolean
    sessionToken?: boolean
    image?: boolean
    userpin?: boolean
    resetOtp?: boolean
    resetExpires?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    number?: boolean
    password?: boolean
    sessionToken?: boolean
    image?: boolean
    userpin?: boolean
    resetOtp?: boolean
    resetExpires?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    number?: boolean
    password?: boolean
    sessionToken?: boolean
    image?: boolean
    userpin?: boolean
    resetOtp?: boolean
    resetExpires?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "number" | "password" | "sessionToken" | "image" | "userpin" | "resetOtp" | "resetExpires", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OnRampTransaction?: boolean | User$OnRampTransactionArgs<ExtArgs>
    Balance?: boolean | User$BalanceArgs<ExtArgs>
    sentTransfers?: boolean | User$sentTransfersArgs<ExtArgs>
    receivedTransfers?: boolean | User$receivedTransfersArgs<ExtArgs>
    sentRequests?: boolean | User$sentRequestsArgs<ExtArgs>
    receivedRequests?: boolean | User$receivedRequestsArgs<ExtArgs>
    billSchedules?: boolean | User$billSchedulesArgs<ExtArgs>
    merchantPayments?: boolean | User$merchantPaymentsArgs<ExtArgs>
    rechargeOrders?: boolean | User$rechargeOrdersArgs<ExtArgs>
    rewards?: boolean | User$rewardsArgs<ExtArgs>
    referralsAsReferrer?: boolean | User$referralsAsReferrerArgs<ExtArgs>
    referralsAsReferred?: boolean | User$referralsAsReferredArgs<ExtArgs>
    wrongSendRequests?: boolean | User$wrongSendRequestsArgs<ExtArgs>
    createdGroups?: boolean | User$createdGroupsArgs<ExtArgs>
    billSplitMembers?: boolean | User$billSplitMembersArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      OnRampTransaction: Prisma.$OnRampTransactionPayload<ExtArgs>[]
      Balance: Prisma.$BalancePayload<ExtArgs>[]
      sentTransfers: Prisma.$p2pTransferPayload<ExtArgs>[]
      receivedTransfers: Prisma.$p2pTransferPayload<ExtArgs>[]
      sentRequests: Prisma.$P2PRequestPayload<ExtArgs>[]
      receivedRequests: Prisma.$P2PRequestPayload<ExtArgs>[]
      billSchedules: Prisma.$BillSchedulePayload<ExtArgs>[]
      merchantPayments: Prisma.$MerchantPaymentPayload<ExtArgs>[]
      rechargeOrders: Prisma.$RechargeOrderPayload<ExtArgs>[]
      rewards: Prisma.$RewardPayload<ExtArgs>[]
      referralsAsReferrer: Prisma.$ReferralPayload<ExtArgs>[]
      referralsAsReferred: Prisma.$ReferralPayload<ExtArgs>[]
      wrongSendRequests: Prisma.$WrongSendRequestPayload<ExtArgs>[]
      createdGroups: Prisma.$BillSplitGroupPayload<ExtArgs>[]
      billSplitMembers: Prisma.$BillSplitMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string | null
      name: string | null
      number: string
      password: string
      sessionToken: string | null
      image: string | null
      userpin: string
      resetOtp: string | null
      resetExpires: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    OnRampTransaction<T extends User$OnRampTransactionArgs<ExtArgs> = {}>(args?: Subset<T, User$OnRampTransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnRampTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Balance<T extends User$BalanceArgs<ExtArgs> = {}>(args?: Subset<T, User$BalanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentTransfers<T extends User$sentTransfersArgs<ExtArgs> = {}>(args?: Subset<T, User$sentTransfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p2pTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedTransfers<T extends User$receivedTransfersArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedTransfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p2pTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentRequests<T extends User$sentRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$sentRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$P2PRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedRequests<T extends User$receivedRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$P2PRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    billSchedules<T extends User$billSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, User$billSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    merchantPayments<T extends User$merchantPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$merchantPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerchantPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rechargeOrders<T extends User$rechargeOrdersArgs<ExtArgs> = {}>(args?: Subset<T, User$rechargeOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RechargeOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rewards<T extends User$rewardsArgs<ExtArgs> = {}>(args?: Subset<T, User$rewardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    referralsAsReferrer<T extends User$referralsAsReferrerArgs<ExtArgs> = {}>(args?: Subset<T, User$referralsAsReferrerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    referralsAsReferred<T extends User$referralsAsReferredArgs<ExtArgs> = {}>(args?: Subset<T, User$referralsAsReferredArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    wrongSendRequests<T extends User$wrongSendRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$wrongSendRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WrongSendRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdGroups<T extends User$createdGroupsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillSplitGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    billSplitMembers<T extends User$billSplitMembersArgs<ExtArgs> = {}>(args?: Subset<T, User$billSplitMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillSplitMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly number: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly sessionToken: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly userpin: FieldRef<"User", 'String'>
    readonly resetOtp: FieldRef<"User", 'String'>
    readonly resetExpires: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.OnRampTransaction
   */
  export type User$OnRampTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnRampTransaction
     */
    select?: OnRampTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnRampTransaction
     */
    omit?: OnRampTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnRampTransactionInclude<ExtArgs> | null
    where?: OnRampTransactionWhereInput
    orderBy?: OnRampTransactionOrderByWithRelationInput | OnRampTransactionOrderByWithRelationInput[]
    cursor?: OnRampTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OnRampTransactionScalarFieldEnum | OnRampTransactionScalarFieldEnum[]
  }

  /**
   * User.Balance
   */
  export type User$BalanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    where?: BalanceWhereInput
    orderBy?: BalanceOrderByWithRelationInput | BalanceOrderByWithRelationInput[]
    cursor?: BalanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BalanceScalarFieldEnum | BalanceScalarFieldEnum[]
  }

  /**
   * User.sentTransfers
   */
  export type User$sentTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2pTransfer
     */
    select?: p2pTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2pTransfer
     */
    omit?: p2pTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2pTransferInclude<ExtArgs> | null
    where?: p2pTransferWhereInput
    orderBy?: p2pTransferOrderByWithRelationInput | p2pTransferOrderByWithRelationInput[]
    cursor?: p2pTransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: P2pTransferScalarFieldEnum | P2pTransferScalarFieldEnum[]
  }

  /**
   * User.receivedTransfers
   */
  export type User$receivedTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2pTransfer
     */
    select?: p2pTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2pTransfer
     */
    omit?: p2pTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2pTransferInclude<ExtArgs> | null
    where?: p2pTransferWhereInput
    orderBy?: p2pTransferOrderByWithRelationInput | p2pTransferOrderByWithRelationInput[]
    cursor?: p2pTransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: P2pTransferScalarFieldEnum | P2pTransferScalarFieldEnum[]
  }

  /**
   * User.sentRequests
   */
  export type User$sentRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the P2PRequest
     */
    select?: P2PRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the P2PRequest
     */
    omit?: P2PRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: P2PRequestInclude<ExtArgs> | null
    where?: P2PRequestWhereInput
    orderBy?: P2PRequestOrderByWithRelationInput | P2PRequestOrderByWithRelationInput[]
    cursor?: P2PRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: P2PRequestScalarFieldEnum | P2PRequestScalarFieldEnum[]
  }

  /**
   * User.receivedRequests
   */
  export type User$receivedRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the P2PRequest
     */
    select?: P2PRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the P2PRequest
     */
    omit?: P2PRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: P2PRequestInclude<ExtArgs> | null
    where?: P2PRequestWhereInput
    orderBy?: P2PRequestOrderByWithRelationInput | P2PRequestOrderByWithRelationInput[]
    cursor?: P2PRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: P2PRequestScalarFieldEnum | P2PRequestScalarFieldEnum[]
  }

  /**
   * User.billSchedules
   */
  export type User$billSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSchedule
     */
    select?: BillScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSchedule
     */
    omit?: BillScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillScheduleInclude<ExtArgs> | null
    where?: BillScheduleWhereInput
    orderBy?: BillScheduleOrderByWithRelationInput | BillScheduleOrderByWithRelationInput[]
    cursor?: BillScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillScheduleScalarFieldEnum | BillScheduleScalarFieldEnum[]
  }

  /**
   * User.merchantPayments
   */
  export type User$merchantPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantPayment
     */
    select?: MerchantPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantPayment
     */
    omit?: MerchantPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantPaymentInclude<ExtArgs> | null
    where?: MerchantPaymentWhereInput
    orderBy?: MerchantPaymentOrderByWithRelationInput | MerchantPaymentOrderByWithRelationInput[]
    cursor?: MerchantPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MerchantPaymentScalarFieldEnum | MerchantPaymentScalarFieldEnum[]
  }

  /**
   * User.rechargeOrders
   */
  export type User$rechargeOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RechargeOrder
     */
    select?: RechargeOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RechargeOrder
     */
    omit?: RechargeOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RechargeOrderInclude<ExtArgs> | null
    where?: RechargeOrderWhereInput
    orderBy?: RechargeOrderOrderByWithRelationInput | RechargeOrderOrderByWithRelationInput[]
    cursor?: RechargeOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RechargeOrderScalarFieldEnum | RechargeOrderScalarFieldEnum[]
  }

  /**
   * User.rewards
   */
  export type User$rewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    where?: RewardWhereInput
    orderBy?: RewardOrderByWithRelationInput | RewardOrderByWithRelationInput[]
    cursor?: RewardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RewardScalarFieldEnum | RewardScalarFieldEnum[]
  }

  /**
   * User.referralsAsReferrer
   */
  export type User$referralsAsReferrerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    cursor?: ReferralWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * User.referralsAsReferred
   */
  export type User$referralsAsReferredArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    cursor?: ReferralWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * User.wrongSendRequests
   */
  export type User$wrongSendRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WrongSendRequest
     */
    select?: WrongSendRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WrongSendRequest
     */
    omit?: WrongSendRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WrongSendRequestInclude<ExtArgs> | null
    where?: WrongSendRequestWhereInput
    orderBy?: WrongSendRequestOrderByWithRelationInput | WrongSendRequestOrderByWithRelationInput[]
    cursor?: WrongSendRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WrongSendRequestScalarFieldEnum | WrongSendRequestScalarFieldEnum[]
  }

  /**
   * User.createdGroups
   */
  export type User$createdGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitGroup
     */
    select?: BillSplitGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitGroup
     */
    omit?: BillSplitGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitGroupInclude<ExtArgs> | null
    where?: BillSplitGroupWhereInput
    orderBy?: BillSplitGroupOrderByWithRelationInput | BillSplitGroupOrderByWithRelationInput[]
    cursor?: BillSplitGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillSplitGroupScalarFieldEnum | BillSplitGroupScalarFieldEnum[]
  }

  /**
   * User.billSplitMembers
   */
  export type User$billSplitMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitMember
     */
    select?: BillSplitMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitMember
     */
    omit?: BillSplitMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitMemberInclude<ExtArgs> | null
    where?: BillSplitMemberWhereInput
    orderBy?: BillSplitMemberOrderByWithRelationInput | BillSplitMemberOrderByWithRelationInput[]
    cursor?: BillSplitMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillSplitMemberScalarFieldEnum | BillSplitMemberScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model p2pTransfer
   */

  export type AggregateP2pTransfer = {
    _count: P2pTransferCountAggregateOutputType | null
    _avg: P2pTransferAvgAggregateOutputType | null
    _sum: P2pTransferSumAggregateOutputType | null
    _min: P2pTransferMinAggregateOutputType | null
    _max: P2pTransferMaxAggregateOutputType | null
  }

  export type P2pTransferAvgAggregateOutputType = {
    id: number | null
    amount: number | null
    fromUserId: number | null
    toUserId: number | null
    merchantId: number | null
    latitude: number | null
    longitude: number | null
    fraudScore: number | null
  }

  export type P2pTransferSumAggregateOutputType = {
    id: number | null
    amount: number | null
    fromUserId: number | null
    toUserId: number | null
    merchantId: number | null
    latitude: number | null
    longitude: number | null
    fraudScore: number | null
  }

  export type P2pTransferMinAggregateOutputType = {
    id: number | null
    amount: number | null
    timestamp: Date | null
    fromUserId: number | null
    toUserId: number | null
    receiverNumber: string | null
    status: string | null
    razorpayPaymentId: string | null
    paymentMethod: string | null
    ipAddress: string | null
    merchantId: number | null
    latitude: number | null
    longitude: number | null
    isFraud: boolean | null
    fraudScore: number | null
    fraudReason: string | null
    riskLevel: string | null
  }

  export type P2pTransferMaxAggregateOutputType = {
    id: number | null
    amount: number | null
    timestamp: Date | null
    fromUserId: number | null
    toUserId: number | null
    receiverNumber: string | null
    status: string | null
    razorpayPaymentId: string | null
    paymentMethod: string | null
    ipAddress: string | null
    merchantId: number | null
    latitude: number | null
    longitude: number | null
    isFraud: boolean | null
    fraudScore: number | null
    fraudReason: string | null
    riskLevel: string | null
  }

  export type P2pTransferCountAggregateOutputType = {
    id: number
    amount: number
    timestamp: number
    fromUserId: number
    toUserId: number
    receiverNumber: number
    status: number
    razorpayPaymentId: number
    paymentMethod: number
    deviceInfo: number
    ipAddress: number
    merchantId: number
    latitude: number
    longitude: number
    isFraud: number
    fraudScore: number
    fraudReason: number
    riskLevel: number
    _all: number
  }


  export type P2pTransferAvgAggregateInputType = {
    id?: true
    amount?: true
    fromUserId?: true
    toUserId?: true
    merchantId?: true
    latitude?: true
    longitude?: true
    fraudScore?: true
  }

  export type P2pTransferSumAggregateInputType = {
    id?: true
    amount?: true
    fromUserId?: true
    toUserId?: true
    merchantId?: true
    latitude?: true
    longitude?: true
    fraudScore?: true
  }

  export type P2pTransferMinAggregateInputType = {
    id?: true
    amount?: true
    timestamp?: true
    fromUserId?: true
    toUserId?: true
    receiverNumber?: true
    status?: true
    razorpayPaymentId?: true
    paymentMethod?: true
    ipAddress?: true
    merchantId?: true
    latitude?: true
    longitude?: true
    isFraud?: true
    fraudScore?: true
    fraudReason?: true
    riskLevel?: true
  }

  export type P2pTransferMaxAggregateInputType = {
    id?: true
    amount?: true
    timestamp?: true
    fromUserId?: true
    toUserId?: true
    receiverNumber?: true
    status?: true
    razorpayPaymentId?: true
    paymentMethod?: true
    ipAddress?: true
    merchantId?: true
    latitude?: true
    longitude?: true
    isFraud?: true
    fraudScore?: true
    fraudReason?: true
    riskLevel?: true
  }

  export type P2pTransferCountAggregateInputType = {
    id?: true
    amount?: true
    timestamp?: true
    fromUserId?: true
    toUserId?: true
    receiverNumber?: true
    status?: true
    razorpayPaymentId?: true
    paymentMethod?: true
    deviceInfo?: true
    ipAddress?: true
    merchantId?: true
    latitude?: true
    longitude?: true
    isFraud?: true
    fraudScore?: true
    fraudReason?: true
    riskLevel?: true
    _all?: true
  }

  export type P2pTransferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which p2pTransfer to aggregate.
     */
    where?: p2pTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p2pTransfers to fetch.
     */
    orderBy?: p2pTransferOrderByWithRelationInput | p2pTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: p2pTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p2pTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p2pTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned p2pTransfers
    **/
    _count?: true | P2pTransferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: P2pTransferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: P2pTransferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: P2pTransferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: P2pTransferMaxAggregateInputType
  }

  export type GetP2pTransferAggregateType<T extends P2pTransferAggregateArgs> = {
        [P in keyof T & keyof AggregateP2pTransfer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateP2pTransfer[P]>
      : GetScalarType<T[P], AggregateP2pTransfer[P]>
  }




  export type p2pTransferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: p2pTransferWhereInput
    orderBy?: p2pTransferOrderByWithAggregationInput | p2pTransferOrderByWithAggregationInput[]
    by: P2pTransferScalarFieldEnum[] | P2pTransferScalarFieldEnum
    having?: p2pTransferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: P2pTransferCountAggregateInputType | true
    _avg?: P2pTransferAvgAggregateInputType
    _sum?: P2pTransferSumAggregateInputType
    _min?: P2pTransferMinAggregateInputType
    _max?: P2pTransferMaxAggregateInputType
  }

  export type P2pTransferGroupByOutputType = {
    id: number
    amount: number
    timestamp: Date
    fromUserId: number
    toUserId: number | null
    receiverNumber: string | null
    status: string
    razorpayPaymentId: string | null
    paymentMethod: string
    deviceInfo: JsonValue | null
    ipAddress: string | null
    merchantId: number | null
    latitude: number | null
    longitude: number | null
    isFraud: boolean | null
    fraudScore: number | null
    fraudReason: string | null
    riskLevel: string | null
    _count: P2pTransferCountAggregateOutputType | null
    _avg: P2pTransferAvgAggregateOutputType | null
    _sum: P2pTransferSumAggregateOutputType | null
    _min: P2pTransferMinAggregateOutputType | null
    _max: P2pTransferMaxAggregateOutputType | null
  }

  type GetP2pTransferGroupByPayload<T extends p2pTransferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<P2pTransferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof P2pTransferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], P2pTransferGroupByOutputType[P]>
            : GetScalarType<T[P], P2pTransferGroupByOutputType[P]>
        }
      >
    >


  export type p2pTransferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    timestamp?: boolean
    fromUserId?: boolean
    toUserId?: boolean
    receiverNumber?: boolean
    status?: boolean
    razorpayPaymentId?: boolean
    paymentMethod?: boolean
    deviceInfo?: boolean
    ipAddress?: boolean
    merchantId?: boolean
    latitude?: boolean
    longitude?: boolean
    isFraud?: boolean
    fraudScore?: boolean
    fraudReason?: boolean
    riskLevel?: boolean
    fromUser?: boolean | UserDefaultArgs<ExtArgs>
    toUser?: boolean | p2pTransfer$toUserArgs<ExtArgs>
    wrongSendRequest?: boolean | p2pTransfer$wrongSendRequestArgs<ExtArgs>
    billSplitPayment?: boolean | p2pTransfer$billSplitPaymentArgs<ExtArgs>
  }, ExtArgs["result"]["p2pTransfer"]>

  export type p2pTransferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    timestamp?: boolean
    fromUserId?: boolean
    toUserId?: boolean
    receiverNumber?: boolean
    status?: boolean
    razorpayPaymentId?: boolean
    paymentMethod?: boolean
    deviceInfo?: boolean
    ipAddress?: boolean
    merchantId?: boolean
    latitude?: boolean
    longitude?: boolean
    isFraud?: boolean
    fraudScore?: boolean
    fraudReason?: boolean
    riskLevel?: boolean
    fromUser?: boolean | UserDefaultArgs<ExtArgs>
    toUser?: boolean | p2pTransfer$toUserArgs<ExtArgs>
  }, ExtArgs["result"]["p2pTransfer"]>

  export type p2pTransferSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    timestamp?: boolean
    fromUserId?: boolean
    toUserId?: boolean
    receiverNumber?: boolean
    status?: boolean
    razorpayPaymentId?: boolean
    paymentMethod?: boolean
    deviceInfo?: boolean
    ipAddress?: boolean
    merchantId?: boolean
    latitude?: boolean
    longitude?: boolean
    isFraud?: boolean
    fraudScore?: boolean
    fraudReason?: boolean
    riskLevel?: boolean
    fromUser?: boolean | UserDefaultArgs<ExtArgs>
    toUser?: boolean | p2pTransfer$toUserArgs<ExtArgs>
  }, ExtArgs["result"]["p2pTransfer"]>

  export type p2pTransferSelectScalar = {
    id?: boolean
    amount?: boolean
    timestamp?: boolean
    fromUserId?: boolean
    toUserId?: boolean
    receiverNumber?: boolean
    status?: boolean
    razorpayPaymentId?: boolean
    paymentMethod?: boolean
    deviceInfo?: boolean
    ipAddress?: boolean
    merchantId?: boolean
    latitude?: boolean
    longitude?: boolean
    isFraud?: boolean
    fraudScore?: boolean
    fraudReason?: boolean
    riskLevel?: boolean
  }

  export type p2pTransferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "timestamp" | "fromUserId" | "toUserId" | "receiverNumber" | "status" | "razorpayPaymentId" | "paymentMethod" | "deviceInfo" | "ipAddress" | "merchantId" | "latitude" | "longitude" | "isFraud" | "fraudScore" | "fraudReason" | "riskLevel", ExtArgs["result"]["p2pTransfer"]>
  export type p2pTransferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromUser?: boolean | UserDefaultArgs<ExtArgs>
    toUser?: boolean | p2pTransfer$toUserArgs<ExtArgs>
    wrongSendRequest?: boolean | p2pTransfer$wrongSendRequestArgs<ExtArgs>
    billSplitPayment?: boolean | p2pTransfer$billSplitPaymentArgs<ExtArgs>
  }
  export type p2pTransferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromUser?: boolean | UserDefaultArgs<ExtArgs>
    toUser?: boolean | p2pTransfer$toUserArgs<ExtArgs>
  }
  export type p2pTransferIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromUser?: boolean | UserDefaultArgs<ExtArgs>
    toUser?: boolean | p2pTransfer$toUserArgs<ExtArgs>
  }

  export type $p2pTransferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "p2pTransfer"
    objects: {
      fromUser: Prisma.$UserPayload<ExtArgs>
      toUser: Prisma.$UserPayload<ExtArgs> | null
      wrongSendRequest: Prisma.$WrongSendRequestPayload<ExtArgs> | null
      billSplitPayment: Prisma.$BillSplitPaymentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      amount: number
      timestamp: Date
      fromUserId: number
      toUserId: number | null
      receiverNumber: string | null
      status: string
      razorpayPaymentId: string | null
      paymentMethod: string
      deviceInfo: Prisma.JsonValue | null
      ipAddress: string | null
      merchantId: number | null
      latitude: number | null
      longitude: number | null
      isFraud: boolean | null
      fraudScore: number | null
      fraudReason: string | null
      riskLevel: string | null
    }, ExtArgs["result"]["p2pTransfer"]>
    composites: {}
  }

  type p2pTransferGetPayload<S extends boolean | null | undefined | p2pTransferDefaultArgs> = $Result.GetResult<Prisma.$p2pTransferPayload, S>

  type p2pTransferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<p2pTransferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: P2pTransferCountAggregateInputType | true
    }

  export interface p2pTransferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['p2pTransfer'], meta: { name: 'p2pTransfer' } }
    /**
     * Find zero or one P2pTransfer that matches the filter.
     * @param {p2pTransferFindUniqueArgs} args - Arguments to find a P2pTransfer
     * @example
     * // Get one P2pTransfer
     * const p2pTransfer = await prisma.p2pTransfer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends p2pTransferFindUniqueArgs>(args: SelectSubset<T, p2pTransferFindUniqueArgs<ExtArgs>>): Prisma__p2pTransferClient<$Result.GetResult<Prisma.$p2pTransferPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one P2pTransfer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {p2pTransferFindUniqueOrThrowArgs} args - Arguments to find a P2pTransfer
     * @example
     * // Get one P2pTransfer
     * const p2pTransfer = await prisma.p2pTransfer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends p2pTransferFindUniqueOrThrowArgs>(args: SelectSubset<T, p2pTransferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__p2pTransferClient<$Result.GetResult<Prisma.$p2pTransferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first P2pTransfer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2pTransferFindFirstArgs} args - Arguments to find a P2pTransfer
     * @example
     * // Get one P2pTransfer
     * const p2pTransfer = await prisma.p2pTransfer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends p2pTransferFindFirstArgs>(args?: SelectSubset<T, p2pTransferFindFirstArgs<ExtArgs>>): Prisma__p2pTransferClient<$Result.GetResult<Prisma.$p2pTransferPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first P2pTransfer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2pTransferFindFirstOrThrowArgs} args - Arguments to find a P2pTransfer
     * @example
     * // Get one P2pTransfer
     * const p2pTransfer = await prisma.p2pTransfer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends p2pTransferFindFirstOrThrowArgs>(args?: SelectSubset<T, p2pTransferFindFirstOrThrowArgs<ExtArgs>>): Prisma__p2pTransferClient<$Result.GetResult<Prisma.$p2pTransferPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more P2pTransfers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2pTransferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all P2pTransfers
     * const p2pTransfers = await prisma.p2pTransfer.findMany()
     * 
     * // Get first 10 P2pTransfers
     * const p2pTransfers = await prisma.p2pTransfer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const p2pTransferWithIdOnly = await prisma.p2pTransfer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends p2pTransferFindManyArgs>(args?: SelectSubset<T, p2pTransferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p2pTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a P2pTransfer.
     * @param {p2pTransferCreateArgs} args - Arguments to create a P2pTransfer.
     * @example
     * // Create one P2pTransfer
     * const P2pTransfer = await prisma.p2pTransfer.create({
     *   data: {
     *     // ... data to create a P2pTransfer
     *   }
     * })
     * 
     */
    create<T extends p2pTransferCreateArgs>(args: SelectSubset<T, p2pTransferCreateArgs<ExtArgs>>): Prisma__p2pTransferClient<$Result.GetResult<Prisma.$p2pTransferPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many P2pTransfers.
     * @param {p2pTransferCreateManyArgs} args - Arguments to create many P2pTransfers.
     * @example
     * // Create many P2pTransfers
     * const p2pTransfer = await prisma.p2pTransfer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends p2pTransferCreateManyArgs>(args?: SelectSubset<T, p2pTransferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many P2pTransfers and returns the data saved in the database.
     * @param {p2pTransferCreateManyAndReturnArgs} args - Arguments to create many P2pTransfers.
     * @example
     * // Create many P2pTransfers
     * const p2pTransfer = await prisma.p2pTransfer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many P2pTransfers and only return the `id`
     * const p2pTransferWithIdOnly = await prisma.p2pTransfer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends p2pTransferCreateManyAndReturnArgs>(args?: SelectSubset<T, p2pTransferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p2pTransferPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a P2pTransfer.
     * @param {p2pTransferDeleteArgs} args - Arguments to delete one P2pTransfer.
     * @example
     * // Delete one P2pTransfer
     * const P2pTransfer = await prisma.p2pTransfer.delete({
     *   where: {
     *     // ... filter to delete one P2pTransfer
     *   }
     * })
     * 
     */
    delete<T extends p2pTransferDeleteArgs>(args: SelectSubset<T, p2pTransferDeleteArgs<ExtArgs>>): Prisma__p2pTransferClient<$Result.GetResult<Prisma.$p2pTransferPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one P2pTransfer.
     * @param {p2pTransferUpdateArgs} args - Arguments to update one P2pTransfer.
     * @example
     * // Update one P2pTransfer
     * const p2pTransfer = await prisma.p2pTransfer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends p2pTransferUpdateArgs>(args: SelectSubset<T, p2pTransferUpdateArgs<ExtArgs>>): Prisma__p2pTransferClient<$Result.GetResult<Prisma.$p2pTransferPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more P2pTransfers.
     * @param {p2pTransferDeleteManyArgs} args - Arguments to filter P2pTransfers to delete.
     * @example
     * // Delete a few P2pTransfers
     * const { count } = await prisma.p2pTransfer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends p2pTransferDeleteManyArgs>(args?: SelectSubset<T, p2pTransferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more P2pTransfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2pTransferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many P2pTransfers
     * const p2pTransfer = await prisma.p2pTransfer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends p2pTransferUpdateManyArgs>(args: SelectSubset<T, p2pTransferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more P2pTransfers and returns the data updated in the database.
     * @param {p2pTransferUpdateManyAndReturnArgs} args - Arguments to update many P2pTransfers.
     * @example
     * // Update many P2pTransfers
     * const p2pTransfer = await prisma.p2pTransfer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more P2pTransfers and only return the `id`
     * const p2pTransferWithIdOnly = await prisma.p2pTransfer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends p2pTransferUpdateManyAndReturnArgs>(args: SelectSubset<T, p2pTransferUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p2pTransferPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one P2pTransfer.
     * @param {p2pTransferUpsertArgs} args - Arguments to update or create a P2pTransfer.
     * @example
     * // Update or create a P2pTransfer
     * const p2pTransfer = await prisma.p2pTransfer.upsert({
     *   create: {
     *     // ... data to create a P2pTransfer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the P2pTransfer we want to update
     *   }
     * })
     */
    upsert<T extends p2pTransferUpsertArgs>(args: SelectSubset<T, p2pTransferUpsertArgs<ExtArgs>>): Prisma__p2pTransferClient<$Result.GetResult<Prisma.$p2pTransferPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of P2pTransfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2pTransferCountArgs} args - Arguments to filter P2pTransfers to count.
     * @example
     * // Count the number of P2pTransfers
     * const count = await prisma.p2pTransfer.count({
     *   where: {
     *     // ... the filter for the P2pTransfers we want to count
     *   }
     * })
    **/
    count<T extends p2pTransferCountArgs>(
      args?: Subset<T, p2pTransferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], P2pTransferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a P2pTransfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {P2pTransferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends P2pTransferAggregateArgs>(args: Subset<T, P2pTransferAggregateArgs>): Prisma.PrismaPromise<GetP2pTransferAggregateType<T>>

    /**
     * Group by P2pTransfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p2pTransferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends p2pTransferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: p2pTransferGroupByArgs['orderBy'] }
        : { orderBy?: p2pTransferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, p2pTransferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetP2pTransferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the p2pTransfer model
   */
  readonly fields: p2pTransferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for p2pTransfer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__p2pTransferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fromUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    toUser<T extends p2pTransfer$toUserArgs<ExtArgs> = {}>(args?: Subset<T, p2pTransfer$toUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    wrongSendRequest<T extends p2pTransfer$wrongSendRequestArgs<ExtArgs> = {}>(args?: Subset<T, p2pTransfer$wrongSendRequestArgs<ExtArgs>>): Prisma__WrongSendRequestClient<$Result.GetResult<Prisma.$WrongSendRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    billSplitPayment<T extends p2pTransfer$billSplitPaymentArgs<ExtArgs> = {}>(args?: Subset<T, p2pTransfer$billSplitPaymentArgs<ExtArgs>>): Prisma__BillSplitPaymentClient<$Result.GetResult<Prisma.$BillSplitPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the p2pTransfer model
   */
  interface p2pTransferFieldRefs {
    readonly id: FieldRef<"p2pTransfer", 'Int'>
    readonly amount: FieldRef<"p2pTransfer", 'Int'>
    readonly timestamp: FieldRef<"p2pTransfer", 'DateTime'>
    readonly fromUserId: FieldRef<"p2pTransfer", 'Int'>
    readonly toUserId: FieldRef<"p2pTransfer", 'Int'>
    readonly receiverNumber: FieldRef<"p2pTransfer", 'String'>
    readonly status: FieldRef<"p2pTransfer", 'String'>
    readonly razorpayPaymentId: FieldRef<"p2pTransfer", 'String'>
    readonly paymentMethod: FieldRef<"p2pTransfer", 'String'>
    readonly deviceInfo: FieldRef<"p2pTransfer", 'Json'>
    readonly ipAddress: FieldRef<"p2pTransfer", 'String'>
    readonly merchantId: FieldRef<"p2pTransfer", 'Int'>
    readonly latitude: FieldRef<"p2pTransfer", 'Float'>
    readonly longitude: FieldRef<"p2pTransfer", 'Float'>
    readonly isFraud: FieldRef<"p2pTransfer", 'Boolean'>
    readonly fraudScore: FieldRef<"p2pTransfer", 'Float'>
    readonly fraudReason: FieldRef<"p2pTransfer", 'String'>
    readonly riskLevel: FieldRef<"p2pTransfer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * p2pTransfer findUnique
   */
  export type p2pTransferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2pTransfer
     */
    select?: p2pTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2pTransfer
     */
    omit?: p2pTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2pTransferInclude<ExtArgs> | null
    /**
     * Filter, which p2pTransfer to fetch.
     */
    where: p2pTransferWhereUniqueInput
  }

  /**
   * p2pTransfer findUniqueOrThrow
   */
  export type p2pTransferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2pTransfer
     */
    select?: p2pTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2pTransfer
     */
    omit?: p2pTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2pTransferInclude<ExtArgs> | null
    /**
     * Filter, which p2pTransfer to fetch.
     */
    where: p2pTransferWhereUniqueInput
  }

  /**
   * p2pTransfer findFirst
   */
  export type p2pTransferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2pTransfer
     */
    select?: p2pTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2pTransfer
     */
    omit?: p2pTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2pTransferInclude<ExtArgs> | null
    /**
     * Filter, which p2pTransfer to fetch.
     */
    where?: p2pTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p2pTransfers to fetch.
     */
    orderBy?: p2pTransferOrderByWithRelationInput | p2pTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for p2pTransfers.
     */
    cursor?: p2pTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p2pTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p2pTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of p2pTransfers.
     */
    distinct?: P2pTransferScalarFieldEnum | P2pTransferScalarFieldEnum[]
  }

  /**
   * p2pTransfer findFirstOrThrow
   */
  export type p2pTransferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2pTransfer
     */
    select?: p2pTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2pTransfer
     */
    omit?: p2pTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2pTransferInclude<ExtArgs> | null
    /**
     * Filter, which p2pTransfer to fetch.
     */
    where?: p2pTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p2pTransfers to fetch.
     */
    orderBy?: p2pTransferOrderByWithRelationInput | p2pTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for p2pTransfers.
     */
    cursor?: p2pTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p2pTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p2pTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of p2pTransfers.
     */
    distinct?: P2pTransferScalarFieldEnum | P2pTransferScalarFieldEnum[]
  }

  /**
   * p2pTransfer findMany
   */
  export type p2pTransferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2pTransfer
     */
    select?: p2pTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2pTransfer
     */
    omit?: p2pTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2pTransferInclude<ExtArgs> | null
    /**
     * Filter, which p2pTransfers to fetch.
     */
    where?: p2pTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p2pTransfers to fetch.
     */
    orderBy?: p2pTransferOrderByWithRelationInput | p2pTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing p2pTransfers.
     */
    cursor?: p2pTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p2pTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p2pTransfers.
     */
    skip?: number
    distinct?: P2pTransferScalarFieldEnum | P2pTransferScalarFieldEnum[]
  }

  /**
   * p2pTransfer create
   */
  export type p2pTransferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2pTransfer
     */
    select?: p2pTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2pTransfer
     */
    omit?: p2pTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2pTransferInclude<ExtArgs> | null
    /**
     * The data needed to create a p2pTransfer.
     */
    data: XOR<p2pTransferCreateInput, p2pTransferUncheckedCreateInput>
  }

  /**
   * p2pTransfer createMany
   */
  export type p2pTransferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many p2pTransfers.
     */
    data: p2pTransferCreateManyInput | p2pTransferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * p2pTransfer createManyAndReturn
   */
  export type p2pTransferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2pTransfer
     */
    select?: p2pTransferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the p2pTransfer
     */
    omit?: p2pTransferOmit<ExtArgs> | null
    /**
     * The data used to create many p2pTransfers.
     */
    data: p2pTransferCreateManyInput | p2pTransferCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2pTransferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * p2pTransfer update
   */
  export type p2pTransferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2pTransfer
     */
    select?: p2pTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2pTransfer
     */
    omit?: p2pTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2pTransferInclude<ExtArgs> | null
    /**
     * The data needed to update a p2pTransfer.
     */
    data: XOR<p2pTransferUpdateInput, p2pTransferUncheckedUpdateInput>
    /**
     * Choose, which p2pTransfer to update.
     */
    where: p2pTransferWhereUniqueInput
  }

  /**
   * p2pTransfer updateMany
   */
  export type p2pTransferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update p2pTransfers.
     */
    data: XOR<p2pTransferUpdateManyMutationInput, p2pTransferUncheckedUpdateManyInput>
    /**
     * Filter which p2pTransfers to update
     */
    where?: p2pTransferWhereInput
    /**
     * Limit how many p2pTransfers to update.
     */
    limit?: number
  }

  /**
   * p2pTransfer updateManyAndReturn
   */
  export type p2pTransferUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2pTransfer
     */
    select?: p2pTransferSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the p2pTransfer
     */
    omit?: p2pTransferOmit<ExtArgs> | null
    /**
     * The data used to update p2pTransfers.
     */
    data: XOR<p2pTransferUpdateManyMutationInput, p2pTransferUncheckedUpdateManyInput>
    /**
     * Filter which p2pTransfers to update
     */
    where?: p2pTransferWhereInput
    /**
     * Limit how many p2pTransfers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2pTransferIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * p2pTransfer upsert
   */
  export type p2pTransferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2pTransfer
     */
    select?: p2pTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2pTransfer
     */
    omit?: p2pTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2pTransferInclude<ExtArgs> | null
    /**
     * The filter to search for the p2pTransfer to update in case it exists.
     */
    where: p2pTransferWhereUniqueInput
    /**
     * In case the p2pTransfer found by the `where` argument doesn't exist, create a new p2pTransfer with this data.
     */
    create: XOR<p2pTransferCreateInput, p2pTransferUncheckedCreateInput>
    /**
     * In case the p2pTransfer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<p2pTransferUpdateInput, p2pTransferUncheckedUpdateInput>
  }

  /**
   * p2pTransfer delete
   */
  export type p2pTransferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2pTransfer
     */
    select?: p2pTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2pTransfer
     */
    omit?: p2pTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2pTransferInclude<ExtArgs> | null
    /**
     * Filter which p2pTransfer to delete.
     */
    where: p2pTransferWhereUniqueInput
  }

  /**
   * p2pTransfer deleteMany
   */
  export type p2pTransferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which p2pTransfers to delete
     */
    where?: p2pTransferWhereInput
    /**
     * Limit how many p2pTransfers to delete.
     */
    limit?: number
  }

  /**
   * p2pTransfer.toUser
   */
  export type p2pTransfer$toUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * p2pTransfer.wrongSendRequest
   */
  export type p2pTransfer$wrongSendRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WrongSendRequest
     */
    select?: WrongSendRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WrongSendRequest
     */
    omit?: WrongSendRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WrongSendRequestInclude<ExtArgs> | null
    where?: WrongSendRequestWhereInput
  }

  /**
   * p2pTransfer.billSplitPayment
   */
  export type p2pTransfer$billSplitPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitPayment
     */
    select?: BillSplitPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitPayment
     */
    omit?: BillSplitPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitPaymentInclude<ExtArgs> | null
    where?: BillSplitPaymentWhereInput
  }

  /**
   * p2pTransfer without action
   */
  export type p2pTransferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2pTransfer
     */
    select?: p2pTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2pTransfer
     */
    omit?: p2pTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2pTransferInclude<ExtArgs> | null
  }


  /**
   * Model FraudLog
   */

  export type AggregateFraudLog = {
    _count: FraudLogCountAggregateOutputType | null
    _avg: FraudLogAvgAggregateOutputType | null
    _sum: FraudLogSumAggregateOutputType | null
    _min: FraudLogMinAggregateOutputType | null
    _max: FraudLogMaxAggregateOutputType | null
  }

  export type FraudLogAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    transactionId: number | null
    score: number | null
  }

  export type FraudLogSumAggregateOutputType = {
    id: number | null
    userId: number | null
    transactionId: number | null
    score: number | null
  }

  export type FraudLogMinAggregateOutputType = {
    id: number | null
    userId: number | null
    transactionId: number | null
    score: number | null
    reason: string | null
    blocked: boolean | null
    createdAt: Date | null
  }

  export type FraudLogMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    transactionId: number | null
    score: number | null
    reason: string | null
    blocked: boolean | null
    createdAt: Date | null
  }

  export type FraudLogCountAggregateOutputType = {
    id: number
    userId: number
    transactionId: number
    score: number
    reason: number
    blocked: number
    createdAt: number
    _all: number
  }


  export type FraudLogAvgAggregateInputType = {
    id?: true
    userId?: true
    transactionId?: true
    score?: true
  }

  export type FraudLogSumAggregateInputType = {
    id?: true
    userId?: true
    transactionId?: true
    score?: true
  }

  export type FraudLogMinAggregateInputType = {
    id?: true
    userId?: true
    transactionId?: true
    score?: true
    reason?: true
    blocked?: true
    createdAt?: true
  }

  export type FraudLogMaxAggregateInputType = {
    id?: true
    userId?: true
    transactionId?: true
    score?: true
    reason?: true
    blocked?: true
    createdAt?: true
  }

  export type FraudLogCountAggregateInputType = {
    id?: true
    userId?: true
    transactionId?: true
    score?: true
    reason?: true
    blocked?: true
    createdAt?: true
    _all?: true
  }

  export type FraudLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FraudLog to aggregate.
     */
    where?: FraudLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FraudLogs to fetch.
     */
    orderBy?: FraudLogOrderByWithRelationInput | FraudLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FraudLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FraudLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FraudLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FraudLogs
    **/
    _count?: true | FraudLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FraudLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FraudLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FraudLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FraudLogMaxAggregateInputType
  }

  export type GetFraudLogAggregateType<T extends FraudLogAggregateArgs> = {
        [P in keyof T & keyof AggregateFraudLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFraudLog[P]>
      : GetScalarType<T[P], AggregateFraudLog[P]>
  }




  export type FraudLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FraudLogWhereInput
    orderBy?: FraudLogOrderByWithAggregationInput | FraudLogOrderByWithAggregationInput[]
    by: FraudLogScalarFieldEnum[] | FraudLogScalarFieldEnum
    having?: FraudLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FraudLogCountAggregateInputType | true
    _avg?: FraudLogAvgAggregateInputType
    _sum?: FraudLogSumAggregateInputType
    _min?: FraudLogMinAggregateInputType
    _max?: FraudLogMaxAggregateInputType
  }

  export type FraudLogGroupByOutputType = {
    id: number
    userId: number
    transactionId: number | null
    score: number
    reason: string
    blocked: boolean
    createdAt: Date
    _count: FraudLogCountAggregateOutputType | null
    _avg: FraudLogAvgAggregateOutputType | null
    _sum: FraudLogSumAggregateOutputType | null
    _min: FraudLogMinAggregateOutputType | null
    _max: FraudLogMaxAggregateOutputType | null
  }

  type GetFraudLogGroupByPayload<T extends FraudLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FraudLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FraudLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FraudLogGroupByOutputType[P]>
            : GetScalarType<T[P], FraudLogGroupByOutputType[P]>
        }
      >
    >


  export type FraudLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    transactionId?: boolean
    score?: boolean
    reason?: boolean
    blocked?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["fraudLog"]>

  export type FraudLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    transactionId?: boolean
    score?: boolean
    reason?: boolean
    blocked?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["fraudLog"]>

  export type FraudLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    transactionId?: boolean
    score?: boolean
    reason?: boolean
    blocked?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["fraudLog"]>

  export type FraudLogSelectScalar = {
    id?: boolean
    userId?: boolean
    transactionId?: boolean
    score?: boolean
    reason?: boolean
    blocked?: boolean
    createdAt?: boolean
  }

  export type FraudLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "transactionId" | "score" | "reason" | "blocked" | "createdAt", ExtArgs["result"]["fraudLog"]>

  export type $FraudLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FraudLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      transactionId: number | null
      score: number
      reason: string
      blocked: boolean
      createdAt: Date
    }, ExtArgs["result"]["fraudLog"]>
    composites: {}
  }

  type FraudLogGetPayload<S extends boolean | null | undefined | FraudLogDefaultArgs> = $Result.GetResult<Prisma.$FraudLogPayload, S>

  type FraudLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FraudLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FraudLogCountAggregateInputType | true
    }

  export interface FraudLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FraudLog'], meta: { name: 'FraudLog' } }
    /**
     * Find zero or one FraudLog that matches the filter.
     * @param {FraudLogFindUniqueArgs} args - Arguments to find a FraudLog
     * @example
     * // Get one FraudLog
     * const fraudLog = await prisma.fraudLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FraudLogFindUniqueArgs>(args: SelectSubset<T, FraudLogFindUniqueArgs<ExtArgs>>): Prisma__FraudLogClient<$Result.GetResult<Prisma.$FraudLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FraudLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FraudLogFindUniqueOrThrowArgs} args - Arguments to find a FraudLog
     * @example
     * // Get one FraudLog
     * const fraudLog = await prisma.fraudLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FraudLogFindUniqueOrThrowArgs>(args: SelectSubset<T, FraudLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FraudLogClient<$Result.GetResult<Prisma.$FraudLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FraudLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FraudLogFindFirstArgs} args - Arguments to find a FraudLog
     * @example
     * // Get one FraudLog
     * const fraudLog = await prisma.fraudLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FraudLogFindFirstArgs>(args?: SelectSubset<T, FraudLogFindFirstArgs<ExtArgs>>): Prisma__FraudLogClient<$Result.GetResult<Prisma.$FraudLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FraudLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FraudLogFindFirstOrThrowArgs} args - Arguments to find a FraudLog
     * @example
     * // Get one FraudLog
     * const fraudLog = await prisma.fraudLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FraudLogFindFirstOrThrowArgs>(args?: SelectSubset<T, FraudLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__FraudLogClient<$Result.GetResult<Prisma.$FraudLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FraudLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FraudLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FraudLogs
     * const fraudLogs = await prisma.fraudLog.findMany()
     * 
     * // Get first 10 FraudLogs
     * const fraudLogs = await prisma.fraudLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fraudLogWithIdOnly = await prisma.fraudLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FraudLogFindManyArgs>(args?: SelectSubset<T, FraudLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FraudLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FraudLog.
     * @param {FraudLogCreateArgs} args - Arguments to create a FraudLog.
     * @example
     * // Create one FraudLog
     * const FraudLog = await prisma.fraudLog.create({
     *   data: {
     *     // ... data to create a FraudLog
     *   }
     * })
     * 
     */
    create<T extends FraudLogCreateArgs>(args: SelectSubset<T, FraudLogCreateArgs<ExtArgs>>): Prisma__FraudLogClient<$Result.GetResult<Prisma.$FraudLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FraudLogs.
     * @param {FraudLogCreateManyArgs} args - Arguments to create many FraudLogs.
     * @example
     * // Create many FraudLogs
     * const fraudLog = await prisma.fraudLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FraudLogCreateManyArgs>(args?: SelectSubset<T, FraudLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FraudLogs and returns the data saved in the database.
     * @param {FraudLogCreateManyAndReturnArgs} args - Arguments to create many FraudLogs.
     * @example
     * // Create many FraudLogs
     * const fraudLog = await prisma.fraudLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FraudLogs and only return the `id`
     * const fraudLogWithIdOnly = await prisma.fraudLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FraudLogCreateManyAndReturnArgs>(args?: SelectSubset<T, FraudLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FraudLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FraudLog.
     * @param {FraudLogDeleteArgs} args - Arguments to delete one FraudLog.
     * @example
     * // Delete one FraudLog
     * const FraudLog = await prisma.fraudLog.delete({
     *   where: {
     *     // ... filter to delete one FraudLog
     *   }
     * })
     * 
     */
    delete<T extends FraudLogDeleteArgs>(args: SelectSubset<T, FraudLogDeleteArgs<ExtArgs>>): Prisma__FraudLogClient<$Result.GetResult<Prisma.$FraudLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FraudLog.
     * @param {FraudLogUpdateArgs} args - Arguments to update one FraudLog.
     * @example
     * // Update one FraudLog
     * const fraudLog = await prisma.fraudLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FraudLogUpdateArgs>(args: SelectSubset<T, FraudLogUpdateArgs<ExtArgs>>): Prisma__FraudLogClient<$Result.GetResult<Prisma.$FraudLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FraudLogs.
     * @param {FraudLogDeleteManyArgs} args - Arguments to filter FraudLogs to delete.
     * @example
     * // Delete a few FraudLogs
     * const { count } = await prisma.fraudLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FraudLogDeleteManyArgs>(args?: SelectSubset<T, FraudLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FraudLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FraudLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FraudLogs
     * const fraudLog = await prisma.fraudLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FraudLogUpdateManyArgs>(args: SelectSubset<T, FraudLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FraudLogs and returns the data updated in the database.
     * @param {FraudLogUpdateManyAndReturnArgs} args - Arguments to update many FraudLogs.
     * @example
     * // Update many FraudLogs
     * const fraudLog = await prisma.fraudLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FraudLogs and only return the `id`
     * const fraudLogWithIdOnly = await prisma.fraudLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FraudLogUpdateManyAndReturnArgs>(args: SelectSubset<T, FraudLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FraudLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FraudLog.
     * @param {FraudLogUpsertArgs} args - Arguments to update or create a FraudLog.
     * @example
     * // Update or create a FraudLog
     * const fraudLog = await prisma.fraudLog.upsert({
     *   create: {
     *     // ... data to create a FraudLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FraudLog we want to update
     *   }
     * })
     */
    upsert<T extends FraudLogUpsertArgs>(args: SelectSubset<T, FraudLogUpsertArgs<ExtArgs>>): Prisma__FraudLogClient<$Result.GetResult<Prisma.$FraudLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FraudLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FraudLogCountArgs} args - Arguments to filter FraudLogs to count.
     * @example
     * // Count the number of FraudLogs
     * const count = await prisma.fraudLog.count({
     *   where: {
     *     // ... the filter for the FraudLogs we want to count
     *   }
     * })
    **/
    count<T extends FraudLogCountArgs>(
      args?: Subset<T, FraudLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FraudLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FraudLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FraudLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FraudLogAggregateArgs>(args: Subset<T, FraudLogAggregateArgs>): Prisma.PrismaPromise<GetFraudLogAggregateType<T>>

    /**
     * Group by FraudLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FraudLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FraudLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FraudLogGroupByArgs['orderBy'] }
        : { orderBy?: FraudLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FraudLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFraudLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FraudLog model
   */
  readonly fields: FraudLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FraudLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FraudLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FraudLog model
   */
  interface FraudLogFieldRefs {
    readonly id: FieldRef<"FraudLog", 'Int'>
    readonly userId: FieldRef<"FraudLog", 'Int'>
    readonly transactionId: FieldRef<"FraudLog", 'Int'>
    readonly score: FieldRef<"FraudLog", 'Float'>
    readonly reason: FieldRef<"FraudLog", 'String'>
    readonly blocked: FieldRef<"FraudLog", 'Boolean'>
    readonly createdAt: FieldRef<"FraudLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FraudLog findUnique
   */
  export type FraudLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FraudLog
     */
    select?: FraudLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FraudLog
     */
    omit?: FraudLogOmit<ExtArgs> | null
    /**
     * Filter, which FraudLog to fetch.
     */
    where: FraudLogWhereUniqueInput
  }

  /**
   * FraudLog findUniqueOrThrow
   */
  export type FraudLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FraudLog
     */
    select?: FraudLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FraudLog
     */
    omit?: FraudLogOmit<ExtArgs> | null
    /**
     * Filter, which FraudLog to fetch.
     */
    where: FraudLogWhereUniqueInput
  }

  /**
   * FraudLog findFirst
   */
  export type FraudLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FraudLog
     */
    select?: FraudLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FraudLog
     */
    omit?: FraudLogOmit<ExtArgs> | null
    /**
     * Filter, which FraudLog to fetch.
     */
    where?: FraudLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FraudLogs to fetch.
     */
    orderBy?: FraudLogOrderByWithRelationInput | FraudLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FraudLogs.
     */
    cursor?: FraudLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FraudLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FraudLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FraudLogs.
     */
    distinct?: FraudLogScalarFieldEnum | FraudLogScalarFieldEnum[]
  }

  /**
   * FraudLog findFirstOrThrow
   */
  export type FraudLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FraudLog
     */
    select?: FraudLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FraudLog
     */
    omit?: FraudLogOmit<ExtArgs> | null
    /**
     * Filter, which FraudLog to fetch.
     */
    where?: FraudLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FraudLogs to fetch.
     */
    orderBy?: FraudLogOrderByWithRelationInput | FraudLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FraudLogs.
     */
    cursor?: FraudLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FraudLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FraudLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FraudLogs.
     */
    distinct?: FraudLogScalarFieldEnum | FraudLogScalarFieldEnum[]
  }

  /**
   * FraudLog findMany
   */
  export type FraudLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FraudLog
     */
    select?: FraudLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FraudLog
     */
    omit?: FraudLogOmit<ExtArgs> | null
    /**
     * Filter, which FraudLogs to fetch.
     */
    where?: FraudLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FraudLogs to fetch.
     */
    orderBy?: FraudLogOrderByWithRelationInput | FraudLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FraudLogs.
     */
    cursor?: FraudLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FraudLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FraudLogs.
     */
    skip?: number
    distinct?: FraudLogScalarFieldEnum | FraudLogScalarFieldEnum[]
  }

  /**
   * FraudLog create
   */
  export type FraudLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FraudLog
     */
    select?: FraudLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FraudLog
     */
    omit?: FraudLogOmit<ExtArgs> | null
    /**
     * The data needed to create a FraudLog.
     */
    data: XOR<FraudLogCreateInput, FraudLogUncheckedCreateInput>
  }

  /**
   * FraudLog createMany
   */
  export type FraudLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FraudLogs.
     */
    data: FraudLogCreateManyInput | FraudLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FraudLog createManyAndReturn
   */
  export type FraudLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FraudLog
     */
    select?: FraudLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FraudLog
     */
    omit?: FraudLogOmit<ExtArgs> | null
    /**
     * The data used to create many FraudLogs.
     */
    data: FraudLogCreateManyInput | FraudLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FraudLog update
   */
  export type FraudLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FraudLog
     */
    select?: FraudLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FraudLog
     */
    omit?: FraudLogOmit<ExtArgs> | null
    /**
     * The data needed to update a FraudLog.
     */
    data: XOR<FraudLogUpdateInput, FraudLogUncheckedUpdateInput>
    /**
     * Choose, which FraudLog to update.
     */
    where: FraudLogWhereUniqueInput
  }

  /**
   * FraudLog updateMany
   */
  export type FraudLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FraudLogs.
     */
    data: XOR<FraudLogUpdateManyMutationInput, FraudLogUncheckedUpdateManyInput>
    /**
     * Filter which FraudLogs to update
     */
    where?: FraudLogWhereInput
    /**
     * Limit how many FraudLogs to update.
     */
    limit?: number
  }

  /**
   * FraudLog updateManyAndReturn
   */
  export type FraudLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FraudLog
     */
    select?: FraudLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FraudLog
     */
    omit?: FraudLogOmit<ExtArgs> | null
    /**
     * The data used to update FraudLogs.
     */
    data: XOR<FraudLogUpdateManyMutationInput, FraudLogUncheckedUpdateManyInput>
    /**
     * Filter which FraudLogs to update
     */
    where?: FraudLogWhereInput
    /**
     * Limit how many FraudLogs to update.
     */
    limit?: number
  }

  /**
   * FraudLog upsert
   */
  export type FraudLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FraudLog
     */
    select?: FraudLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FraudLog
     */
    omit?: FraudLogOmit<ExtArgs> | null
    /**
     * The filter to search for the FraudLog to update in case it exists.
     */
    where: FraudLogWhereUniqueInput
    /**
     * In case the FraudLog found by the `where` argument doesn't exist, create a new FraudLog with this data.
     */
    create: XOR<FraudLogCreateInput, FraudLogUncheckedCreateInput>
    /**
     * In case the FraudLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FraudLogUpdateInput, FraudLogUncheckedUpdateInput>
  }

  /**
   * FraudLog delete
   */
  export type FraudLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FraudLog
     */
    select?: FraudLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FraudLog
     */
    omit?: FraudLogOmit<ExtArgs> | null
    /**
     * Filter which FraudLog to delete.
     */
    where: FraudLogWhereUniqueInput
  }

  /**
   * FraudLog deleteMany
   */
  export type FraudLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FraudLogs to delete
     */
    where?: FraudLogWhereInput
    /**
     * Limit how many FraudLogs to delete.
     */
    limit?: number
  }

  /**
   * FraudLog without action
   */
  export type FraudLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FraudLog
     */
    select?: FraudLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FraudLog
     */
    omit?: FraudLogOmit<ExtArgs> | null
  }


  /**
   * Model Merchant
   */

  export type AggregateMerchant = {
    _count: MerchantCountAggregateOutputType | null
    _avg: MerchantAvgAggregateOutputType | null
    _sum: MerchantSumAggregateOutputType | null
    _min: MerchantMinAggregateOutputType | null
    _max: MerchantMaxAggregateOutputType | null
  }

  export type MerchantAvgAggregateOutputType = {
    id: number | null
  }

  export type MerchantSumAggregateOutputType = {
    id: number | null
  }

  export type MerchantMinAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    upiId: string | null
    auth_type: $Enums.AuthType | null
  }

  export type MerchantMaxAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    upiId: string | null
    auth_type: $Enums.AuthType | null
  }

  export type MerchantCountAggregateOutputType = {
    id: number
    email: number
    name: number
    upiId: number
    auth_type: number
    _all: number
  }


  export type MerchantAvgAggregateInputType = {
    id?: true
  }

  export type MerchantSumAggregateInputType = {
    id?: true
  }

  export type MerchantMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    upiId?: true
    auth_type?: true
  }

  export type MerchantMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    upiId?: true
    auth_type?: true
  }

  export type MerchantCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    upiId?: true
    auth_type?: true
    _all?: true
  }

  export type MerchantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Merchant to aggregate.
     */
    where?: MerchantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Merchants to fetch.
     */
    orderBy?: MerchantOrderByWithRelationInput | MerchantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MerchantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Merchants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Merchants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Merchants
    **/
    _count?: true | MerchantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MerchantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MerchantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MerchantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MerchantMaxAggregateInputType
  }

  export type GetMerchantAggregateType<T extends MerchantAggregateArgs> = {
        [P in keyof T & keyof AggregateMerchant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMerchant[P]>
      : GetScalarType<T[P], AggregateMerchant[P]>
  }




  export type MerchantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MerchantWhereInput
    orderBy?: MerchantOrderByWithAggregationInput | MerchantOrderByWithAggregationInput[]
    by: MerchantScalarFieldEnum[] | MerchantScalarFieldEnum
    having?: MerchantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MerchantCountAggregateInputType | true
    _avg?: MerchantAvgAggregateInputType
    _sum?: MerchantSumAggregateInputType
    _min?: MerchantMinAggregateInputType
    _max?: MerchantMaxAggregateInputType
  }

  export type MerchantGroupByOutputType = {
    id: number
    email: string
    name: string | null
    upiId: string | null
    auth_type: $Enums.AuthType
    _count: MerchantCountAggregateOutputType | null
    _avg: MerchantAvgAggregateOutputType | null
    _sum: MerchantSumAggregateOutputType | null
    _min: MerchantMinAggregateOutputType | null
    _max: MerchantMaxAggregateOutputType | null
  }

  type GetMerchantGroupByPayload<T extends MerchantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MerchantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MerchantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MerchantGroupByOutputType[P]>
            : GetScalarType<T[P], MerchantGroupByOutputType[P]>
        }
      >
    >


  export type MerchantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    upiId?: boolean
    auth_type?: boolean
    billSchedules?: boolean | Merchant$billSchedulesArgs<ExtArgs>
    payments?: boolean | Merchant$paymentsArgs<ExtArgs>
    _count?: boolean | MerchantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["merchant"]>

  export type MerchantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    upiId?: boolean
    auth_type?: boolean
  }, ExtArgs["result"]["merchant"]>

  export type MerchantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    upiId?: boolean
    auth_type?: boolean
  }, ExtArgs["result"]["merchant"]>

  export type MerchantSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    upiId?: boolean
    auth_type?: boolean
  }

  export type MerchantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "upiId" | "auth_type", ExtArgs["result"]["merchant"]>
  export type MerchantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    billSchedules?: boolean | Merchant$billSchedulesArgs<ExtArgs>
    payments?: boolean | Merchant$paymentsArgs<ExtArgs>
    _count?: boolean | MerchantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MerchantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MerchantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MerchantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Merchant"
    objects: {
      billSchedules: Prisma.$BillSchedulePayload<ExtArgs>[]
      payments: Prisma.$MerchantPaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      name: string | null
      upiId: string | null
      auth_type: $Enums.AuthType
    }, ExtArgs["result"]["merchant"]>
    composites: {}
  }

  type MerchantGetPayload<S extends boolean | null | undefined | MerchantDefaultArgs> = $Result.GetResult<Prisma.$MerchantPayload, S>

  type MerchantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MerchantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MerchantCountAggregateInputType | true
    }

  export interface MerchantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Merchant'], meta: { name: 'Merchant' } }
    /**
     * Find zero or one Merchant that matches the filter.
     * @param {MerchantFindUniqueArgs} args - Arguments to find a Merchant
     * @example
     * // Get one Merchant
     * const merchant = await prisma.merchant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MerchantFindUniqueArgs>(args: SelectSubset<T, MerchantFindUniqueArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Merchant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MerchantFindUniqueOrThrowArgs} args - Arguments to find a Merchant
     * @example
     * // Get one Merchant
     * const merchant = await prisma.merchant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MerchantFindUniqueOrThrowArgs>(args: SelectSubset<T, MerchantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Merchant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantFindFirstArgs} args - Arguments to find a Merchant
     * @example
     * // Get one Merchant
     * const merchant = await prisma.merchant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MerchantFindFirstArgs>(args?: SelectSubset<T, MerchantFindFirstArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Merchant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantFindFirstOrThrowArgs} args - Arguments to find a Merchant
     * @example
     * // Get one Merchant
     * const merchant = await prisma.merchant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MerchantFindFirstOrThrowArgs>(args?: SelectSubset<T, MerchantFindFirstOrThrowArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Merchants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Merchants
     * const merchants = await prisma.merchant.findMany()
     * 
     * // Get first 10 Merchants
     * const merchants = await prisma.merchant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const merchantWithIdOnly = await prisma.merchant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MerchantFindManyArgs>(args?: SelectSubset<T, MerchantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Merchant.
     * @param {MerchantCreateArgs} args - Arguments to create a Merchant.
     * @example
     * // Create one Merchant
     * const Merchant = await prisma.merchant.create({
     *   data: {
     *     // ... data to create a Merchant
     *   }
     * })
     * 
     */
    create<T extends MerchantCreateArgs>(args: SelectSubset<T, MerchantCreateArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Merchants.
     * @param {MerchantCreateManyArgs} args - Arguments to create many Merchants.
     * @example
     * // Create many Merchants
     * const merchant = await prisma.merchant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MerchantCreateManyArgs>(args?: SelectSubset<T, MerchantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Merchants and returns the data saved in the database.
     * @param {MerchantCreateManyAndReturnArgs} args - Arguments to create many Merchants.
     * @example
     * // Create many Merchants
     * const merchant = await prisma.merchant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Merchants and only return the `id`
     * const merchantWithIdOnly = await prisma.merchant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MerchantCreateManyAndReturnArgs>(args?: SelectSubset<T, MerchantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Merchant.
     * @param {MerchantDeleteArgs} args - Arguments to delete one Merchant.
     * @example
     * // Delete one Merchant
     * const Merchant = await prisma.merchant.delete({
     *   where: {
     *     // ... filter to delete one Merchant
     *   }
     * })
     * 
     */
    delete<T extends MerchantDeleteArgs>(args: SelectSubset<T, MerchantDeleteArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Merchant.
     * @param {MerchantUpdateArgs} args - Arguments to update one Merchant.
     * @example
     * // Update one Merchant
     * const merchant = await prisma.merchant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MerchantUpdateArgs>(args: SelectSubset<T, MerchantUpdateArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Merchants.
     * @param {MerchantDeleteManyArgs} args - Arguments to filter Merchants to delete.
     * @example
     * // Delete a few Merchants
     * const { count } = await prisma.merchant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MerchantDeleteManyArgs>(args?: SelectSubset<T, MerchantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Merchants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Merchants
     * const merchant = await prisma.merchant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MerchantUpdateManyArgs>(args: SelectSubset<T, MerchantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Merchants and returns the data updated in the database.
     * @param {MerchantUpdateManyAndReturnArgs} args - Arguments to update many Merchants.
     * @example
     * // Update many Merchants
     * const merchant = await prisma.merchant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Merchants and only return the `id`
     * const merchantWithIdOnly = await prisma.merchant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MerchantUpdateManyAndReturnArgs>(args: SelectSubset<T, MerchantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Merchant.
     * @param {MerchantUpsertArgs} args - Arguments to update or create a Merchant.
     * @example
     * // Update or create a Merchant
     * const merchant = await prisma.merchant.upsert({
     *   create: {
     *     // ... data to create a Merchant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Merchant we want to update
     *   }
     * })
     */
    upsert<T extends MerchantUpsertArgs>(args: SelectSubset<T, MerchantUpsertArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Merchants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantCountArgs} args - Arguments to filter Merchants to count.
     * @example
     * // Count the number of Merchants
     * const count = await prisma.merchant.count({
     *   where: {
     *     // ... the filter for the Merchants we want to count
     *   }
     * })
    **/
    count<T extends MerchantCountArgs>(
      args?: Subset<T, MerchantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MerchantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Merchant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MerchantAggregateArgs>(args: Subset<T, MerchantAggregateArgs>): Prisma.PrismaPromise<GetMerchantAggregateType<T>>

    /**
     * Group by Merchant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MerchantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MerchantGroupByArgs['orderBy'] }
        : { orderBy?: MerchantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MerchantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMerchantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Merchant model
   */
  readonly fields: MerchantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Merchant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MerchantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    billSchedules<T extends Merchant$billSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, Merchant$billSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Merchant$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Merchant$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerchantPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Merchant model
   */
  interface MerchantFieldRefs {
    readonly id: FieldRef<"Merchant", 'Int'>
    readonly email: FieldRef<"Merchant", 'String'>
    readonly name: FieldRef<"Merchant", 'String'>
    readonly upiId: FieldRef<"Merchant", 'String'>
    readonly auth_type: FieldRef<"Merchant", 'AuthType'>
  }
    

  // Custom InputTypes
  /**
   * Merchant findUnique
   */
  export type MerchantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * Filter, which Merchant to fetch.
     */
    where: MerchantWhereUniqueInput
  }

  /**
   * Merchant findUniqueOrThrow
   */
  export type MerchantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * Filter, which Merchant to fetch.
     */
    where: MerchantWhereUniqueInput
  }

  /**
   * Merchant findFirst
   */
  export type MerchantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * Filter, which Merchant to fetch.
     */
    where?: MerchantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Merchants to fetch.
     */
    orderBy?: MerchantOrderByWithRelationInput | MerchantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Merchants.
     */
    cursor?: MerchantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Merchants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Merchants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Merchants.
     */
    distinct?: MerchantScalarFieldEnum | MerchantScalarFieldEnum[]
  }

  /**
   * Merchant findFirstOrThrow
   */
  export type MerchantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * Filter, which Merchant to fetch.
     */
    where?: MerchantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Merchants to fetch.
     */
    orderBy?: MerchantOrderByWithRelationInput | MerchantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Merchants.
     */
    cursor?: MerchantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Merchants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Merchants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Merchants.
     */
    distinct?: MerchantScalarFieldEnum | MerchantScalarFieldEnum[]
  }

  /**
   * Merchant findMany
   */
  export type MerchantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * Filter, which Merchants to fetch.
     */
    where?: MerchantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Merchants to fetch.
     */
    orderBy?: MerchantOrderByWithRelationInput | MerchantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Merchants.
     */
    cursor?: MerchantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Merchants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Merchants.
     */
    skip?: number
    distinct?: MerchantScalarFieldEnum | MerchantScalarFieldEnum[]
  }

  /**
   * Merchant create
   */
  export type MerchantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * The data needed to create a Merchant.
     */
    data: XOR<MerchantCreateInput, MerchantUncheckedCreateInput>
  }

  /**
   * Merchant createMany
   */
  export type MerchantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Merchants.
     */
    data: MerchantCreateManyInput | MerchantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Merchant createManyAndReturn
   */
  export type MerchantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * The data used to create many Merchants.
     */
    data: MerchantCreateManyInput | MerchantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Merchant update
   */
  export type MerchantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * The data needed to update a Merchant.
     */
    data: XOR<MerchantUpdateInput, MerchantUncheckedUpdateInput>
    /**
     * Choose, which Merchant to update.
     */
    where: MerchantWhereUniqueInput
  }

  /**
   * Merchant updateMany
   */
  export type MerchantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Merchants.
     */
    data: XOR<MerchantUpdateManyMutationInput, MerchantUncheckedUpdateManyInput>
    /**
     * Filter which Merchants to update
     */
    where?: MerchantWhereInput
    /**
     * Limit how many Merchants to update.
     */
    limit?: number
  }

  /**
   * Merchant updateManyAndReturn
   */
  export type MerchantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * The data used to update Merchants.
     */
    data: XOR<MerchantUpdateManyMutationInput, MerchantUncheckedUpdateManyInput>
    /**
     * Filter which Merchants to update
     */
    where?: MerchantWhereInput
    /**
     * Limit how many Merchants to update.
     */
    limit?: number
  }

  /**
   * Merchant upsert
   */
  export type MerchantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * The filter to search for the Merchant to update in case it exists.
     */
    where: MerchantWhereUniqueInput
    /**
     * In case the Merchant found by the `where` argument doesn't exist, create a new Merchant with this data.
     */
    create: XOR<MerchantCreateInput, MerchantUncheckedCreateInput>
    /**
     * In case the Merchant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MerchantUpdateInput, MerchantUncheckedUpdateInput>
  }

  /**
   * Merchant delete
   */
  export type MerchantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * Filter which Merchant to delete.
     */
    where: MerchantWhereUniqueInput
  }

  /**
   * Merchant deleteMany
   */
  export type MerchantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Merchants to delete
     */
    where?: MerchantWhereInput
    /**
     * Limit how many Merchants to delete.
     */
    limit?: number
  }

  /**
   * Merchant.billSchedules
   */
  export type Merchant$billSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSchedule
     */
    select?: BillScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSchedule
     */
    omit?: BillScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillScheduleInclude<ExtArgs> | null
    where?: BillScheduleWhereInput
    orderBy?: BillScheduleOrderByWithRelationInput | BillScheduleOrderByWithRelationInput[]
    cursor?: BillScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillScheduleScalarFieldEnum | BillScheduleScalarFieldEnum[]
  }

  /**
   * Merchant.payments
   */
  export type Merchant$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantPayment
     */
    select?: MerchantPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantPayment
     */
    omit?: MerchantPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantPaymentInclude<ExtArgs> | null
    where?: MerchantPaymentWhereInput
    orderBy?: MerchantPaymentOrderByWithRelationInput | MerchantPaymentOrderByWithRelationInput[]
    cursor?: MerchantPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MerchantPaymentScalarFieldEnum | MerchantPaymentScalarFieldEnum[]
  }

  /**
   * Merchant without action
   */
  export type MerchantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
  }


  /**
   * Model MerchantPayment
   */

  export type AggregateMerchantPayment = {
    _count: MerchantPaymentCountAggregateOutputType | null
    _avg: MerchantPaymentAvgAggregateOutputType | null
    _sum: MerchantPaymentSumAggregateOutputType | null
    _min: MerchantPaymentMinAggregateOutputType | null
    _max: MerchantPaymentMaxAggregateOutputType | null
  }

  export type MerchantPaymentAvgAggregateOutputType = {
    id: number | null
    merchantId: number | null
    amount: number | null
    userId: number | null
  }

  export type MerchantPaymentSumAggregateOutputType = {
    id: number | null
    merchantId: number | null
    amount: number | null
    userId: number | null
  }

  export type MerchantPaymentMinAggregateOutputType = {
    id: number | null
    merchantId: number | null
    qrId: string | null
    amount: number | null
    status: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    transactionId: string | null
  }

  export type MerchantPaymentMaxAggregateOutputType = {
    id: number | null
    merchantId: number | null
    qrId: string | null
    amount: number | null
    status: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    transactionId: string | null
  }

  export type MerchantPaymentCountAggregateOutputType = {
    id: number
    merchantId: number
    qrId: number
    amount: number
    status: number
    userId: number
    createdAt: number
    updatedAt: number
    transactionId: number
    _all: number
  }


  export type MerchantPaymentAvgAggregateInputType = {
    id?: true
    merchantId?: true
    amount?: true
    userId?: true
  }

  export type MerchantPaymentSumAggregateInputType = {
    id?: true
    merchantId?: true
    amount?: true
    userId?: true
  }

  export type MerchantPaymentMinAggregateInputType = {
    id?: true
    merchantId?: true
    qrId?: true
    amount?: true
    status?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    transactionId?: true
  }

  export type MerchantPaymentMaxAggregateInputType = {
    id?: true
    merchantId?: true
    qrId?: true
    amount?: true
    status?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    transactionId?: true
  }

  export type MerchantPaymentCountAggregateInputType = {
    id?: true
    merchantId?: true
    qrId?: true
    amount?: true
    status?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    transactionId?: true
    _all?: true
  }

  export type MerchantPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MerchantPayment to aggregate.
     */
    where?: MerchantPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MerchantPayments to fetch.
     */
    orderBy?: MerchantPaymentOrderByWithRelationInput | MerchantPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MerchantPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MerchantPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MerchantPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MerchantPayments
    **/
    _count?: true | MerchantPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MerchantPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MerchantPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MerchantPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MerchantPaymentMaxAggregateInputType
  }

  export type GetMerchantPaymentAggregateType<T extends MerchantPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateMerchantPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMerchantPayment[P]>
      : GetScalarType<T[P], AggregateMerchantPayment[P]>
  }




  export type MerchantPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MerchantPaymentWhereInput
    orderBy?: MerchantPaymentOrderByWithAggregationInput | MerchantPaymentOrderByWithAggregationInput[]
    by: MerchantPaymentScalarFieldEnum[] | MerchantPaymentScalarFieldEnum
    having?: MerchantPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MerchantPaymentCountAggregateInputType | true
    _avg?: MerchantPaymentAvgAggregateInputType
    _sum?: MerchantPaymentSumAggregateInputType
    _min?: MerchantPaymentMinAggregateInputType
    _max?: MerchantPaymentMaxAggregateInputType
  }

  export type MerchantPaymentGroupByOutputType = {
    id: number
    merchantId: number
    qrId: string
    amount: number
    status: string
    userId: number | null
    createdAt: Date
    updatedAt: Date
    transactionId: string | null
    _count: MerchantPaymentCountAggregateOutputType | null
    _avg: MerchantPaymentAvgAggregateOutputType | null
    _sum: MerchantPaymentSumAggregateOutputType | null
    _min: MerchantPaymentMinAggregateOutputType | null
    _max: MerchantPaymentMaxAggregateOutputType | null
  }

  type GetMerchantPaymentGroupByPayload<T extends MerchantPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MerchantPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MerchantPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MerchantPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], MerchantPaymentGroupByOutputType[P]>
        }
      >
    >


  export type MerchantPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    merchantId?: boolean
    qrId?: boolean
    amount?: boolean
    status?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transactionId?: boolean
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
    user?: boolean | MerchantPayment$userArgs<ExtArgs>
  }, ExtArgs["result"]["merchantPayment"]>

  export type MerchantPaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    merchantId?: boolean
    qrId?: boolean
    amount?: boolean
    status?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transactionId?: boolean
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
    user?: boolean | MerchantPayment$userArgs<ExtArgs>
  }, ExtArgs["result"]["merchantPayment"]>

  export type MerchantPaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    merchantId?: boolean
    qrId?: boolean
    amount?: boolean
    status?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transactionId?: boolean
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
    user?: boolean | MerchantPayment$userArgs<ExtArgs>
  }, ExtArgs["result"]["merchantPayment"]>

  export type MerchantPaymentSelectScalar = {
    id?: boolean
    merchantId?: boolean
    qrId?: boolean
    amount?: boolean
    status?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transactionId?: boolean
  }

  export type MerchantPaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "merchantId" | "qrId" | "amount" | "status" | "userId" | "createdAt" | "updatedAt" | "transactionId", ExtArgs["result"]["merchantPayment"]>
  export type MerchantPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
    user?: boolean | MerchantPayment$userArgs<ExtArgs>
  }
  export type MerchantPaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
    user?: boolean | MerchantPayment$userArgs<ExtArgs>
  }
  export type MerchantPaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
    user?: boolean | MerchantPayment$userArgs<ExtArgs>
  }

  export type $MerchantPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MerchantPayment"
    objects: {
      merchant: Prisma.$MerchantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      merchantId: number
      qrId: string
      amount: number
      status: string
      userId: number | null
      createdAt: Date
      updatedAt: Date
      transactionId: string | null
    }, ExtArgs["result"]["merchantPayment"]>
    composites: {}
  }

  type MerchantPaymentGetPayload<S extends boolean | null | undefined | MerchantPaymentDefaultArgs> = $Result.GetResult<Prisma.$MerchantPaymentPayload, S>

  type MerchantPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MerchantPaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MerchantPaymentCountAggregateInputType | true
    }

  export interface MerchantPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MerchantPayment'], meta: { name: 'MerchantPayment' } }
    /**
     * Find zero or one MerchantPayment that matches the filter.
     * @param {MerchantPaymentFindUniqueArgs} args - Arguments to find a MerchantPayment
     * @example
     * // Get one MerchantPayment
     * const merchantPayment = await prisma.merchantPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MerchantPaymentFindUniqueArgs>(args: SelectSubset<T, MerchantPaymentFindUniqueArgs<ExtArgs>>): Prisma__MerchantPaymentClient<$Result.GetResult<Prisma.$MerchantPaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MerchantPayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MerchantPaymentFindUniqueOrThrowArgs} args - Arguments to find a MerchantPayment
     * @example
     * // Get one MerchantPayment
     * const merchantPayment = await prisma.merchantPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MerchantPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, MerchantPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MerchantPaymentClient<$Result.GetResult<Prisma.$MerchantPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MerchantPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantPaymentFindFirstArgs} args - Arguments to find a MerchantPayment
     * @example
     * // Get one MerchantPayment
     * const merchantPayment = await prisma.merchantPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MerchantPaymentFindFirstArgs>(args?: SelectSubset<T, MerchantPaymentFindFirstArgs<ExtArgs>>): Prisma__MerchantPaymentClient<$Result.GetResult<Prisma.$MerchantPaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MerchantPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantPaymentFindFirstOrThrowArgs} args - Arguments to find a MerchantPayment
     * @example
     * // Get one MerchantPayment
     * const merchantPayment = await prisma.merchantPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MerchantPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, MerchantPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__MerchantPaymentClient<$Result.GetResult<Prisma.$MerchantPaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MerchantPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MerchantPayments
     * const merchantPayments = await prisma.merchantPayment.findMany()
     * 
     * // Get first 10 MerchantPayments
     * const merchantPayments = await prisma.merchantPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const merchantPaymentWithIdOnly = await prisma.merchantPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MerchantPaymentFindManyArgs>(args?: SelectSubset<T, MerchantPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerchantPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MerchantPayment.
     * @param {MerchantPaymentCreateArgs} args - Arguments to create a MerchantPayment.
     * @example
     * // Create one MerchantPayment
     * const MerchantPayment = await prisma.merchantPayment.create({
     *   data: {
     *     // ... data to create a MerchantPayment
     *   }
     * })
     * 
     */
    create<T extends MerchantPaymentCreateArgs>(args: SelectSubset<T, MerchantPaymentCreateArgs<ExtArgs>>): Prisma__MerchantPaymentClient<$Result.GetResult<Prisma.$MerchantPaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MerchantPayments.
     * @param {MerchantPaymentCreateManyArgs} args - Arguments to create many MerchantPayments.
     * @example
     * // Create many MerchantPayments
     * const merchantPayment = await prisma.merchantPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MerchantPaymentCreateManyArgs>(args?: SelectSubset<T, MerchantPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MerchantPayments and returns the data saved in the database.
     * @param {MerchantPaymentCreateManyAndReturnArgs} args - Arguments to create many MerchantPayments.
     * @example
     * // Create many MerchantPayments
     * const merchantPayment = await prisma.merchantPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MerchantPayments and only return the `id`
     * const merchantPaymentWithIdOnly = await prisma.merchantPayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MerchantPaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, MerchantPaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerchantPaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MerchantPayment.
     * @param {MerchantPaymentDeleteArgs} args - Arguments to delete one MerchantPayment.
     * @example
     * // Delete one MerchantPayment
     * const MerchantPayment = await prisma.merchantPayment.delete({
     *   where: {
     *     // ... filter to delete one MerchantPayment
     *   }
     * })
     * 
     */
    delete<T extends MerchantPaymentDeleteArgs>(args: SelectSubset<T, MerchantPaymentDeleteArgs<ExtArgs>>): Prisma__MerchantPaymentClient<$Result.GetResult<Prisma.$MerchantPaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MerchantPayment.
     * @param {MerchantPaymentUpdateArgs} args - Arguments to update one MerchantPayment.
     * @example
     * // Update one MerchantPayment
     * const merchantPayment = await prisma.merchantPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MerchantPaymentUpdateArgs>(args: SelectSubset<T, MerchantPaymentUpdateArgs<ExtArgs>>): Prisma__MerchantPaymentClient<$Result.GetResult<Prisma.$MerchantPaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MerchantPayments.
     * @param {MerchantPaymentDeleteManyArgs} args - Arguments to filter MerchantPayments to delete.
     * @example
     * // Delete a few MerchantPayments
     * const { count } = await prisma.merchantPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MerchantPaymentDeleteManyArgs>(args?: SelectSubset<T, MerchantPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MerchantPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MerchantPayments
     * const merchantPayment = await prisma.merchantPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MerchantPaymentUpdateManyArgs>(args: SelectSubset<T, MerchantPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MerchantPayments and returns the data updated in the database.
     * @param {MerchantPaymentUpdateManyAndReturnArgs} args - Arguments to update many MerchantPayments.
     * @example
     * // Update many MerchantPayments
     * const merchantPayment = await prisma.merchantPayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MerchantPayments and only return the `id`
     * const merchantPaymentWithIdOnly = await prisma.merchantPayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MerchantPaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, MerchantPaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerchantPaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MerchantPayment.
     * @param {MerchantPaymentUpsertArgs} args - Arguments to update or create a MerchantPayment.
     * @example
     * // Update or create a MerchantPayment
     * const merchantPayment = await prisma.merchantPayment.upsert({
     *   create: {
     *     // ... data to create a MerchantPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MerchantPayment we want to update
     *   }
     * })
     */
    upsert<T extends MerchantPaymentUpsertArgs>(args: SelectSubset<T, MerchantPaymentUpsertArgs<ExtArgs>>): Prisma__MerchantPaymentClient<$Result.GetResult<Prisma.$MerchantPaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MerchantPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantPaymentCountArgs} args - Arguments to filter MerchantPayments to count.
     * @example
     * // Count the number of MerchantPayments
     * const count = await prisma.merchantPayment.count({
     *   where: {
     *     // ... the filter for the MerchantPayments we want to count
     *   }
     * })
    **/
    count<T extends MerchantPaymentCountArgs>(
      args?: Subset<T, MerchantPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MerchantPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MerchantPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MerchantPaymentAggregateArgs>(args: Subset<T, MerchantPaymentAggregateArgs>): Prisma.PrismaPromise<GetMerchantPaymentAggregateType<T>>

    /**
     * Group by MerchantPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MerchantPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MerchantPaymentGroupByArgs['orderBy'] }
        : { orderBy?: MerchantPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MerchantPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMerchantPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MerchantPayment model
   */
  readonly fields: MerchantPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MerchantPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MerchantPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    merchant<T extends MerchantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MerchantDefaultArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends MerchantPayment$userArgs<ExtArgs> = {}>(args?: Subset<T, MerchantPayment$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MerchantPayment model
   */
  interface MerchantPaymentFieldRefs {
    readonly id: FieldRef<"MerchantPayment", 'Int'>
    readonly merchantId: FieldRef<"MerchantPayment", 'Int'>
    readonly qrId: FieldRef<"MerchantPayment", 'String'>
    readonly amount: FieldRef<"MerchantPayment", 'Int'>
    readonly status: FieldRef<"MerchantPayment", 'String'>
    readonly userId: FieldRef<"MerchantPayment", 'Int'>
    readonly createdAt: FieldRef<"MerchantPayment", 'DateTime'>
    readonly updatedAt: FieldRef<"MerchantPayment", 'DateTime'>
    readonly transactionId: FieldRef<"MerchantPayment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MerchantPayment findUnique
   */
  export type MerchantPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantPayment
     */
    select?: MerchantPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantPayment
     */
    omit?: MerchantPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantPaymentInclude<ExtArgs> | null
    /**
     * Filter, which MerchantPayment to fetch.
     */
    where: MerchantPaymentWhereUniqueInput
  }

  /**
   * MerchantPayment findUniqueOrThrow
   */
  export type MerchantPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantPayment
     */
    select?: MerchantPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantPayment
     */
    omit?: MerchantPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantPaymentInclude<ExtArgs> | null
    /**
     * Filter, which MerchantPayment to fetch.
     */
    where: MerchantPaymentWhereUniqueInput
  }

  /**
   * MerchantPayment findFirst
   */
  export type MerchantPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantPayment
     */
    select?: MerchantPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantPayment
     */
    omit?: MerchantPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantPaymentInclude<ExtArgs> | null
    /**
     * Filter, which MerchantPayment to fetch.
     */
    where?: MerchantPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MerchantPayments to fetch.
     */
    orderBy?: MerchantPaymentOrderByWithRelationInput | MerchantPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MerchantPayments.
     */
    cursor?: MerchantPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MerchantPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MerchantPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MerchantPayments.
     */
    distinct?: MerchantPaymentScalarFieldEnum | MerchantPaymentScalarFieldEnum[]
  }

  /**
   * MerchantPayment findFirstOrThrow
   */
  export type MerchantPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantPayment
     */
    select?: MerchantPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantPayment
     */
    omit?: MerchantPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantPaymentInclude<ExtArgs> | null
    /**
     * Filter, which MerchantPayment to fetch.
     */
    where?: MerchantPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MerchantPayments to fetch.
     */
    orderBy?: MerchantPaymentOrderByWithRelationInput | MerchantPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MerchantPayments.
     */
    cursor?: MerchantPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MerchantPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MerchantPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MerchantPayments.
     */
    distinct?: MerchantPaymentScalarFieldEnum | MerchantPaymentScalarFieldEnum[]
  }

  /**
   * MerchantPayment findMany
   */
  export type MerchantPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantPayment
     */
    select?: MerchantPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantPayment
     */
    omit?: MerchantPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantPaymentInclude<ExtArgs> | null
    /**
     * Filter, which MerchantPayments to fetch.
     */
    where?: MerchantPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MerchantPayments to fetch.
     */
    orderBy?: MerchantPaymentOrderByWithRelationInput | MerchantPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MerchantPayments.
     */
    cursor?: MerchantPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MerchantPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MerchantPayments.
     */
    skip?: number
    distinct?: MerchantPaymentScalarFieldEnum | MerchantPaymentScalarFieldEnum[]
  }

  /**
   * MerchantPayment create
   */
  export type MerchantPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantPayment
     */
    select?: MerchantPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantPayment
     */
    omit?: MerchantPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a MerchantPayment.
     */
    data: XOR<MerchantPaymentCreateInput, MerchantPaymentUncheckedCreateInput>
  }

  /**
   * MerchantPayment createMany
   */
  export type MerchantPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MerchantPayments.
     */
    data: MerchantPaymentCreateManyInput | MerchantPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MerchantPayment createManyAndReturn
   */
  export type MerchantPaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantPayment
     */
    select?: MerchantPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantPayment
     */
    omit?: MerchantPaymentOmit<ExtArgs> | null
    /**
     * The data used to create many MerchantPayments.
     */
    data: MerchantPaymentCreateManyInput | MerchantPaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantPaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MerchantPayment update
   */
  export type MerchantPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantPayment
     */
    select?: MerchantPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantPayment
     */
    omit?: MerchantPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a MerchantPayment.
     */
    data: XOR<MerchantPaymentUpdateInput, MerchantPaymentUncheckedUpdateInput>
    /**
     * Choose, which MerchantPayment to update.
     */
    where: MerchantPaymentWhereUniqueInput
  }

  /**
   * MerchantPayment updateMany
   */
  export type MerchantPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MerchantPayments.
     */
    data: XOR<MerchantPaymentUpdateManyMutationInput, MerchantPaymentUncheckedUpdateManyInput>
    /**
     * Filter which MerchantPayments to update
     */
    where?: MerchantPaymentWhereInput
    /**
     * Limit how many MerchantPayments to update.
     */
    limit?: number
  }

  /**
   * MerchantPayment updateManyAndReturn
   */
  export type MerchantPaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantPayment
     */
    select?: MerchantPaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantPayment
     */
    omit?: MerchantPaymentOmit<ExtArgs> | null
    /**
     * The data used to update MerchantPayments.
     */
    data: XOR<MerchantPaymentUpdateManyMutationInput, MerchantPaymentUncheckedUpdateManyInput>
    /**
     * Filter which MerchantPayments to update
     */
    where?: MerchantPaymentWhereInput
    /**
     * Limit how many MerchantPayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantPaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MerchantPayment upsert
   */
  export type MerchantPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantPayment
     */
    select?: MerchantPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantPayment
     */
    omit?: MerchantPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the MerchantPayment to update in case it exists.
     */
    where: MerchantPaymentWhereUniqueInput
    /**
     * In case the MerchantPayment found by the `where` argument doesn't exist, create a new MerchantPayment with this data.
     */
    create: XOR<MerchantPaymentCreateInput, MerchantPaymentUncheckedCreateInput>
    /**
     * In case the MerchantPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MerchantPaymentUpdateInput, MerchantPaymentUncheckedUpdateInput>
  }

  /**
   * MerchantPayment delete
   */
  export type MerchantPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantPayment
     */
    select?: MerchantPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantPayment
     */
    omit?: MerchantPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantPaymentInclude<ExtArgs> | null
    /**
     * Filter which MerchantPayment to delete.
     */
    where: MerchantPaymentWhereUniqueInput
  }

  /**
   * MerchantPayment deleteMany
   */
  export type MerchantPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MerchantPayments to delete
     */
    where?: MerchantPaymentWhereInput
    /**
     * Limit how many MerchantPayments to delete.
     */
    limit?: number
  }

  /**
   * MerchantPayment.user
   */
  export type MerchantPayment$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * MerchantPayment without action
   */
  export type MerchantPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantPayment
     */
    select?: MerchantPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantPayment
     */
    omit?: MerchantPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantPaymentInclude<ExtArgs> | null
  }


  /**
   * Model OnRampTransaction
   */

  export type AggregateOnRampTransaction = {
    _count: OnRampTransactionCountAggregateOutputType | null
    _avg: OnRampTransactionAvgAggregateOutputType | null
    _sum: OnRampTransactionSumAggregateOutputType | null
    _min: OnRampTransactionMinAggregateOutputType | null
    _max: OnRampTransactionMaxAggregateOutputType | null
  }

  export type OnRampTransactionAvgAggregateOutputType = {
    id: number | null
    amount: number | null
    userId: number | null
  }

  export type OnRampTransactionSumAggregateOutputType = {
    id: number | null
    amount: number | null
    userId: number | null
  }

  export type OnRampTransactionMinAggregateOutputType = {
    id: number | null
    status: $Enums.OnRampStatus | null
    token: string | null
    provider: string | null
    amount: number | null
    startTime: Date | null
    transactionId: string | null
    userId: number | null
  }

  export type OnRampTransactionMaxAggregateOutputType = {
    id: number | null
    status: $Enums.OnRampStatus | null
    token: string | null
    provider: string | null
    amount: number | null
    startTime: Date | null
    transactionId: string | null
    userId: number | null
  }

  export type OnRampTransactionCountAggregateOutputType = {
    id: number
    status: number
    token: number
    provider: number
    amount: number
    startTime: number
    transactionId: number
    userId: number
    _all: number
  }


  export type OnRampTransactionAvgAggregateInputType = {
    id?: true
    amount?: true
    userId?: true
  }

  export type OnRampTransactionSumAggregateInputType = {
    id?: true
    amount?: true
    userId?: true
  }

  export type OnRampTransactionMinAggregateInputType = {
    id?: true
    status?: true
    token?: true
    provider?: true
    amount?: true
    startTime?: true
    transactionId?: true
    userId?: true
  }

  export type OnRampTransactionMaxAggregateInputType = {
    id?: true
    status?: true
    token?: true
    provider?: true
    amount?: true
    startTime?: true
    transactionId?: true
    userId?: true
  }

  export type OnRampTransactionCountAggregateInputType = {
    id?: true
    status?: true
    token?: true
    provider?: true
    amount?: true
    startTime?: true
    transactionId?: true
    userId?: true
    _all?: true
  }

  export type OnRampTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OnRampTransaction to aggregate.
     */
    where?: OnRampTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnRampTransactions to fetch.
     */
    orderBy?: OnRampTransactionOrderByWithRelationInput | OnRampTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OnRampTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnRampTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnRampTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OnRampTransactions
    **/
    _count?: true | OnRampTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OnRampTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OnRampTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OnRampTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OnRampTransactionMaxAggregateInputType
  }

  export type GetOnRampTransactionAggregateType<T extends OnRampTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateOnRampTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOnRampTransaction[P]>
      : GetScalarType<T[P], AggregateOnRampTransaction[P]>
  }




  export type OnRampTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OnRampTransactionWhereInput
    orderBy?: OnRampTransactionOrderByWithAggregationInput | OnRampTransactionOrderByWithAggregationInput[]
    by: OnRampTransactionScalarFieldEnum[] | OnRampTransactionScalarFieldEnum
    having?: OnRampTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OnRampTransactionCountAggregateInputType | true
    _avg?: OnRampTransactionAvgAggregateInputType
    _sum?: OnRampTransactionSumAggregateInputType
    _min?: OnRampTransactionMinAggregateInputType
    _max?: OnRampTransactionMaxAggregateInputType
  }

  export type OnRampTransactionGroupByOutputType = {
    id: number
    status: $Enums.OnRampStatus
    token: string
    provider: string
    amount: number
    startTime: Date
    transactionId: string | null
    userId: number
    _count: OnRampTransactionCountAggregateOutputType | null
    _avg: OnRampTransactionAvgAggregateOutputType | null
    _sum: OnRampTransactionSumAggregateOutputType | null
    _min: OnRampTransactionMinAggregateOutputType | null
    _max: OnRampTransactionMaxAggregateOutputType | null
  }

  type GetOnRampTransactionGroupByPayload<T extends OnRampTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OnRampTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OnRampTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OnRampTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], OnRampTransactionGroupByOutputType[P]>
        }
      >
    >


  export type OnRampTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    token?: boolean
    provider?: boolean
    amount?: boolean
    startTime?: boolean
    transactionId?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["onRampTransaction"]>

  export type OnRampTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    token?: boolean
    provider?: boolean
    amount?: boolean
    startTime?: boolean
    transactionId?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["onRampTransaction"]>

  export type OnRampTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    token?: boolean
    provider?: boolean
    amount?: boolean
    startTime?: boolean
    transactionId?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["onRampTransaction"]>

  export type OnRampTransactionSelectScalar = {
    id?: boolean
    status?: boolean
    token?: boolean
    provider?: boolean
    amount?: boolean
    startTime?: boolean
    transactionId?: boolean
    userId?: boolean
  }

  export type OnRampTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "token" | "provider" | "amount" | "startTime" | "transactionId" | "userId", ExtArgs["result"]["onRampTransaction"]>
  export type OnRampTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OnRampTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OnRampTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OnRampTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OnRampTransaction"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      status: $Enums.OnRampStatus
      token: string
      provider: string
      amount: number
      startTime: Date
      transactionId: string | null
      userId: number
    }, ExtArgs["result"]["onRampTransaction"]>
    composites: {}
  }

  type OnRampTransactionGetPayload<S extends boolean | null | undefined | OnRampTransactionDefaultArgs> = $Result.GetResult<Prisma.$OnRampTransactionPayload, S>

  type OnRampTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OnRampTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OnRampTransactionCountAggregateInputType | true
    }

  export interface OnRampTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OnRampTransaction'], meta: { name: 'OnRampTransaction' } }
    /**
     * Find zero or one OnRampTransaction that matches the filter.
     * @param {OnRampTransactionFindUniqueArgs} args - Arguments to find a OnRampTransaction
     * @example
     * // Get one OnRampTransaction
     * const onRampTransaction = await prisma.onRampTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OnRampTransactionFindUniqueArgs>(args: SelectSubset<T, OnRampTransactionFindUniqueArgs<ExtArgs>>): Prisma__OnRampTransactionClient<$Result.GetResult<Prisma.$OnRampTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OnRampTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OnRampTransactionFindUniqueOrThrowArgs} args - Arguments to find a OnRampTransaction
     * @example
     * // Get one OnRampTransaction
     * const onRampTransaction = await prisma.onRampTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OnRampTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, OnRampTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OnRampTransactionClient<$Result.GetResult<Prisma.$OnRampTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OnRampTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnRampTransactionFindFirstArgs} args - Arguments to find a OnRampTransaction
     * @example
     * // Get one OnRampTransaction
     * const onRampTransaction = await prisma.onRampTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OnRampTransactionFindFirstArgs>(args?: SelectSubset<T, OnRampTransactionFindFirstArgs<ExtArgs>>): Prisma__OnRampTransactionClient<$Result.GetResult<Prisma.$OnRampTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OnRampTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnRampTransactionFindFirstOrThrowArgs} args - Arguments to find a OnRampTransaction
     * @example
     * // Get one OnRampTransaction
     * const onRampTransaction = await prisma.onRampTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OnRampTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, OnRampTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__OnRampTransactionClient<$Result.GetResult<Prisma.$OnRampTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OnRampTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnRampTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OnRampTransactions
     * const onRampTransactions = await prisma.onRampTransaction.findMany()
     * 
     * // Get first 10 OnRampTransactions
     * const onRampTransactions = await prisma.onRampTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const onRampTransactionWithIdOnly = await prisma.onRampTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OnRampTransactionFindManyArgs>(args?: SelectSubset<T, OnRampTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnRampTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OnRampTransaction.
     * @param {OnRampTransactionCreateArgs} args - Arguments to create a OnRampTransaction.
     * @example
     * // Create one OnRampTransaction
     * const OnRampTransaction = await prisma.onRampTransaction.create({
     *   data: {
     *     // ... data to create a OnRampTransaction
     *   }
     * })
     * 
     */
    create<T extends OnRampTransactionCreateArgs>(args: SelectSubset<T, OnRampTransactionCreateArgs<ExtArgs>>): Prisma__OnRampTransactionClient<$Result.GetResult<Prisma.$OnRampTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OnRampTransactions.
     * @param {OnRampTransactionCreateManyArgs} args - Arguments to create many OnRampTransactions.
     * @example
     * // Create many OnRampTransactions
     * const onRampTransaction = await prisma.onRampTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OnRampTransactionCreateManyArgs>(args?: SelectSubset<T, OnRampTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OnRampTransactions and returns the data saved in the database.
     * @param {OnRampTransactionCreateManyAndReturnArgs} args - Arguments to create many OnRampTransactions.
     * @example
     * // Create many OnRampTransactions
     * const onRampTransaction = await prisma.onRampTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OnRampTransactions and only return the `id`
     * const onRampTransactionWithIdOnly = await prisma.onRampTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OnRampTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, OnRampTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnRampTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OnRampTransaction.
     * @param {OnRampTransactionDeleteArgs} args - Arguments to delete one OnRampTransaction.
     * @example
     * // Delete one OnRampTransaction
     * const OnRampTransaction = await prisma.onRampTransaction.delete({
     *   where: {
     *     // ... filter to delete one OnRampTransaction
     *   }
     * })
     * 
     */
    delete<T extends OnRampTransactionDeleteArgs>(args: SelectSubset<T, OnRampTransactionDeleteArgs<ExtArgs>>): Prisma__OnRampTransactionClient<$Result.GetResult<Prisma.$OnRampTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OnRampTransaction.
     * @param {OnRampTransactionUpdateArgs} args - Arguments to update one OnRampTransaction.
     * @example
     * // Update one OnRampTransaction
     * const onRampTransaction = await prisma.onRampTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OnRampTransactionUpdateArgs>(args: SelectSubset<T, OnRampTransactionUpdateArgs<ExtArgs>>): Prisma__OnRampTransactionClient<$Result.GetResult<Prisma.$OnRampTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OnRampTransactions.
     * @param {OnRampTransactionDeleteManyArgs} args - Arguments to filter OnRampTransactions to delete.
     * @example
     * // Delete a few OnRampTransactions
     * const { count } = await prisma.onRampTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OnRampTransactionDeleteManyArgs>(args?: SelectSubset<T, OnRampTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OnRampTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnRampTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OnRampTransactions
     * const onRampTransaction = await prisma.onRampTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OnRampTransactionUpdateManyArgs>(args: SelectSubset<T, OnRampTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OnRampTransactions and returns the data updated in the database.
     * @param {OnRampTransactionUpdateManyAndReturnArgs} args - Arguments to update many OnRampTransactions.
     * @example
     * // Update many OnRampTransactions
     * const onRampTransaction = await prisma.onRampTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OnRampTransactions and only return the `id`
     * const onRampTransactionWithIdOnly = await prisma.onRampTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OnRampTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, OnRampTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnRampTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OnRampTransaction.
     * @param {OnRampTransactionUpsertArgs} args - Arguments to update or create a OnRampTransaction.
     * @example
     * // Update or create a OnRampTransaction
     * const onRampTransaction = await prisma.onRampTransaction.upsert({
     *   create: {
     *     // ... data to create a OnRampTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OnRampTransaction we want to update
     *   }
     * })
     */
    upsert<T extends OnRampTransactionUpsertArgs>(args: SelectSubset<T, OnRampTransactionUpsertArgs<ExtArgs>>): Prisma__OnRampTransactionClient<$Result.GetResult<Prisma.$OnRampTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OnRampTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnRampTransactionCountArgs} args - Arguments to filter OnRampTransactions to count.
     * @example
     * // Count the number of OnRampTransactions
     * const count = await prisma.onRampTransaction.count({
     *   where: {
     *     // ... the filter for the OnRampTransactions we want to count
     *   }
     * })
    **/
    count<T extends OnRampTransactionCountArgs>(
      args?: Subset<T, OnRampTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OnRampTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OnRampTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnRampTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OnRampTransactionAggregateArgs>(args: Subset<T, OnRampTransactionAggregateArgs>): Prisma.PrismaPromise<GetOnRampTransactionAggregateType<T>>

    /**
     * Group by OnRampTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnRampTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OnRampTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OnRampTransactionGroupByArgs['orderBy'] }
        : { orderBy?: OnRampTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OnRampTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOnRampTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OnRampTransaction model
   */
  readonly fields: OnRampTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OnRampTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OnRampTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OnRampTransaction model
   */
  interface OnRampTransactionFieldRefs {
    readonly id: FieldRef<"OnRampTransaction", 'Int'>
    readonly status: FieldRef<"OnRampTransaction", 'OnRampStatus'>
    readonly token: FieldRef<"OnRampTransaction", 'String'>
    readonly provider: FieldRef<"OnRampTransaction", 'String'>
    readonly amount: FieldRef<"OnRampTransaction", 'Int'>
    readonly startTime: FieldRef<"OnRampTransaction", 'DateTime'>
    readonly transactionId: FieldRef<"OnRampTransaction", 'String'>
    readonly userId: FieldRef<"OnRampTransaction", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * OnRampTransaction findUnique
   */
  export type OnRampTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnRampTransaction
     */
    select?: OnRampTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnRampTransaction
     */
    omit?: OnRampTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnRampTransactionInclude<ExtArgs> | null
    /**
     * Filter, which OnRampTransaction to fetch.
     */
    where: OnRampTransactionWhereUniqueInput
  }

  /**
   * OnRampTransaction findUniqueOrThrow
   */
  export type OnRampTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnRampTransaction
     */
    select?: OnRampTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnRampTransaction
     */
    omit?: OnRampTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnRampTransactionInclude<ExtArgs> | null
    /**
     * Filter, which OnRampTransaction to fetch.
     */
    where: OnRampTransactionWhereUniqueInput
  }

  /**
   * OnRampTransaction findFirst
   */
  export type OnRampTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnRampTransaction
     */
    select?: OnRampTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnRampTransaction
     */
    omit?: OnRampTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnRampTransactionInclude<ExtArgs> | null
    /**
     * Filter, which OnRampTransaction to fetch.
     */
    where?: OnRampTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnRampTransactions to fetch.
     */
    orderBy?: OnRampTransactionOrderByWithRelationInput | OnRampTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OnRampTransactions.
     */
    cursor?: OnRampTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnRampTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnRampTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OnRampTransactions.
     */
    distinct?: OnRampTransactionScalarFieldEnum | OnRampTransactionScalarFieldEnum[]
  }

  /**
   * OnRampTransaction findFirstOrThrow
   */
  export type OnRampTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnRampTransaction
     */
    select?: OnRampTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnRampTransaction
     */
    omit?: OnRampTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnRampTransactionInclude<ExtArgs> | null
    /**
     * Filter, which OnRampTransaction to fetch.
     */
    where?: OnRampTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnRampTransactions to fetch.
     */
    orderBy?: OnRampTransactionOrderByWithRelationInput | OnRampTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OnRampTransactions.
     */
    cursor?: OnRampTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnRampTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnRampTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OnRampTransactions.
     */
    distinct?: OnRampTransactionScalarFieldEnum | OnRampTransactionScalarFieldEnum[]
  }

  /**
   * OnRampTransaction findMany
   */
  export type OnRampTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnRampTransaction
     */
    select?: OnRampTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnRampTransaction
     */
    omit?: OnRampTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnRampTransactionInclude<ExtArgs> | null
    /**
     * Filter, which OnRampTransactions to fetch.
     */
    where?: OnRampTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnRampTransactions to fetch.
     */
    orderBy?: OnRampTransactionOrderByWithRelationInput | OnRampTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OnRampTransactions.
     */
    cursor?: OnRampTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnRampTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnRampTransactions.
     */
    skip?: number
    distinct?: OnRampTransactionScalarFieldEnum | OnRampTransactionScalarFieldEnum[]
  }

  /**
   * OnRampTransaction create
   */
  export type OnRampTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnRampTransaction
     */
    select?: OnRampTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnRampTransaction
     */
    omit?: OnRampTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnRampTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a OnRampTransaction.
     */
    data: XOR<OnRampTransactionCreateInput, OnRampTransactionUncheckedCreateInput>
  }

  /**
   * OnRampTransaction createMany
   */
  export type OnRampTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OnRampTransactions.
     */
    data: OnRampTransactionCreateManyInput | OnRampTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OnRampTransaction createManyAndReturn
   */
  export type OnRampTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnRampTransaction
     */
    select?: OnRampTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OnRampTransaction
     */
    omit?: OnRampTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many OnRampTransactions.
     */
    data: OnRampTransactionCreateManyInput | OnRampTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnRampTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OnRampTransaction update
   */
  export type OnRampTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnRampTransaction
     */
    select?: OnRampTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnRampTransaction
     */
    omit?: OnRampTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnRampTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a OnRampTransaction.
     */
    data: XOR<OnRampTransactionUpdateInput, OnRampTransactionUncheckedUpdateInput>
    /**
     * Choose, which OnRampTransaction to update.
     */
    where: OnRampTransactionWhereUniqueInput
  }

  /**
   * OnRampTransaction updateMany
   */
  export type OnRampTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OnRampTransactions.
     */
    data: XOR<OnRampTransactionUpdateManyMutationInput, OnRampTransactionUncheckedUpdateManyInput>
    /**
     * Filter which OnRampTransactions to update
     */
    where?: OnRampTransactionWhereInput
    /**
     * Limit how many OnRampTransactions to update.
     */
    limit?: number
  }

  /**
   * OnRampTransaction updateManyAndReturn
   */
  export type OnRampTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnRampTransaction
     */
    select?: OnRampTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OnRampTransaction
     */
    omit?: OnRampTransactionOmit<ExtArgs> | null
    /**
     * The data used to update OnRampTransactions.
     */
    data: XOR<OnRampTransactionUpdateManyMutationInput, OnRampTransactionUncheckedUpdateManyInput>
    /**
     * Filter which OnRampTransactions to update
     */
    where?: OnRampTransactionWhereInput
    /**
     * Limit how many OnRampTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnRampTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OnRampTransaction upsert
   */
  export type OnRampTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnRampTransaction
     */
    select?: OnRampTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnRampTransaction
     */
    omit?: OnRampTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnRampTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the OnRampTransaction to update in case it exists.
     */
    where: OnRampTransactionWhereUniqueInput
    /**
     * In case the OnRampTransaction found by the `where` argument doesn't exist, create a new OnRampTransaction with this data.
     */
    create: XOR<OnRampTransactionCreateInput, OnRampTransactionUncheckedCreateInput>
    /**
     * In case the OnRampTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OnRampTransactionUpdateInput, OnRampTransactionUncheckedUpdateInput>
  }

  /**
   * OnRampTransaction delete
   */
  export type OnRampTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnRampTransaction
     */
    select?: OnRampTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnRampTransaction
     */
    omit?: OnRampTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnRampTransactionInclude<ExtArgs> | null
    /**
     * Filter which OnRampTransaction to delete.
     */
    where: OnRampTransactionWhereUniqueInput
  }

  /**
   * OnRampTransaction deleteMany
   */
  export type OnRampTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OnRampTransactions to delete
     */
    where?: OnRampTransactionWhereInput
    /**
     * Limit how many OnRampTransactions to delete.
     */
    limit?: number
  }

  /**
   * OnRampTransaction without action
   */
  export type OnRampTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnRampTransaction
     */
    select?: OnRampTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnRampTransaction
     */
    omit?: OnRampTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnRampTransactionInclude<ExtArgs> | null
  }


  /**
   * Model P2PRequest
   */

  export type AggregateP2PRequest = {
    _count: P2PRequestCountAggregateOutputType | null
    _avg: P2PRequestAvgAggregateOutputType | null
    _sum: P2PRequestSumAggregateOutputType | null
    _min: P2PRequestMinAggregateOutputType | null
    _max: P2PRequestMaxAggregateOutputType | null
  }

  export type P2PRequestAvgAggregateOutputType = {
    id: number | null
    senderId: number | null
    receiverId: number | null
    amount: number | null
    billSplitMemberId: number | null
  }

  export type P2PRequestSumAggregateOutputType = {
    id: number | null
    senderId: number | null
    receiverId: number | null
    amount: number | null
    billSplitMemberId: number | null
  }

  export type P2PRequestMinAggregateOutputType = {
    id: number | null
    senderId: number | null
    receiverId: number | null
    receiverNumber: string | null
    amount: number | null
    message: string | null
    status: $Enums.P2PRequestStatus | null
    createdAt: Date | null
    settledAt: Date | null
    billSplitMemberId: number | null
  }

  export type P2PRequestMaxAggregateOutputType = {
    id: number | null
    senderId: number | null
    receiverId: number | null
    receiverNumber: string | null
    amount: number | null
    message: string | null
    status: $Enums.P2PRequestStatus | null
    createdAt: Date | null
    settledAt: Date | null
    billSplitMemberId: number | null
  }

  export type P2PRequestCountAggregateOutputType = {
    id: number
    senderId: number
    receiverId: number
    receiverNumber: number
    amount: number
    message: number
    status: number
    createdAt: number
    settledAt: number
    billSplitMemberId: number
    _all: number
  }


  export type P2PRequestAvgAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    amount?: true
    billSplitMemberId?: true
  }

  export type P2PRequestSumAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    amount?: true
    billSplitMemberId?: true
  }

  export type P2PRequestMinAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    receiverNumber?: true
    amount?: true
    message?: true
    status?: true
    createdAt?: true
    settledAt?: true
    billSplitMemberId?: true
  }

  export type P2PRequestMaxAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    receiverNumber?: true
    amount?: true
    message?: true
    status?: true
    createdAt?: true
    settledAt?: true
    billSplitMemberId?: true
  }

  export type P2PRequestCountAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    receiverNumber?: true
    amount?: true
    message?: true
    status?: true
    createdAt?: true
    settledAt?: true
    billSplitMemberId?: true
    _all?: true
  }

  export type P2PRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which P2PRequest to aggregate.
     */
    where?: P2PRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of P2PRequests to fetch.
     */
    orderBy?: P2PRequestOrderByWithRelationInput | P2PRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: P2PRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` P2PRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` P2PRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned P2PRequests
    **/
    _count?: true | P2PRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: P2PRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: P2PRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: P2PRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: P2PRequestMaxAggregateInputType
  }

  export type GetP2PRequestAggregateType<T extends P2PRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateP2PRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateP2PRequest[P]>
      : GetScalarType<T[P], AggregateP2PRequest[P]>
  }




  export type P2PRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: P2PRequestWhereInput
    orderBy?: P2PRequestOrderByWithAggregationInput | P2PRequestOrderByWithAggregationInput[]
    by: P2PRequestScalarFieldEnum[] | P2PRequestScalarFieldEnum
    having?: P2PRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: P2PRequestCountAggregateInputType | true
    _avg?: P2PRequestAvgAggregateInputType
    _sum?: P2PRequestSumAggregateInputType
    _min?: P2PRequestMinAggregateInputType
    _max?: P2PRequestMaxAggregateInputType
  }

  export type P2PRequestGroupByOutputType = {
    id: number
    senderId: number
    receiverId: number | null
    receiverNumber: string
    amount: number
    message: string | null
    status: $Enums.P2PRequestStatus
    createdAt: Date
    settledAt: Date | null
    billSplitMemberId: number | null
    _count: P2PRequestCountAggregateOutputType | null
    _avg: P2PRequestAvgAggregateOutputType | null
    _sum: P2PRequestSumAggregateOutputType | null
    _min: P2PRequestMinAggregateOutputType | null
    _max: P2PRequestMaxAggregateOutputType | null
  }

  type GetP2PRequestGroupByPayload<T extends P2PRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<P2PRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof P2PRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], P2PRequestGroupByOutputType[P]>
            : GetScalarType<T[P], P2PRequestGroupByOutputType[P]>
        }
      >
    >


  export type P2PRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    receiverNumber?: boolean
    amount?: boolean
    message?: boolean
    status?: boolean
    createdAt?: boolean
    settledAt?: boolean
    billSplitMemberId?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | P2PRequest$receiverArgs<ExtArgs>
    billSplitMember?: boolean | P2PRequest$billSplitMemberArgs<ExtArgs>
  }, ExtArgs["result"]["p2PRequest"]>

  export type P2PRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    receiverNumber?: boolean
    amount?: boolean
    message?: boolean
    status?: boolean
    createdAt?: boolean
    settledAt?: boolean
    billSplitMemberId?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | P2PRequest$receiverArgs<ExtArgs>
    billSplitMember?: boolean | P2PRequest$billSplitMemberArgs<ExtArgs>
  }, ExtArgs["result"]["p2PRequest"]>

  export type P2PRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    receiverNumber?: boolean
    amount?: boolean
    message?: boolean
    status?: boolean
    createdAt?: boolean
    settledAt?: boolean
    billSplitMemberId?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | P2PRequest$receiverArgs<ExtArgs>
    billSplitMember?: boolean | P2PRequest$billSplitMemberArgs<ExtArgs>
  }, ExtArgs["result"]["p2PRequest"]>

  export type P2PRequestSelectScalar = {
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    receiverNumber?: boolean
    amount?: boolean
    message?: boolean
    status?: boolean
    createdAt?: boolean
    settledAt?: boolean
    billSplitMemberId?: boolean
  }

  export type P2PRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "senderId" | "receiverId" | "receiverNumber" | "amount" | "message" | "status" | "createdAt" | "settledAt" | "billSplitMemberId", ExtArgs["result"]["p2PRequest"]>
  export type P2PRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | P2PRequest$receiverArgs<ExtArgs>
    billSplitMember?: boolean | P2PRequest$billSplitMemberArgs<ExtArgs>
  }
  export type P2PRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | P2PRequest$receiverArgs<ExtArgs>
    billSplitMember?: boolean | P2PRequest$billSplitMemberArgs<ExtArgs>
  }
  export type P2PRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | P2PRequest$receiverArgs<ExtArgs>
    billSplitMember?: boolean | P2PRequest$billSplitMemberArgs<ExtArgs>
  }

  export type $P2PRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "P2PRequest"
    objects: {
      sender: Prisma.$UserPayload<ExtArgs>
      receiver: Prisma.$UserPayload<ExtArgs> | null
      billSplitMember: Prisma.$BillSplitMemberPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      senderId: number
      receiverId: number | null
      receiverNumber: string
      amount: number
      message: string | null
      status: $Enums.P2PRequestStatus
      createdAt: Date
      settledAt: Date | null
      billSplitMemberId: number | null
    }, ExtArgs["result"]["p2PRequest"]>
    composites: {}
  }

  type P2PRequestGetPayload<S extends boolean | null | undefined | P2PRequestDefaultArgs> = $Result.GetResult<Prisma.$P2PRequestPayload, S>

  type P2PRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<P2PRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: P2PRequestCountAggregateInputType | true
    }

  export interface P2PRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['P2PRequest'], meta: { name: 'P2PRequest' } }
    /**
     * Find zero or one P2PRequest that matches the filter.
     * @param {P2PRequestFindUniqueArgs} args - Arguments to find a P2PRequest
     * @example
     * // Get one P2PRequest
     * const p2PRequest = await prisma.p2PRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends P2PRequestFindUniqueArgs>(args: SelectSubset<T, P2PRequestFindUniqueArgs<ExtArgs>>): Prisma__P2PRequestClient<$Result.GetResult<Prisma.$P2PRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one P2PRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {P2PRequestFindUniqueOrThrowArgs} args - Arguments to find a P2PRequest
     * @example
     * // Get one P2PRequest
     * const p2PRequest = await prisma.p2PRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends P2PRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, P2PRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__P2PRequestClient<$Result.GetResult<Prisma.$P2PRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first P2PRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {P2PRequestFindFirstArgs} args - Arguments to find a P2PRequest
     * @example
     * // Get one P2PRequest
     * const p2PRequest = await prisma.p2PRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends P2PRequestFindFirstArgs>(args?: SelectSubset<T, P2PRequestFindFirstArgs<ExtArgs>>): Prisma__P2PRequestClient<$Result.GetResult<Prisma.$P2PRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first P2PRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {P2PRequestFindFirstOrThrowArgs} args - Arguments to find a P2PRequest
     * @example
     * // Get one P2PRequest
     * const p2PRequest = await prisma.p2PRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends P2PRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, P2PRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__P2PRequestClient<$Result.GetResult<Prisma.$P2PRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more P2PRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {P2PRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all P2PRequests
     * const p2PRequests = await prisma.p2PRequest.findMany()
     * 
     * // Get first 10 P2PRequests
     * const p2PRequests = await prisma.p2PRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const p2PRequestWithIdOnly = await prisma.p2PRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends P2PRequestFindManyArgs>(args?: SelectSubset<T, P2PRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$P2PRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a P2PRequest.
     * @param {P2PRequestCreateArgs} args - Arguments to create a P2PRequest.
     * @example
     * // Create one P2PRequest
     * const P2PRequest = await prisma.p2PRequest.create({
     *   data: {
     *     // ... data to create a P2PRequest
     *   }
     * })
     * 
     */
    create<T extends P2PRequestCreateArgs>(args: SelectSubset<T, P2PRequestCreateArgs<ExtArgs>>): Prisma__P2PRequestClient<$Result.GetResult<Prisma.$P2PRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many P2PRequests.
     * @param {P2PRequestCreateManyArgs} args - Arguments to create many P2PRequests.
     * @example
     * // Create many P2PRequests
     * const p2PRequest = await prisma.p2PRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends P2PRequestCreateManyArgs>(args?: SelectSubset<T, P2PRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many P2PRequests and returns the data saved in the database.
     * @param {P2PRequestCreateManyAndReturnArgs} args - Arguments to create many P2PRequests.
     * @example
     * // Create many P2PRequests
     * const p2PRequest = await prisma.p2PRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many P2PRequests and only return the `id`
     * const p2PRequestWithIdOnly = await prisma.p2PRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends P2PRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, P2PRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$P2PRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a P2PRequest.
     * @param {P2PRequestDeleteArgs} args - Arguments to delete one P2PRequest.
     * @example
     * // Delete one P2PRequest
     * const P2PRequest = await prisma.p2PRequest.delete({
     *   where: {
     *     // ... filter to delete one P2PRequest
     *   }
     * })
     * 
     */
    delete<T extends P2PRequestDeleteArgs>(args: SelectSubset<T, P2PRequestDeleteArgs<ExtArgs>>): Prisma__P2PRequestClient<$Result.GetResult<Prisma.$P2PRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one P2PRequest.
     * @param {P2PRequestUpdateArgs} args - Arguments to update one P2PRequest.
     * @example
     * // Update one P2PRequest
     * const p2PRequest = await prisma.p2PRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends P2PRequestUpdateArgs>(args: SelectSubset<T, P2PRequestUpdateArgs<ExtArgs>>): Prisma__P2PRequestClient<$Result.GetResult<Prisma.$P2PRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more P2PRequests.
     * @param {P2PRequestDeleteManyArgs} args - Arguments to filter P2PRequests to delete.
     * @example
     * // Delete a few P2PRequests
     * const { count } = await prisma.p2PRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends P2PRequestDeleteManyArgs>(args?: SelectSubset<T, P2PRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more P2PRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {P2PRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many P2PRequests
     * const p2PRequest = await prisma.p2PRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends P2PRequestUpdateManyArgs>(args: SelectSubset<T, P2PRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more P2PRequests and returns the data updated in the database.
     * @param {P2PRequestUpdateManyAndReturnArgs} args - Arguments to update many P2PRequests.
     * @example
     * // Update many P2PRequests
     * const p2PRequest = await prisma.p2PRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more P2PRequests and only return the `id`
     * const p2PRequestWithIdOnly = await prisma.p2PRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends P2PRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, P2PRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$P2PRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one P2PRequest.
     * @param {P2PRequestUpsertArgs} args - Arguments to update or create a P2PRequest.
     * @example
     * // Update or create a P2PRequest
     * const p2PRequest = await prisma.p2PRequest.upsert({
     *   create: {
     *     // ... data to create a P2PRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the P2PRequest we want to update
     *   }
     * })
     */
    upsert<T extends P2PRequestUpsertArgs>(args: SelectSubset<T, P2PRequestUpsertArgs<ExtArgs>>): Prisma__P2PRequestClient<$Result.GetResult<Prisma.$P2PRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of P2PRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {P2PRequestCountArgs} args - Arguments to filter P2PRequests to count.
     * @example
     * // Count the number of P2PRequests
     * const count = await prisma.p2PRequest.count({
     *   where: {
     *     // ... the filter for the P2PRequests we want to count
     *   }
     * })
    **/
    count<T extends P2PRequestCountArgs>(
      args?: Subset<T, P2PRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], P2PRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a P2PRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {P2PRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends P2PRequestAggregateArgs>(args: Subset<T, P2PRequestAggregateArgs>): Prisma.PrismaPromise<GetP2PRequestAggregateType<T>>

    /**
     * Group by P2PRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {P2PRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends P2PRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: P2PRequestGroupByArgs['orderBy'] }
        : { orderBy?: P2PRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, P2PRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetP2PRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the P2PRequest model
   */
  readonly fields: P2PRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for P2PRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__P2PRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    receiver<T extends P2PRequest$receiverArgs<ExtArgs> = {}>(args?: Subset<T, P2PRequest$receiverArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    billSplitMember<T extends P2PRequest$billSplitMemberArgs<ExtArgs> = {}>(args?: Subset<T, P2PRequest$billSplitMemberArgs<ExtArgs>>): Prisma__BillSplitMemberClient<$Result.GetResult<Prisma.$BillSplitMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the P2PRequest model
   */
  interface P2PRequestFieldRefs {
    readonly id: FieldRef<"P2PRequest", 'Int'>
    readonly senderId: FieldRef<"P2PRequest", 'Int'>
    readonly receiverId: FieldRef<"P2PRequest", 'Int'>
    readonly receiverNumber: FieldRef<"P2PRequest", 'String'>
    readonly amount: FieldRef<"P2PRequest", 'Int'>
    readonly message: FieldRef<"P2PRequest", 'String'>
    readonly status: FieldRef<"P2PRequest", 'P2PRequestStatus'>
    readonly createdAt: FieldRef<"P2PRequest", 'DateTime'>
    readonly settledAt: FieldRef<"P2PRequest", 'DateTime'>
    readonly billSplitMemberId: FieldRef<"P2PRequest", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * P2PRequest findUnique
   */
  export type P2PRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the P2PRequest
     */
    select?: P2PRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the P2PRequest
     */
    omit?: P2PRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: P2PRequestInclude<ExtArgs> | null
    /**
     * Filter, which P2PRequest to fetch.
     */
    where: P2PRequestWhereUniqueInput
  }

  /**
   * P2PRequest findUniqueOrThrow
   */
  export type P2PRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the P2PRequest
     */
    select?: P2PRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the P2PRequest
     */
    omit?: P2PRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: P2PRequestInclude<ExtArgs> | null
    /**
     * Filter, which P2PRequest to fetch.
     */
    where: P2PRequestWhereUniqueInput
  }

  /**
   * P2PRequest findFirst
   */
  export type P2PRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the P2PRequest
     */
    select?: P2PRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the P2PRequest
     */
    omit?: P2PRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: P2PRequestInclude<ExtArgs> | null
    /**
     * Filter, which P2PRequest to fetch.
     */
    where?: P2PRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of P2PRequests to fetch.
     */
    orderBy?: P2PRequestOrderByWithRelationInput | P2PRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for P2PRequests.
     */
    cursor?: P2PRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` P2PRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` P2PRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of P2PRequests.
     */
    distinct?: P2PRequestScalarFieldEnum | P2PRequestScalarFieldEnum[]
  }

  /**
   * P2PRequest findFirstOrThrow
   */
  export type P2PRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the P2PRequest
     */
    select?: P2PRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the P2PRequest
     */
    omit?: P2PRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: P2PRequestInclude<ExtArgs> | null
    /**
     * Filter, which P2PRequest to fetch.
     */
    where?: P2PRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of P2PRequests to fetch.
     */
    orderBy?: P2PRequestOrderByWithRelationInput | P2PRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for P2PRequests.
     */
    cursor?: P2PRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` P2PRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` P2PRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of P2PRequests.
     */
    distinct?: P2PRequestScalarFieldEnum | P2PRequestScalarFieldEnum[]
  }

  /**
   * P2PRequest findMany
   */
  export type P2PRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the P2PRequest
     */
    select?: P2PRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the P2PRequest
     */
    omit?: P2PRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: P2PRequestInclude<ExtArgs> | null
    /**
     * Filter, which P2PRequests to fetch.
     */
    where?: P2PRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of P2PRequests to fetch.
     */
    orderBy?: P2PRequestOrderByWithRelationInput | P2PRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing P2PRequests.
     */
    cursor?: P2PRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` P2PRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` P2PRequests.
     */
    skip?: number
    distinct?: P2PRequestScalarFieldEnum | P2PRequestScalarFieldEnum[]
  }

  /**
   * P2PRequest create
   */
  export type P2PRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the P2PRequest
     */
    select?: P2PRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the P2PRequest
     */
    omit?: P2PRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: P2PRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a P2PRequest.
     */
    data: XOR<P2PRequestCreateInput, P2PRequestUncheckedCreateInput>
  }

  /**
   * P2PRequest createMany
   */
  export type P2PRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many P2PRequests.
     */
    data: P2PRequestCreateManyInput | P2PRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * P2PRequest createManyAndReturn
   */
  export type P2PRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the P2PRequest
     */
    select?: P2PRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the P2PRequest
     */
    omit?: P2PRequestOmit<ExtArgs> | null
    /**
     * The data used to create many P2PRequests.
     */
    data: P2PRequestCreateManyInput | P2PRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: P2PRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * P2PRequest update
   */
  export type P2PRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the P2PRequest
     */
    select?: P2PRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the P2PRequest
     */
    omit?: P2PRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: P2PRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a P2PRequest.
     */
    data: XOR<P2PRequestUpdateInput, P2PRequestUncheckedUpdateInput>
    /**
     * Choose, which P2PRequest to update.
     */
    where: P2PRequestWhereUniqueInput
  }

  /**
   * P2PRequest updateMany
   */
  export type P2PRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update P2PRequests.
     */
    data: XOR<P2PRequestUpdateManyMutationInput, P2PRequestUncheckedUpdateManyInput>
    /**
     * Filter which P2PRequests to update
     */
    where?: P2PRequestWhereInput
    /**
     * Limit how many P2PRequests to update.
     */
    limit?: number
  }

  /**
   * P2PRequest updateManyAndReturn
   */
  export type P2PRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the P2PRequest
     */
    select?: P2PRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the P2PRequest
     */
    omit?: P2PRequestOmit<ExtArgs> | null
    /**
     * The data used to update P2PRequests.
     */
    data: XOR<P2PRequestUpdateManyMutationInput, P2PRequestUncheckedUpdateManyInput>
    /**
     * Filter which P2PRequests to update
     */
    where?: P2PRequestWhereInput
    /**
     * Limit how many P2PRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: P2PRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * P2PRequest upsert
   */
  export type P2PRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the P2PRequest
     */
    select?: P2PRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the P2PRequest
     */
    omit?: P2PRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: P2PRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the P2PRequest to update in case it exists.
     */
    where: P2PRequestWhereUniqueInput
    /**
     * In case the P2PRequest found by the `where` argument doesn't exist, create a new P2PRequest with this data.
     */
    create: XOR<P2PRequestCreateInput, P2PRequestUncheckedCreateInput>
    /**
     * In case the P2PRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<P2PRequestUpdateInput, P2PRequestUncheckedUpdateInput>
  }

  /**
   * P2PRequest delete
   */
  export type P2PRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the P2PRequest
     */
    select?: P2PRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the P2PRequest
     */
    omit?: P2PRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: P2PRequestInclude<ExtArgs> | null
    /**
     * Filter which P2PRequest to delete.
     */
    where: P2PRequestWhereUniqueInput
  }

  /**
   * P2PRequest deleteMany
   */
  export type P2PRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which P2PRequests to delete
     */
    where?: P2PRequestWhereInput
    /**
     * Limit how many P2PRequests to delete.
     */
    limit?: number
  }

  /**
   * P2PRequest.receiver
   */
  export type P2PRequest$receiverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * P2PRequest.billSplitMember
   */
  export type P2PRequest$billSplitMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitMember
     */
    select?: BillSplitMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitMember
     */
    omit?: BillSplitMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitMemberInclude<ExtArgs> | null
    where?: BillSplitMemberWhereInput
  }

  /**
   * P2PRequest without action
   */
  export type P2PRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the P2PRequest
     */
    select?: P2PRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the P2PRequest
     */
    omit?: P2PRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: P2PRequestInclude<ExtArgs> | null
  }


  /**
   * Model BillSchedule
   */

  export type AggregateBillSchedule = {
    _count: BillScheduleCountAggregateOutputType | null
    _avg: BillScheduleAvgAggregateOutputType | null
    _sum: BillScheduleSumAggregateOutputType | null
    _min: BillScheduleMinAggregateOutputType | null
    _max: BillScheduleMaxAggregateOutputType | null
  }

  export type BillScheduleAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    merchantId: number | null
    amount: number | null
  }

  export type BillScheduleSumAggregateOutputType = {
    id: number | null
    userId: number | null
    merchantId: number | null
    amount: number | null
  }

  export type BillScheduleMinAggregateOutputType = {
    id: number | null
    userId: number | null
    merchantId: number | null
    billType: string | null
    provider: string | null
    accountNo: string | null
    amount: number | null
    dueDate: Date | null
    nextPayment: Date | null
    createdAt: Date | null
    paymentMethod: string | null
    status: string | null
    token: string | null
  }

  export type BillScheduleMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    merchantId: number | null
    billType: string | null
    provider: string | null
    accountNo: string | null
    amount: number | null
    dueDate: Date | null
    nextPayment: Date | null
    createdAt: Date | null
    paymentMethod: string | null
    status: string | null
    token: string | null
  }

  export type BillScheduleCountAggregateOutputType = {
    id: number
    userId: number
    merchantId: number
    billType: number
    provider: number
    accountNo: number
    amount: number
    dueDate: number
    nextPayment: number
    createdAt: number
    paymentMethod: number
    status: number
    token: number
    _all: number
  }


  export type BillScheduleAvgAggregateInputType = {
    id?: true
    userId?: true
    merchantId?: true
    amount?: true
  }

  export type BillScheduleSumAggregateInputType = {
    id?: true
    userId?: true
    merchantId?: true
    amount?: true
  }

  export type BillScheduleMinAggregateInputType = {
    id?: true
    userId?: true
    merchantId?: true
    billType?: true
    provider?: true
    accountNo?: true
    amount?: true
    dueDate?: true
    nextPayment?: true
    createdAt?: true
    paymentMethod?: true
    status?: true
    token?: true
  }

  export type BillScheduleMaxAggregateInputType = {
    id?: true
    userId?: true
    merchantId?: true
    billType?: true
    provider?: true
    accountNo?: true
    amount?: true
    dueDate?: true
    nextPayment?: true
    createdAt?: true
    paymentMethod?: true
    status?: true
    token?: true
  }

  export type BillScheduleCountAggregateInputType = {
    id?: true
    userId?: true
    merchantId?: true
    billType?: true
    provider?: true
    accountNo?: true
    amount?: true
    dueDate?: true
    nextPayment?: true
    createdAt?: true
    paymentMethod?: true
    status?: true
    token?: true
    _all?: true
  }

  export type BillScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillSchedule to aggregate.
     */
    where?: BillScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillSchedules to fetch.
     */
    orderBy?: BillScheduleOrderByWithRelationInput | BillScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BillSchedules
    **/
    _count?: true | BillScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillScheduleMaxAggregateInputType
  }

  export type GetBillScheduleAggregateType<T extends BillScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateBillSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBillSchedule[P]>
      : GetScalarType<T[P], AggregateBillSchedule[P]>
  }




  export type BillScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillScheduleWhereInput
    orderBy?: BillScheduleOrderByWithAggregationInput | BillScheduleOrderByWithAggregationInput[]
    by: BillScheduleScalarFieldEnum[] | BillScheduleScalarFieldEnum
    having?: BillScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillScheduleCountAggregateInputType | true
    _avg?: BillScheduleAvgAggregateInputType
    _sum?: BillScheduleSumAggregateInputType
    _min?: BillScheduleMinAggregateInputType
    _max?: BillScheduleMaxAggregateInputType
  }

  export type BillScheduleGroupByOutputType = {
    id: number
    userId: number
    merchantId: number | null
    billType: string
    provider: string
    accountNo: string
    amount: number
    dueDate: Date
    nextPayment: Date | null
    createdAt: Date
    paymentMethod: string
    status: string
    token: string | null
    _count: BillScheduleCountAggregateOutputType | null
    _avg: BillScheduleAvgAggregateOutputType | null
    _sum: BillScheduleSumAggregateOutputType | null
    _min: BillScheduleMinAggregateOutputType | null
    _max: BillScheduleMaxAggregateOutputType | null
  }

  type GetBillScheduleGroupByPayload<T extends BillScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], BillScheduleGroupByOutputType[P]>
        }
      >
    >


  export type BillScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    merchantId?: boolean
    billType?: boolean
    provider?: boolean
    accountNo?: boolean
    amount?: boolean
    dueDate?: boolean
    nextPayment?: boolean
    createdAt?: boolean
    paymentMethod?: boolean
    status?: boolean
    token?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    merchant?: boolean | BillSchedule$merchantArgs<ExtArgs>
  }, ExtArgs["result"]["billSchedule"]>

  export type BillScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    merchantId?: boolean
    billType?: boolean
    provider?: boolean
    accountNo?: boolean
    amount?: boolean
    dueDate?: boolean
    nextPayment?: boolean
    createdAt?: boolean
    paymentMethod?: boolean
    status?: boolean
    token?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    merchant?: boolean | BillSchedule$merchantArgs<ExtArgs>
  }, ExtArgs["result"]["billSchedule"]>

  export type BillScheduleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    merchantId?: boolean
    billType?: boolean
    provider?: boolean
    accountNo?: boolean
    amount?: boolean
    dueDate?: boolean
    nextPayment?: boolean
    createdAt?: boolean
    paymentMethod?: boolean
    status?: boolean
    token?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    merchant?: boolean | BillSchedule$merchantArgs<ExtArgs>
  }, ExtArgs["result"]["billSchedule"]>

  export type BillScheduleSelectScalar = {
    id?: boolean
    userId?: boolean
    merchantId?: boolean
    billType?: boolean
    provider?: boolean
    accountNo?: boolean
    amount?: boolean
    dueDate?: boolean
    nextPayment?: boolean
    createdAt?: boolean
    paymentMethod?: boolean
    status?: boolean
    token?: boolean
  }

  export type BillScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "merchantId" | "billType" | "provider" | "accountNo" | "amount" | "dueDate" | "nextPayment" | "createdAt" | "paymentMethod" | "status" | "token", ExtArgs["result"]["billSchedule"]>
  export type BillScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    merchant?: boolean | BillSchedule$merchantArgs<ExtArgs>
  }
  export type BillScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    merchant?: boolean | BillSchedule$merchantArgs<ExtArgs>
  }
  export type BillScheduleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    merchant?: boolean | BillSchedule$merchantArgs<ExtArgs>
  }

  export type $BillSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BillSchedule"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      merchant: Prisma.$MerchantPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      merchantId: number | null
      billType: string
      provider: string
      accountNo: string
      amount: number
      dueDate: Date
      nextPayment: Date | null
      createdAt: Date
      paymentMethod: string
      status: string
      token: string | null
    }, ExtArgs["result"]["billSchedule"]>
    composites: {}
  }

  type BillScheduleGetPayload<S extends boolean | null | undefined | BillScheduleDefaultArgs> = $Result.GetResult<Prisma.$BillSchedulePayload, S>

  type BillScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BillScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BillScheduleCountAggregateInputType | true
    }

  export interface BillScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BillSchedule'], meta: { name: 'BillSchedule' } }
    /**
     * Find zero or one BillSchedule that matches the filter.
     * @param {BillScheduleFindUniqueArgs} args - Arguments to find a BillSchedule
     * @example
     * // Get one BillSchedule
     * const billSchedule = await prisma.billSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillScheduleFindUniqueArgs>(args: SelectSubset<T, BillScheduleFindUniqueArgs<ExtArgs>>): Prisma__BillScheduleClient<$Result.GetResult<Prisma.$BillSchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BillSchedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BillScheduleFindUniqueOrThrowArgs} args - Arguments to find a BillSchedule
     * @example
     * // Get one BillSchedule
     * const billSchedule = await prisma.billSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, BillScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillScheduleClient<$Result.GetResult<Prisma.$BillSchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillScheduleFindFirstArgs} args - Arguments to find a BillSchedule
     * @example
     * // Get one BillSchedule
     * const billSchedule = await prisma.billSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillScheduleFindFirstArgs>(args?: SelectSubset<T, BillScheduleFindFirstArgs<ExtArgs>>): Prisma__BillScheduleClient<$Result.GetResult<Prisma.$BillSchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillScheduleFindFirstOrThrowArgs} args - Arguments to find a BillSchedule
     * @example
     * // Get one BillSchedule
     * const billSchedule = await prisma.billSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, BillScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillScheduleClient<$Result.GetResult<Prisma.$BillSchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BillSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BillSchedules
     * const billSchedules = await prisma.billSchedule.findMany()
     * 
     * // Get first 10 BillSchedules
     * const billSchedules = await prisma.billSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billScheduleWithIdOnly = await prisma.billSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillScheduleFindManyArgs>(args?: SelectSubset<T, BillScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BillSchedule.
     * @param {BillScheduleCreateArgs} args - Arguments to create a BillSchedule.
     * @example
     * // Create one BillSchedule
     * const BillSchedule = await prisma.billSchedule.create({
     *   data: {
     *     // ... data to create a BillSchedule
     *   }
     * })
     * 
     */
    create<T extends BillScheduleCreateArgs>(args: SelectSubset<T, BillScheduleCreateArgs<ExtArgs>>): Prisma__BillScheduleClient<$Result.GetResult<Prisma.$BillSchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BillSchedules.
     * @param {BillScheduleCreateManyArgs} args - Arguments to create many BillSchedules.
     * @example
     * // Create many BillSchedules
     * const billSchedule = await prisma.billSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillScheduleCreateManyArgs>(args?: SelectSubset<T, BillScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BillSchedules and returns the data saved in the database.
     * @param {BillScheduleCreateManyAndReturnArgs} args - Arguments to create many BillSchedules.
     * @example
     * // Create many BillSchedules
     * const billSchedule = await prisma.billSchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BillSchedules and only return the `id`
     * const billScheduleWithIdOnly = await prisma.billSchedule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BillScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, BillScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillSchedulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BillSchedule.
     * @param {BillScheduleDeleteArgs} args - Arguments to delete one BillSchedule.
     * @example
     * // Delete one BillSchedule
     * const BillSchedule = await prisma.billSchedule.delete({
     *   where: {
     *     // ... filter to delete one BillSchedule
     *   }
     * })
     * 
     */
    delete<T extends BillScheduleDeleteArgs>(args: SelectSubset<T, BillScheduleDeleteArgs<ExtArgs>>): Prisma__BillScheduleClient<$Result.GetResult<Prisma.$BillSchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BillSchedule.
     * @param {BillScheduleUpdateArgs} args - Arguments to update one BillSchedule.
     * @example
     * // Update one BillSchedule
     * const billSchedule = await prisma.billSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillScheduleUpdateArgs>(args: SelectSubset<T, BillScheduleUpdateArgs<ExtArgs>>): Prisma__BillScheduleClient<$Result.GetResult<Prisma.$BillSchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BillSchedules.
     * @param {BillScheduleDeleteManyArgs} args - Arguments to filter BillSchedules to delete.
     * @example
     * // Delete a few BillSchedules
     * const { count } = await prisma.billSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillScheduleDeleteManyArgs>(args?: SelectSubset<T, BillScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BillSchedules
     * const billSchedule = await prisma.billSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillScheduleUpdateManyArgs>(args: SelectSubset<T, BillScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillSchedules and returns the data updated in the database.
     * @param {BillScheduleUpdateManyAndReturnArgs} args - Arguments to update many BillSchedules.
     * @example
     * // Update many BillSchedules
     * const billSchedule = await prisma.billSchedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BillSchedules and only return the `id`
     * const billScheduleWithIdOnly = await prisma.billSchedule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BillScheduleUpdateManyAndReturnArgs>(args: SelectSubset<T, BillScheduleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillSchedulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BillSchedule.
     * @param {BillScheduleUpsertArgs} args - Arguments to update or create a BillSchedule.
     * @example
     * // Update or create a BillSchedule
     * const billSchedule = await prisma.billSchedule.upsert({
     *   create: {
     *     // ... data to create a BillSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BillSchedule we want to update
     *   }
     * })
     */
    upsert<T extends BillScheduleUpsertArgs>(args: SelectSubset<T, BillScheduleUpsertArgs<ExtArgs>>): Prisma__BillScheduleClient<$Result.GetResult<Prisma.$BillSchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BillSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillScheduleCountArgs} args - Arguments to filter BillSchedules to count.
     * @example
     * // Count the number of BillSchedules
     * const count = await prisma.billSchedule.count({
     *   where: {
     *     // ... the filter for the BillSchedules we want to count
     *   }
     * })
    **/
    count<T extends BillScheduleCountArgs>(
      args?: Subset<T, BillScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BillSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillScheduleAggregateArgs>(args: Subset<T, BillScheduleAggregateArgs>): Prisma.PrismaPromise<GetBillScheduleAggregateType<T>>

    /**
     * Group by BillSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillScheduleGroupByArgs['orderBy'] }
        : { orderBy?: BillScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BillSchedule model
   */
  readonly fields: BillScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BillSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    merchant<T extends BillSchedule$merchantArgs<ExtArgs> = {}>(args?: Subset<T, BillSchedule$merchantArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BillSchedule model
   */
  interface BillScheduleFieldRefs {
    readonly id: FieldRef<"BillSchedule", 'Int'>
    readonly userId: FieldRef<"BillSchedule", 'Int'>
    readonly merchantId: FieldRef<"BillSchedule", 'Int'>
    readonly billType: FieldRef<"BillSchedule", 'String'>
    readonly provider: FieldRef<"BillSchedule", 'String'>
    readonly accountNo: FieldRef<"BillSchedule", 'String'>
    readonly amount: FieldRef<"BillSchedule", 'Int'>
    readonly dueDate: FieldRef<"BillSchedule", 'DateTime'>
    readonly nextPayment: FieldRef<"BillSchedule", 'DateTime'>
    readonly createdAt: FieldRef<"BillSchedule", 'DateTime'>
    readonly paymentMethod: FieldRef<"BillSchedule", 'String'>
    readonly status: FieldRef<"BillSchedule", 'String'>
    readonly token: FieldRef<"BillSchedule", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BillSchedule findUnique
   */
  export type BillScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSchedule
     */
    select?: BillScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSchedule
     */
    omit?: BillScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillScheduleInclude<ExtArgs> | null
    /**
     * Filter, which BillSchedule to fetch.
     */
    where: BillScheduleWhereUniqueInput
  }

  /**
   * BillSchedule findUniqueOrThrow
   */
  export type BillScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSchedule
     */
    select?: BillScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSchedule
     */
    omit?: BillScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillScheduleInclude<ExtArgs> | null
    /**
     * Filter, which BillSchedule to fetch.
     */
    where: BillScheduleWhereUniqueInput
  }

  /**
   * BillSchedule findFirst
   */
  export type BillScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSchedule
     */
    select?: BillScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSchedule
     */
    omit?: BillScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillScheduleInclude<ExtArgs> | null
    /**
     * Filter, which BillSchedule to fetch.
     */
    where?: BillScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillSchedules to fetch.
     */
    orderBy?: BillScheduleOrderByWithRelationInput | BillScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillSchedules.
     */
    cursor?: BillScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillSchedules.
     */
    distinct?: BillScheduleScalarFieldEnum | BillScheduleScalarFieldEnum[]
  }

  /**
   * BillSchedule findFirstOrThrow
   */
  export type BillScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSchedule
     */
    select?: BillScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSchedule
     */
    omit?: BillScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillScheduleInclude<ExtArgs> | null
    /**
     * Filter, which BillSchedule to fetch.
     */
    where?: BillScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillSchedules to fetch.
     */
    orderBy?: BillScheduleOrderByWithRelationInput | BillScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillSchedules.
     */
    cursor?: BillScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillSchedules.
     */
    distinct?: BillScheduleScalarFieldEnum | BillScheduleScalarFieldEnum[]
  }

  /**
   * BillSchedule findMany
   */
  export type BillScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSchedule
     */
    select?: BillScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSchedule
     */
    omit?: BillScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillScheduleInclude<ExtArgs> | null
    /**
     * Filter, which BillSchedules to fetch.
     */
    where?: BillScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillSchedules to fetch.
     */
    orderBy?: BillScheduleOrderByWithRelationInput | BillScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BillSchedules.
     */
    cursor?: BillScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillSchedules.
     */
    skip?: number
    distinct?: BillScheduleScalarFieldEnum | BillScheduleScalarFieldEnum[]
  }

  /**
   * BillSchedule create
   */
  export type BillScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSchedule
     */
    select?: BillScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSchedule
     */
    omit?: BillScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a BillSchedule.
     */
    data: XOR<BillScheduleCreateInput, BillScheduleUncheckedCreateInput>
  }

  /**
   * BillSchedule createMany
   */
  export type BillScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BillSchedules.
     */
    data: BillScheduleCreateManyInput | BillScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BillSchedule createManyAndReturn
   */
  export type BillScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSchedule
     */
    select?: BillScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillSchedule
     */
    omit?: BillScheduleOmit<ExtArgs> | null
    /**
     * The data used to create many BillSchedules.
     */
    data: BillScheduleCreateManyInput | BillScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillSchedule update
   */
  export type BillScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSchedule
     */
    select?: BillScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSchedule
     */
    omit?: BillScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a BillSchedule.
     */
    data: XOR<BillScheduleUpdateInput, BillScheduleUncheckedUpdateInput>
    /**
     * Choose, which BillSchedule to update.
     */
    where: BillScheduleWhereUniqueInput
  }

  /**
   * BillSchedule updateMany
   */
  export type BillScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BillSchedules.
     */
    data: XOR<BillScheduleUpdateManyMutationInput, BillScheduleUncheckedUpdateManyInput>
    /**
     * Filter which BillSchedules to update
     */
    where?: BillScheduleWhereInput
    /**
     * Limit how many BillSchedules to update.
     */
    limit?: number
  }

  /**
   * BillSchedule updateManyAndReturn
   */
  export type BillScheduleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSchedule
     */
    select?: BillScheduleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillSchedule
     */
    omit?: BillScheduleOmit<ExtArgs> | null
    /**
     * The data used to update BillSchedules.
     */
    data: XOR<BillScheduleUpdateManyMutationInput, BillScheduleUncheckedUpdateManyInput>
    /**
     * Filter which BillSchedules to update
     */
    where?: BillScheduleWhereInput
    /**
     * Limit how many BillSchedules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillScheduleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillSchedule upsert
   */
  export type BillScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSchedule
     */
    select?: BillScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSchedule
     */
    omit?: BillScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the BillSchedule to update in case it exists.
     */
    where: BillScheduleWhereUniqueInput
    /**
     * In case the BillSchedule found by the `where` argument doesn't exist, create a new BillSchedule with this data.
     */
    create: XOR<BillScheduleCreateInput, BillScheduleUncheckedCreateInput>
    /**
     * In case the BillSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillScheduleUpdateInput, BillScheduleUncheckedUpdateInput>
  }

  /**
   * BillSchedule delete
   */
  export type BillScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSchedule
     */
    select?: BillScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSchedule
     */
    omit?: BillScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillScheduleInclude<ExtArgs> | null
    /**
     * Filter which BillSchedule to delete.
     */
    where: BillScheduleWhereUniqueInput
  }

  /**
   * BillSchedule deleteMany
   */
  export type BillScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillSchedules to delete
     */
    where?: BillScheduleWhereInput
    /**
     * Limit how many BillSchedules to delete.
     */
    limit?: number
  }

  /**
   * BillSchedule.merchant
   */
  export type BillSchedule$merchantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    where?: MerchantWhereInput
  }

  /**
   * BillSchedule without action
   */
  export type BillScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSchedule
     */
    select?: BillScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSchedule
     */
    omit?: BillScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillScheduleInclude<ExtArgs> | null
  }


  /**
   * Model RechargePlan
   */

  export type AggregateRechargePlan = {
    _count: RechargePlanCountAggregateOutputType | null
    _avg: RechargePlanAvgAggregateOutputType | null
    _sum: RechargePlanSumAggregateOutputType | null
    _min: RechargePlanMinAggregateOutputType | null
    _max: RechargePlanMaxAggregateOutputType | null
  }

  export type RechargePlanAvgAggregateOutputType = {
    id: number | null
    amount: number | null
  }

  export type RechargePlanSumAggregateOutputType = {
    id: number | null
    amount: number | null
  }

  export type RechargePlanMinAggregateOutputType = {
    id: number | null
    operator: string | null
    circle: string | null
    planCode: string | null
    amount: number | null
    planType: string | null
    validity: string | null
    data: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RechargePlanMaxAggregateOutputType = {
    id: number | null
    operator: string | null
    circle: string | null
    planCode: string | null
    amount: number | null
    planType: string | null
    validity: string | null
    data: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RechargePlanCountAggregateOutputType = {
    id: number
    operator: number
    circle: number
    planCode: number
    amount: number
    planType: number
    validity: number
    data: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RechargePlanAvgAggregateInputType = {
    id?: true
    amount?: true
  }

  export type RechargePlanSumAggregateInputType = {
    id?: true
    amount?: true
  }

  export type RechargePlanMinAggregateInputType = {
    id?: true
    operator?: true
    circle?: true
    planCode?: true
    amount?: true
    planType?: true
    validity?: true
    data?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RechargePlanMaxAggregateInputType = {
    id?: true
    operator?: true
    circle?: true
    planCode?: true
    amount?: true
    planType?: true
    validity?: true
    data?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RechargePlanCountAggregateInputType = {
    id?: true
    operator?: true
    circle?: true
    planCode?: true
    amount?: true
    planType?: true
    validity?: true
    data?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RechargePlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RechargePlan to aggregate.
     */
    where?: RechargePlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RechargePlans to fetch.
     */
    orderBy?: RechargePlanOrderByWithRelationInput | RechargePlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RechargePlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RechargePlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RechargePlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RechargePlans
    **/
    _count?: true | RechargePlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RechargePlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RechargePlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RechargePlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RechargePlanMaxAggregateInputType
  }

  export type GetRechargePlanAggregateType<T extends RechargePlanAggregateArgs> = {
        [P in keyof T & keyof AggregateRechargePlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRechargePlan[P]>
      : GetScalarType<T[P], AggregateRechargePlan[P]>
  }




  export type RechargePlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RechargePlanWhereInput
    orderBy?: RechargePlanOrderByWithAggregationInput | RechargePlanOrderByWithAggregationInput[]
    by: RechargePlanScalarFieldEnum[] | RechargePlanScalarFieldEnum
    having?: RechargePlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RechargePlanCountAggregateInputType | true
    _avg?: RechargePlanAvgAggregateInputType
    _sum?: RechargePlanSumAggregateInputType
    _min?: RechargePlanMinAggregateInputType
    _max?: RechargePlanMaxAggregateInputType
  }

  export type RechargePlanGroupByOutputType = {
    id: number
    operator: string
    circle: string
    planCode: string
    amount: number
    planType: string
    validity: string | null
    data: string | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: RechargePlanCountAggregateOutputType | null
    _avg: RechargePlanAvgAggregateOutputType | null
    _sum: RechargePlanSumAggregateOutputType | null
    _min: RechargePlanMinAggregateOutputType | null
    _max: RechargePlanMaxAggregateOutputType | null
  }

  type GetRechargePlanGroupByPayload<T extends RechargePlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RechargePlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RechargePlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RechargePlanGroupByOutputType[P]>
            : GetScalarType<T[P], RechargePlanGroupByOutputType[P]>
        }
      >
    >


  export type RechargePlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    operator?: boolean
    circle?: boolean
    planCode?: boolean
    amount?: boolean
    planType?: boolean
    validity?: boolean
    data?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rechargeOrders?: boolean | RechargePlan$rechargeOrdersArgs<ExtArgs>
    _count?: boolean | RechargePlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rechargePlan"]>

  export type RechargePlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    operator?: boolean
    circle?: boolean
    planCode?: boolean
    amount?: boolean
    planType?: boolean
    validity?: boolean
    data?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["rechargePlan"]>

  export type RechargePlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    operator?: boolean
    circle?: boolean
    planCode?: boolean
    amount?: boolean
    planType?: boolean
    validity?: boolean
    data?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["rechargePlan"]>

  export type RechargePlanSelectScalar = {
    id?: boolean
    operator?: boolean
    circle?: boolean
    planCode?: boolean
    amount?: boolean
    planType?: boolean
    validity?: boolean
    data?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RechargePlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "operator" | "circle" | "planCode" | "amount" | "planType" | "validity" | "data" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["rechargePlan"]>
  export type RechargePlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rechargeOrders?: boolean | RechargePlan$rechargeOrdersArgs<ExtArgs>
    _count?: boolean | RechargePlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RechargePlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RechargePlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RechargePlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RechargePlan"
    objects: {
      rechargeOrders: Prisma.$RechargeOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      operator: string
      circle: string
      planCode: string
      amount: number
      planType: string
      validity: string | null
      data: string | null
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rechargePlan"]>
    composites: {}
  }

  type RechargePlanGetPayload<S extends boolean | null | undefined | RechargePlanDefaultArgs> = $Result.GetResult<Prisma.$RechargePlanPayload, S>

  type RechargePlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RechargePlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RechargePlanCountAggregateInputType | true
    }

  export interface RechargePlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RechargePlan'], meta: { name: 'RechargePlan' } }
    /**
     * Find zero or one RechargePlan that matches the filter.
     * @param {RechargePlanFindUniqueArgs} args - Arguments to find a RechargePlan
     * @example
     * // Get one RechargePlan
     * const rechargePlan = await prisma.rechargePlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RechargePlanFindUniqueArgs>(args: SelectSubset<T, RechargePlanFindUniqueArgs<ExtArgs>>): Prisma__RechargePlanClient<$Result.GetResult<Prisma.$RechargePlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RechargePlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RechargePlanFindUniqueOrThrowArgs} args - Arguments to find a RechargePlan
     * @example
     * // Get one RechargePlan
     * const rechargePlan = await prisma.rechargePlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RechargePlanFindUniqueOrThrowArgs>(args: SelectSubset<T, RechargePlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RechargePlanClient<$Result.GetResult<Prisma.$RechargePlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RechargePlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargePlanFindFirstArgs} args - Arguments to find a RechargePlan
     * @example
     * // Get one RechargePlan
     * const rechargePlan = await prisma.rechargePlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RechargePlanFindFirstArgs>(args?: SelectSubset<T, RechargePlanFindFirstArgs<ExtArgs>>): Prisma__RechargePlanClient<$Result.GetResult<Prisma.$RechargePlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RechargePlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargePlanFindFirstOrThrowArgs} args - Arguments to find a RechargePlan
     * @example
     * // Get one RechargePlan
     * const rechargePlan = await prisma.rechargePlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RechargePlanFindFirstOrThrowArgs>(args?: SelectSubset<T, RechargePlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__RechargePlanClient<$Result.GetResult<Prisma.$RechargePlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RechargePlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargePlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RechargePlans
     * const rechargePlans = await prisma.rechargePlan.findMany()
     * 
     * // Get first 10 RechargePlans
     * const rechargePlans = await prisma.rechargePlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rechargePlanWithIdOnly = await prisma.rechargePlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RechargePlanFindManyArgs>(args?: SelectSubset<T, RechargePlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RechargePlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RechargePlan.
     * @param {RechargePlanCreateArgs} args - Arguments to create a RechargePlan.
     * @example
     * // Create one RechargePlan
     * const RechargePlan = await prisma.rechargePlan.create({
     *   data: {
     *     // ... data to create a RechargePlan
     *   }
     * })
     * 
     */
    create<T extends RechargePlanCreateArgs>(args: SelectSubset<T, RechargePlanCreateArgs<ExtArgs>>): Prisma__RechargePlanClient<$Result.GetResult<Prisma.$RechargePlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RechargePlans.
     * @param {RechargePlanCreateManyArgs} args - Arguments to create many RechargePlans.
     * @example
     * // Create many RechargePlans
     * const rechargePlan = await prisma.rechargePlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RechargePlanCreateManyArgs>(args?: SelectSubset<T, RechargePlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RechargePlans and returns the data saved in the database.
     * @param {RechargePlanCreateManyAndReturnArgs} args - Arguments to create many RechargePlans.
     * @example
     * // Create many RechargePlans
     * const rechargePlan = await prisma.rechargePlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RechargePlans and only return the `id`
     * const rechargePlanWithIdOnly = await prisma.rechargePlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RechargePlanCreateManyAndReturnArgs>(args?: SelectSubset<T, RechargePlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RechargePlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RechargePlan.
     * @param {RechargePlanDeleteArgs} args - Arguments to delete one RechargePlan.
     * @example
     * // Delete one RechargePlan
     * const RechargePlan = await prisma.rechargePlan.delete({
     *   where: {
     *     // ... filter to delete one RechargePlan
     *   }
     * })
     * 
     */
    delete<T extends RechargePlanDeleteArgs>(args: SelectSubset<T, RechargePlanDeleteArgs<ExtArgs>>): Prisma__RechargePlanClient<$Result.GetResult<Prisma.$RechargePlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RechargePlan.
     * @param {RechargePlanUpdateArgs} args - Arguments to update one RechargePlan.
     * @example
     * // Update one RechargePlan
     * const rechargePlan = await prisma.rechargePlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RechargePlanUpdateArgs>(args: SelectSubset<T, RechargePlanUpdateArgs<ExtArgs>>): Prisma__RechargePlanClient<$Result.GetResult<Prisma.$RechargePlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RechargePlans.
     * @param {RechargePlanDeleteManyArgs} args - Arguments to filter RechargePlans to delete.
     * @example
     * // Delete a few RechargePlans
     * const { count } = await prisma.rechargePlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RechargePlanDeleteManyArgs>(args?: SelectSubset<T, RechargePlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RechargePlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargePlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RechargePlans
     * const rechargePlan = await prisma.rechargePlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RechargePlanUpdateManyArgs>(args: SelectSubset<T, RechargePlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RechargePlans and returns the data updated in the database.
     * @param {RechargePlanUpdateManyAndReturnArgs} args - Arguments to update many RechargePlans.
     * @example
     * // Update many RechargePlans
     * const rechargePlan = await prisma.rechargePlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RechargePlans and only return the `id`
     * const rechargePlanWithIdOnly = await prisma.rechargePlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RechargePlanUpdateManyAndReturnArgs>(args: SelectSubset<T, RechargePlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RechargePlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RechargePlan.
     * @param {RechargePlanUpsertArgs} args - Arguments to update or create a RechargePlan.
     * @example
     * // Update or create a RechargePlan
     * const rechargePlan = await prisma.rechargePlan.upsert({
     *   create: {
     *     // ... data to create a RechargePlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RechargePlan we want to update
     *   }
     * })
     */
    upsert<T extends RechargePlanUpsertArgs>(args: SelectSubset<T, RechargePlanUpsertArgs<ExtArgs>>): Prisma__RechargePlanClient<$Result.GetResult<Prisma.$RechargePlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RechargePlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargePlanCountArgs} args - Arguments to filter RechargePlans to count.
     * @example
     * // Count the number of RechargePlans
     * const count = await prisma.rechargePlan.count({
     *   where: {
     *     // ... the filter for the RechargePlans we want to count
     *   }
     * })
    **/
    count<T extends RechargePlanCountArgs>(
      args?: Subset<T, RechargePlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RechargePlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RechargePlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargePlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RechargePlanAggregateArgs>(args: Subset<T, RechargePlanAggregateArgs>): Prisma.PrismaPromise<GetRechargePlanAggregateType<T>>

    /**
     * Group by RechargePlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargePlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RechargePlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RechargePlanGroupByArgs['orderBy'] }
        : { orderBy?: RechargePlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RechargePlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRechargePlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RechargePlan model
   */
  readonly fields: RechargePlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RechargePlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RechargePlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rechargeOrders<T extends RechargePlan$rechargeOrdersArgs<ExtArgs> = {}>(args?: Subset<T, RechargePlan$rechargeOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RechargeOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RechargePlan model
   */
  interface RechargePlanFieldRefs {
    readonly id: FieldRef<"RechargePlan", 'Int'>
    readonly operator: FieldRef<"RechargePlan", 'String'>
    readonly circle: FieldRef<"RechargePlan", 'String'>
    readonly planCode: FieldRef<"RechargePlan", 'String'>
    readonly amount: FieldRef<"RechargePlan", 'Int'>
    readonly planType: FieldRef<"RechargePlan", 'String'>
    readonly validity: FieldRef<"RechargePlan", 'String'>
    readonly data: FieldRef<"RechargePlan", 'String'>
    readonly description: FieldRef<"RechargePlan", 'String'>
    readonly createdAt: FieldRef<"RechargePlan", 'DateTime'>
    readonly updatedAt: FieldRef<"RechargePlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RechargePlan findUnique
   */
  export type RechargePlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RechargePlan
     */
    select?: RechargePlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RechargePlan
     */
    omit?: RechargePlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RechargePlanInclude<ExtArgs> | null
    /**
     * Filter, which RechargePlan to fetch.
     */
    where: RechargePlanWhereUniqueInput
  }

  /**
   * RechargePlan findUniqueOrThrow
   */
  export type RechargePlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RechargePlan
     */
    select?: RechargePlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RechargePlan
     */
    omit?: RechargePlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RechargePlanInclude<ExtArgs> | null
    /**
     * Filter, which RechargePlan to fetch.
     */
    where: RechargePlanWhereUniqueInput
  }

  /**
   * RechargePlan findFirst
   */
  export type RechargePlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RechargePlan
     */
    select?: RechargePlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RechargePlan
     */
    omit?: RechargePlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RechargePlanInclude<ExtArgs> | null
    /**
     * Filter, which RechargePlan to fetch.
     */
    where?: RechargePlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RechargePlans to fetch.
     */
    orderBy?: RechargePlanOrderByWithRelationInput | RechargePlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RechargePlans.
     */
    cursor?: RechargePlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RechargePlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RechargePlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RechargePlans.
     */
    distinct?: RechargePlanScalarFieldEnum | RechargePlanScalarFieldEnum[]
  }

  /**
   * RechargePlan findFirstOrThrow
   */
  export type RechargePlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RechargePlan
     */
    select?: RechargePlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RechargePlan
     */
    omit?: RechargePlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RechargePlanInclude<ExtArgs> | null
    /**
     * Filter, which RechargePlan to fetch.
     */
    where?: RechargePlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RechargePlans to fetch.
     */
    orderBy?: RechargePlanOrderByWithRelationInput | RechargePlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RechargePlans.
     */
    cursor?: RechargePlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RechargePlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RechargePlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RechargePlans.
     */
    distinct?: RechargePlanScalarFieldEnum | RechargePlanScalarFieldEnum[]
  }

  /**
   * RechargePlan findMany
   */
  export type RechargePlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RechargePlan
     */
    select?: RechargePlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RechargePlan
     */
    omit?: RechargePlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RechargePlanInclude<ExtArgs> | null
    /**
     * Filter, which RechargePlans to fetch.
     */
    where?: RechargePlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RechargePlans to fetch.
     */
    orderBy?: RechargePlanOrderByWithRelationInput | RechargePlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RechargePlans.
     */
    cursor?: RechargePlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RechargePlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RechargePlans.
     */
    skip?: number
    distinct?: RechargePlanScalarFieldEnum | RechargePlanScalarFieldEnum[]
  }

  /**
   * RechargePlan create
   */
  export type RechargePlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RechargePlan
     */
    select?: RechargePlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RechargePlan
     */
    omit?: RechargePlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RechargePlanInclude<ExtArgs> | null
    /**
     * The data needed to create a RechargePlan.
     */
    data: XOR<RechargePlanCreateInput, RechargePlanUncheckedCreateInput>
  }

  /**
   * RechargePlan createMany
   */
  export type RechargePlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RechargePlans.
     */
    data: RechargePlanCreateManyInput | RechargePlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RechargePlan createManyAndReturn
   */
  export type RechargePlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RechargePlan
     */
    select?: RechargePlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RechargePlan
     */
    omit?: RechargePlanOmit<ExtArgs> | null
    /**
     * The data used to create many RechargePlans.
     */
    data: RechargePlanCreateManyInput | RechargePlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RechargePlan update
   */
  export type RechargePlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RechargePlan
     */
    select?: RechargePlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RechargePlan
     */
    omit?: RechargePlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RechargePlanInclude<ExtArgs> | null
    /**
     * The data needed to update a RechargePlan.
     */
    data: XOR<RechargePlanUpdateInput, RechargePlanUncheckedUpdateInput>
    /**
     * Choose, which RechargePlan to update.
     */
    where: RechargePlanWhereUniqueInput
  }

  /**
   * RechargePlan updateMany
   */
  export type RechargePlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RechargePlans.
     */
    data: XOR<RechargePlanUpdateManyMutationInput, RechargePlanUncheckedUpdateManyInput>
    /**
     * Filter which RechargePlans to update
     */
    where?: RechargePlanWhereInput
    /**
     * Limit how many RechargePlans to update.
     */
    limit?: number
  }

  /**
   * RechargePlan updateManyAndReturn
   */
  export type RechargePlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RechargePlan
     */
    select?: RechargePlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RechargePlan
     */
    omit?: RechargePlanOmit<ExtArgs> | null
    /**
     * The data used to update RechargePlans.
     */
    data: XOR<RechargePlanUpdateManyMutationInput, RechargePlanUncheckedUpdateManyInput>
    /**
     * Filter which RechargePlans to update
     */
    where?: RechargePlanWhereInput
    /**
     * Limit how many RechargePlans to update.
     */
    limit?: number
  }

  /**
   * RechargePlan upsert
   */
  export type RechargePlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RechargePlan
     */
    select?: RechargePlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RechargePlan
     */
    omit?: RechargePlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RechargePlanInclude<ExtArgs> | null
    /**
     * The filter to search for the RechargePlan to update in case it exists.
     */
    where: RechargePlanWhereUniqueInput
    /**
     * In case the RechargePlan found by the `where` argument doesn't exist, create a new RechargePlan with this data.
     */
    create: XOR<RechargePlanCreateInput, RechargePlanUncheckedCreateInput>
    /**
     * In case the RechargePlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RechargePlanUpdateInput, RechargePlanUncheckedUpdateInput>
  }

  /**
   * RechargePlan delete
   */
  export type RechargePlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RechargePlan
     */
    select?: RechargePlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RechargePlan
     */
    omit?: RechargePlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RechargePlanInclude<ExtArgs> | null
    /**
     * Filter which RechargePlan to delete.
     */
    where: RechargePlanWhereUniqueInput
  }

  /**
   * RechargePlan deleteMany
   */
  export type RechargePlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RechargePlans to delete
     */
    where?: RechargePlanWhereInput
    /**
     * Limit how many RechargePlans to delete.
     */
    limit?: number
  }

  /**
   * RechargePlan.rechargeOrders
   */
  export type RechargePlan$rechargeOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RechargeOrder
     */
    select?: RechargeOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RechargeOrder
     */
    omit?: RechargeOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RechargeOrderInclude<ExtArgs> | null
    where?: RechargeOrderWhereInput
    orderBy?: RechargeOrderOrderByWithRelationInput | RechargeOrderOrderByWithRelationInput[]
    cursor?: RechargeOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RechargeOrderScalarFieldEnum | RechargeOrderScalarFieldEnum[]
  }

  /**
   * RechargePlan without action
   */
  export type RechargePlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RechargePlan
     */
    select?: RechargePlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RechargePlan
     */
    omit?: RechargePlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RechargePlanInclude<ExtArgs> | null
  }


  /**
   * Model RechargeOrder
   */

  export type AggregateRechargeOrder = {
    _count: RechargeOrderCountAggregateOutputType | null
    _avg: RechargeOrderAvgAggregateOutputType | null
    _sum: RechargeOrderSumAggregateOutputType | null
    _min: RechargeOrderMinAggregateOutputType | null
    _max: RechargeOrderMaxAggregateOutputType | null
  }

  export type RechargeOrderAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    planId: number | null
    amount: number | null
  }

  export type RechargeOrderSumAggregateOutputType = {
    id: number | null
    userId: number | null
    planId: number | null
    amount: number | null
  }

  export type RechargeOrderMinAggregateOutputType = {
    id: number | null
    userId: number | null
    planId: number | null
    mobileNumber: string | null
    operator: string | null
    circle: string | null
    amount: number | null
    status: string | null
    providerTxnId: string | null
    orderId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RechargeOrderMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    planId: number | null
    mobileNumber: string | null
    operator: string | null
    circle: string | null
    amount: number | null
    status: string | null
    providerTxnId: string | null
    orderId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RechargeOrderCountAggregateOutputType = {
    id: number
    userId: number
    planId: number
    mobileNumber: number
    operator: number
    circle: number
    amount: number
    status: number
    providerTxnId: number
    orderId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RechargeOrderAvgAggregateInputType = {
    id?: true
    userId?: true
    planId?: true
    amount?: true
  }

  export type RechargeOrderSumAggregateInputType = {
    id?: true
    userId?: true
    planId?: true
    amount?: true
  }

  export type RechargeOrderMinAggregateInputType = {
    id?: true
    userId?: true
    planId?: true
    mobileNumber?: true
    operator?: true
    circle?: true
    amount?: true
    status?: true
    providerTxnId?: true
    orderId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RechargeOrderMaxAggregateInputType = {
    id?: true
    userId?: true
    planId?: true
    mobileNumber?: true
    operator?: true
    circle?: true
    amount?: true
    status?: true
    providerTxnId?: true
    orderId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RechargeOrderCountAggregateInputType = {
    id?: true
    userId?: true
    planId?: true
    mobileNumber?: true
    operator?: true
    circle?: true
    amount?: true
    status?: true
    providerTxnId?: true
    orderId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RechargeOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RechargeOrder to aggregate.
     */
    where?: RechargeOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RechargeOrders to fetch.
     */
    orderBy?: RechargeOrderOrderByWithRelationInput | RechargeOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RechargeOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RechargeOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RechargeOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RechargeOrders
    **/
    _count?: true | RechargeOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RechargeOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RechargeOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RechargeOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RechargeOrderMaxAggregateInputType
  }

  export type GetRechargeOrderAggregateType<T extends RechargeOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateRechargeOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRechargeOrder[P]>
      : GetScalarType<T[P], AggregateRechargeOrder[P]>
  }




  export type RechargeOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RechargeOrderWhereInput
    orderBy?: RechargeOrderOrderByWithAggregationInput | RechargeOrderOrderByWithAggregationInput[]
    by: RechargeOrderScalarFieldEnum[] | RechargeOrderScalarFieldEnum
    having?: RechargeOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RechargeOrderCountAggregateInputType | true
    _avg?: RechargeOrderAvgAggregateInputType
    _sum?: RechargeOrderSumAggregateInputType
    _min?: RechargeOrderMinAggregateInputType
    _max?: RechargeOrderMaxAggregateInputType
  }

  export type RechargeOrderGroupByOutputType = {
    id: number
    userId: number
    planId: number | null
    mobileNumber: string
    operator: string
    circle: string
    amount: number
    status: string
    providerTxnId: string | null
    orderId: string
    createdAt: Date
    updatedAt: Date
    _count: RechargeOrderCountAggregateOutputType | null
    _avg: RechargeOrderAvgAggregateOutputType | null
    _sum: RechargeOrderSumAggregateOutputType | null
    _min: RechargeOrderMinAggregateOutputType | null
    _max: RechargeOrderMaxAggregateOutputType | null
  }

  type GetRechargeOrderGroupByPayload<T extends RechargeOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RechargeOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RechargeOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RechargeOrderGroupByOutputType[P]>
            : GetScalarType<T[P], RechargeOrderGroupByOutputType[P]>
        }
      >
    >


  export type RechargeOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    planId?: boolean
    mobileNumber?: boolean
    operator?: boolean
    circle?: boolean
    amount?: boolean
    status?: boolean
    providerTxnId?: boolean
    orderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | RechargeOrder$planArgs<ExtArgs>
  }, ExtArgs["result"]["rechargeOrder"]>

  export type RechargeOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    planId?: boolean
    mobileNumber?: boolean
    operator?: boolean
    circle?: boolean
    amount?: boolean
    status?: boolean
    providerTxnId?: boolean
    orderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | RechargeOrder$planArgs<ExtArgs>
  }, ExtArgs["result"]["rechargeOrder"]>

  export type RechargeOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    planId?: boolean
    mobileNumber?: boolean
    operator?: boolean
    circle?: boolean
    amount?: boolean
    status?: boolean
    providerTxnId?: boolean
    orderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | RechargeOrder$planArgs<ExtArgs>
  }, ExtArgs["result"]["rechargeOrder"]>

  export type RechargeOrderSelectScalar = {
    id?: boolean
    userId?: boolean
    planId?: boolean
    mobileNumber?: boolean
    operator?: boolean
    circle?: boolean
    amount?: boolean
    status?: boolean
    providerTxnId?: boolean
    orderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RechargeOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "planId" | "mobileNumber" | "operator" | "circle" | "amount" | "status" | "providerTxnId" | "orderId" | "createdAt" | "updatedAt", ExtArgs["result"]["rechargeOrder"]>
  export type RechargeOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | RechargeOrder$planArgs<ExtArgs>
  }
  export type RechargeOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | RechargeOrder$planArgs<ExtArgs>
  }
  export type RechargeOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | RechargeOrder$planArgs<ExtArgs>
  }

  export type $RechargeOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RechargeOrder"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      plan: Prisma.$RechargePlanPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      planId: number | null
      mobileNumber: string
      operator: string
      circle: string
      amount: number
      status: string
      providerTxnId: string | null
      orderId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rechargeOrder"]>
    composites: {}
  }

  type RechargeOrderGetPayload<S extends boolean | null | undefined | RechargeOrderDefaultArgs> = $Result.GetResult<Prisma.$RechargeOrderPayload, S>

  type RechargeOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RechargeOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RechargeOrderCountAggregateInputType | true
    }

  export interface RechargeOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RechargeOrder'], meta: { name: 'RechargeOrder' } }
    /**
     * Find zero or one RechargeOrder that matches the filter.
     * @param {RechargeOrderFindUniqueArgs} args - Arguments to find a RechargeOrder
     * @example
     * // Get one RechargeOrder
     * const rechargeOrder = await prisma.rechargeOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RechargeOrderFindUniqueArgs>(args: SelectSubset<T, RechargeOrderFindUniqueArgs<ExtArgs>>): Prisma__RechargeOrderClient<$Result.GetResult<Prisma.$RechargeOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RechargeOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RechargeOrderFindUniqueOrThrowArgs} args - Arguments to find a RechargeOrder
     * @example
     * // Get one RechargeOrder
     * const rechargeOrder = await prisma.rechargeOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RechargeOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, RechargeOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RechargeOrderClient<$Result.GetResult<Prisma.$RechargeOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RechargeOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargeOrderFindFirstArgs} args - Arguments to find a RechargeOrder
     * @example
     * // Get one RechargeOrder
     * const rechargeOrder = await prisma.rechargeOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RechargeOrderFindFirstArgs>(args?: SelectSubset<T, RechargeOrderFindFirstArgs<ExtArgs>>): Prisma__RechargeOrderClient<$Result.GetResult<Prisma.$RechargeOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RechargeOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargeOrderFindFirstOrThrowArgs} args - Arguments to find a RechargeOrder
     * @example
     * // Get one RechargeOrder
     * const rechargeOrder = await prisma.rechargeOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RechargeOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, RechargeOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__RechargeOrderClient<$Result.GetResult<Prisma.$RechargeOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RechargeOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargeOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RechargeOrders
     * const rechargeOrders = await prisma.rechargeOrder.findMany()
     * 
     * // Get first 10 RechargeOrders
     * const rechargeOrders = await prisma.rechargeOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rechargeOrderWithIdOnly = await prisma.rechargeOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RechargeOrderFindManyArgs>(args?: SelectSubset<T, RechargeOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RechargeOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RechargeOrder.
     * @param {RechargeOrderCreateArgs} args - Arguments to create a RechargeOrder.
     * @example
     * // Create one RechargeOrder
     * const RechargeOrder = await prisma.rechargeOrder.create({
     *   data: {
     *     // ... data to create a RechargeOrder
     *   }
     * })
     * 
     */
    create<T extends RechargeOrderCreateArgs>(args: SelectSubset<T, RechargeOrderCreateArgs<ExtArgs>>): Prisma__RechargeOrderClient<$Result.GetResult<Prisma.$RechargeOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RechargeOrders.
     * @param {RechargeOrderCreateManyArgs} args - Arguments to create many RechargeOrders.
     * @example
     * // Create many RechargeOrders
     * const rechargeOrder = await prisma.rechargeOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RechargeOrderCreateManyArgs>(args?: SelectSubset<T, RechargeOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RechargeOrders and returns the data saved in the database.
     * @param {RechargeOrderCreateManyAndReturnArgs} args - Arguments to create many RechargeOrders.
     * @example
     * // Create many RechargeOrders
     * const rechargeOrder = await prisma.rechargeOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RechargeOrders and only return the `id`
     * const rechargeOrderWithIdOnly = await prisma.rechargeOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RechargeOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, RechargeOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RechargeOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RechargeOrder.
     * @param {RechargeOrderDeleteArgs} args - Arguments to delete one RechargeOrder.
     * @example
     * // Delete one RechargeOrder
     * const RechargeOrder = await prisma.rechargeOrder.delete({
     *   where: {
     *     // ... filter to delete one RechargeOrder
     *   }
     * })
     * 
     */
    delete<T extends RechargeOrderDeleteArgs>(args: SelectSubset<T, RechargeOrderDeleteArgs<ExtArgs>>): Prisma__RechargeOrderClient<$Result.GetResult<Prisma.$RechargeOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RechargeOrder.
     * @param {RechargeOrderUpdateArgs} args - Arguments to update one RechargeOrder.
     * @example
     * // Update one RechargeOrder
     * const rechargeOrder = await prisma.rechargeOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RechargeOrderUpdateArgs>(args: SelectSubset<T, RechargeOrderUpdateArgs<ExtArgs>>): Prisma__RechargeOrderClient<$Result.GetResult<Prisma.$RechargeOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RechargeOrders.
     * @param {RechargeOrderDeleteManyArgs} args - Arguments to filter RechargeOrders to delete.
     * @example
     * // Delete a few RechargeOrders
     * const { count } = await prisma.rechargeOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RechargeOrderDeleteManyArgs>(args?: SelectSubset<T, RechargeOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RechargeOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargeOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RechargeOrders
     * const rechargeOrder = await prisma.rechargeOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RechargeOrderUpdateManyArgs>(args: SelectSubset<T, RechargeOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RechargeOrders and returns the data updated in the database.
     * @param {RechargeOrderUpdateManyAndReturnArgs} args - Arguments to update many RechargeOrders.
     * @example
     * // Update many RechargeOrders
     * const rechargeOrder = await prisma.rechargeOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RechargeOrders and only return the `id`
     * const rechargeOrderWithIdOnly = await prisma.rechargeOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RechargeOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, RechargeOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RechargeOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RechargeOrder.
     * @param {RechargeOrderUpsertArgs} args - Arguments to update or create a RechargeOrder.
     * @example
     * // Update or create a RechargeOrder
     * const rechargeOrder = await prisma.rechargeOrder.upsert({
     *   create: {
     *     // ... data to create a RechargeOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RechargeOrder we want to update
     *   }
     * })
     */
    upsert<T extends RechargeOrderUpsertArgs>(args: SelectSubset<T, RechargeOrderUpsertArgs<ExtArgs>>): Prisma__RechargeOrderClient<$Result.GetResult<Prisma.$RechargeOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RechargeOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargeOrderCountArgs} args - Arguments to filter RechargeOrders to count.
     * @example
     * // Count the number of RechargeOrders
     * const count = await prisma.rechargeOrder.count({
     *   where: {
     *     // ... the filter for the RechargeOrders we want to count
     *   }
     * })
    **/
    count<T extends RechargeOrderCountArgs>(
      args?: Subset<T, RechargeOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RechargeOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RechargeOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargeOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RechargeOrderAggregateArgs>(args: Subset<T, RechargeOrderAggregateArgs>): Prisma.PrismaPromise<GetRechargeOrderAggregateType<T>>

    /**
     * Group by RechargeOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargeOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RechargeOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RechargeOrderGroupByArgs['orderBy'] }
        : { orderBy?: RechargeOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RechargeOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRechargeOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RechargeOrder model
   */
  readonly fields: RechargeOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RechargeOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RechargeOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    plan<T extends RechargeOrder$planArgs<ExtArgs> = {}>(args?: Subset<T, RechargeOrder$planArgs<ExtArgs>>): Prisma__RechargePlanClient<$Result.GetResult<Prisma.$RechargePlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RechargeOrder model
   */
  interface RechargeOrderFieldRefs {
    readonly id: FieldRef<"RechargeOrder", 'Int'>
    readonly userId: FieldRef<"RechargeOrder", 'Int'>
    readonly planId: FieldRef<"RechargeOrder", 'Int'>
    readonly mobileNumber: FieldRef<"RechargeOrder", 'String'>
    readonly operator: FieldRef<"RechargeOrder", 'String'>
    readonly circle: FieldRef<"RechargeOrder", 'String'>
    readonly amount: FieldRef<"RechargeOrder", 'Int'>
    readonly status: FieldRef<"RechargeOrder", 'String'>
    readonly providerTxnId: FieldRef<"RechargeOrder", 'String'>
    readonly orderId: FieldRef<"RechargeOrder", 'String'>
    readonly createdAt: FieldRef<"RechargeOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"RechargeOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RechargeOrder findUnique
   */
  export type RechargeOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RechargeOrder
     */
    select?: RechargeOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RechargeOrder
     */
    omit?: RechargeOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RechargeOrderInclude<ExtArgs> | null
    /**
     * Filter, which RechargeOrder to fetch.
     */
    where: RechargeOrderWhereUniqueInput
  }

  /**
   * RechargeOrder findUniqueOrThrow
   */
  export type RechargeOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RechargeOrder
     */
    select?: RechargeOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RechargeOrder
     */
    omit?: RechargeOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RechargeOrderInclude<ExtArgs> | null
    /**
     * Filter, which RechargeOrder to fetch.
     */
    where: RechargeOrderWhereUniqueInput
  }

  /**
   * RechargeOrder findFirst
   */
  export type RechargeOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RechargeOrder
     */
    select?: RechargeOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RechargeOrder
     */
    omit?: RechargeOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RechargeOrderInclude<ExtArgs> | null
    /**
     * Filter, which RechargeOrder to fetch.
     */
    where?: RechargeOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RechargeOrders to fetch.
     */
    orderBy?: RechargeOrderOrderByWithRelationInput | RechargeOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RechargeOrders.
     */
    cursor?: RechargeOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RechargeOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RechargeOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RechargeOrders.
     */
    distinct?: RechargeOrderScalarFieldEnum | RechargeOrderScalarFieldEnum[]
  }

  /**
   * RechargeOrder findFirstOrThrow
   */
  export type RechargeOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RechargeOrder
     */
    select?: RechargeOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RechargeOrder
     */
    omit?: RechargeOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RechargeOrderInclude<ExtArgs> | null
    /**
     * Filter, which RechargeOrder to fetch.
     */
    where?: RechargeOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RechargeOrders to fetch.
     */
    orderBy?: RechargeOrderOrderByWithRelationInput | RechargeOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RechargeOrders.
     */
    cursor?: RechargeOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RechargeOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RechargeOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RechargeOrders.
     */
    distinct?: RechargeOrderScalarFieldEnum | RechargeOrderScalarFieldEnum[]
  }

  /**
   * RechargeOrder findMany
   */
  export type RechargeOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RechargeOrder
     */
    select?: RechargeOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RechargeOrder
     */
    omit?: RechargeOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RechargeOrderInclude<ExtArgs> | null
    /**
     * Filter, which RechargeOrders to fetch.
     */
    where?: RechargeOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RechargeOrders to fetch.
     */
    orderBy?: RechargeOrderOrderByWithRelationInput | RechargeOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RechargeOrders.
     */
    cursor?: RechargeOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RechargeOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RechargeOrders.
     */
    skip?: number
    distinct?: RechargeOrderScalarFieldEnum | RechargeOrderScalarFieldEnum[]
  }

  /**
   * RechargeOrder create
   */
  export type RechargeOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RechargeOrder
     */
    select?: RechargeOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RechargeOrder
     */
    omit?: RechargeOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RechargeOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a RechargeOrder.
     */
    data: XOR<RechargeOrderCreateInput, RechargeOrderUncheckedCreateInput>
  }

  /**
   * RechargeOrder createMany
   */
  export type RechargeOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RechargeOrders.
     */
    data: RechargeOrderCreateManyInput | RechargeOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RechargeOrder createManyAndReturn
   */
  export type RechargeOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RechargeOrder
     */
    select?: RechargeOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RechargeOrder
     */
    omit?: RechargeOrderOmit<ExtArgs> | null
    /**
     * The data used to create many RechargeOrders.
     */
    data: RechargeOrderCreateManyInput | RechargeOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RechargeOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RechargeOrder update
   */
  export type RechargeOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RechargeOrder
     */
    select?: RechargeOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RechargeOrder
     */
    omit?: RechargeOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RechargeOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a RechargeOrder.
     */
    data: XOR<RechargeOrderUpdateInput, RechargeOrderUncheckedUpdateInput>
    /**
     * Choose, which RechargeOrder to update.
     */
    where: RechargeOrderWhereUniqueInput
  }

  /**
   * RechargeOrder updateMany
   */
  export type RechargeOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RechargeOrders.
     */
    data: XOR<RechargeOrderUpdateManyMutationInput, RechargeOrderUncheckedUpdateManyInput>
    /**
     * Filter which RechargeOrders to update
     */
    where?: RechargeOrderWhereInput
    /**
     * Limit how many RechargeOrders to update.
     */
    limit?: number
  }

  /**
   * RechargeOrder updateManyAndReturn
   */
  export type RechargeOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RechargeOrder
     */
    select?: RechargeOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RechargeOrder
     */
    omit?: RechargeOrderOmit<ExtArgs> | null
    /**
     * The data used to update RechargeOrders.
     */
    data: XOR<RechargeOrderUpdateManyMutationInput, RechargeOrderUncheckedUpdateManyInput>
    /**
     * Filter which RechargeOrders to update
     */
    where?: RechargeOrderWhereInput
    /**
     * Limit how many RechargeOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RechargeOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RechargeOrder upsert
   */
  export type RechargeOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RechargeOrder
     */
    select?: RechargeOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RechargeOrder
     */
    omit?: RechargeOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RechargeOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the RechargeOrder to update in case it exists.
     */
    where: RechargeOrderWhereUniqueInput
    /**
     * In case the RechargeOrder found by the `where` argument doesn't exist, create a new RechargeOrder with this data.
     */
    create: XOR<RechargeOrderCreateInput, RechargeOrderUncheckedCreateInput>
    /**
     * In case the RechargeOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RechargeOrderUpdateInput, RechargeOrderUncheckedUpdateInput>
  }

  /**
   * RechargeOrder delete
   */
  export type RechargeOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RechargeOrder
     */
    select?: RechargeOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RechargeOrder
     */
    omit?: RechargeOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RechargeOrderInclude<ExtArgs> | null
    /**
     * Filter which RechargeOrder to delete.
     */
    where: RechargeOrderWhereUniqueInput
  }

  /**
   * RechargeOrder deleteMany
   */
  export type RechargeOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RechargeOrders to delete
     */
    where?: RechargeOrderWhereInput
    /**
     * Limit how many RechargeOrders to delete.
     */
    limit?: number
  }

  /**
   * RechargeOrder.plan
   */
  export type RechargeOrder$planArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RechargePlan
     */
    select?: RechargePlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RechargePlan
     */
    omit?: RechargePlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RechargePlanInclude<ExtArgs> | null
    where?: RechargePlanWhereInput
  }

  /**
   * RechargeOrder without action
   */
  export type RechargeOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RechargeOrder
     */
    select?: RechargeOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RechargeOrder
     */
    omit?: RechargeOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RechargeOrderInclude<ExtArgs> | null
  }


  /**
   * Model Reward
   */

  export type AggregateReward = {
    _count: RewardCountAggregateOutputType | null
    _avg: RewardAvgAggregateOutputType | null
    _sum: RewardSumAggregateOutputType | null
    _min: RewardMinAggregateOutputType | null
    _max: RewardMaxAggregateOutputType | null
  }

  export type RewardAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: number | null
    billSplitGroupId: number | null
  }

  export type RewardSumAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: bigint | null
    billSplitGroupId: number | null
  }

  export type RewardMinAggregateOutputType = {
    id: number | null
    userId: number | null
    type: $Enums.RewardType | null
    amount: bigint | null
    status: $Enums.RewardStatus | null
    earnedAt: Date | null
    expiresAt: Date | null
    billSplitGroupId: number | null
  }

  export type RewardMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    type: $Enums.RewardType | null
    amount: bigint | null
    status: $Enums.RewardStatus | null
    earnedAt: Date | null
    expiresAt: Date | null
    billSplitGroupId: number | null
  }

  export type RewardCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    amount: number
    status: number
    earnedAt: number
    expiresAt: number
    metadata: number
    billSplitGroupId: number
    _all: number
  }


  export type RewardAvgAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    billSplitGroupId?: true
  }

  export type RewardSumAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    billSplitGroupId?: true
  }

  export type RewardMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    amount?: true
    status?: true
    earnedAt?: true
    expiresAt?: true
    billSplitGroupId?: true
  }

  export type RewardMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    amount?: true
    status?: true
    earnedAt?: true
    expiresAt?: true
    billSplitGroupId?: true
  }

  export type RewardCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    amount?: true
    status?: true
    earnedAt?: true
    expiresAt?: true
    metadata?: true
    billSplitGroupId?: true
    _all?: true
  }

  export type RewardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reward to aggregate.
     */
    where?: RewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rewards to fetch.
     */
    orderBy?: RewardOrderByWithRelationInput | RewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rewards
    **/
    _count?: true | RewardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RewardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RewardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RewardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RewardMaxAggregateInputType
  }

  export type GetRewardAggregateType<T extends RewardAggregateArgs> = {
        [P in keyof T & keyof AggregateReward]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReward[P]>
      : GetScalarType<T[P], AggregateReward[P]>
  }




  export type RewardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RewardWhereInput
    orderBy?: RewardOrderByWithAggregationInput | RewardOrderByWithAggregationInput[]
    by: RewardScalarFieldEnum[] | RewardScalarFieldEnum
    having?: RewardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RewardCountAggregateInputType | true
    _avg?: RewardAvgAggregateInputType
    _sum?: RewardSumAggregateInputType
    _min?: RewardMinAggregateInputType
    _max?: RewardMaxAggregateInputType
  }

  export type RewardGroupByOutputType = {
    id: number
    userId: number
    type: $Enums.RewardType
    amount: bigint
    status: $Enums.RewardStatus
    earnedAt: Date
    expiresAt: Date | null
    metadata: JsonValue | null
    billSplitGroupId: number | null
    _count: RewardCountAggregateOutputType | null
    _avg: RewardAvgAggregateOutputType | null
    _sum: RewardSumAggregateOutputType | null
    _min: RewardMinAggregateOutputType | null
    _max: RewardMaxAggregateOutputType | null
  }

  type GetRewardGroupByPayload<T extends RewardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RewardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RewardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RewardGroupByOutputType[P]>
            : GetScalarType<T[P], RewardGroupByOutputType[P]>
        }
      >
    >


  export type RewardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    amount?: boolean
    status?: boolean
    earnedAt?: boolean
    expiresAt?: boolean
    metadata?: boolean
    billSplitGroupId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    billSplitGroup?: boolean | Reward$billSplitGroupArgs<ExtArgs>
  }, ExtArgs["result"]["reward"]>

  export type RewardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    amount?: boolean
    status?: boolean
    earnedAt?: boolean
    expiresAt?: boolean
    metadata?: boolean
    billSplitGroupId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    billSplitGroup?: boolean | Reward$billSplitGroupArgs<ExtArgs>
  }, ExtArgs["result"]["reward"]>

  export type RewardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    amount?: boolean
    status?: boolean
    earnedAt?: boolean
    expiresAt?: boolean
    metadata?: boolean
    billSplitGroupId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    billSplitGroup?: boolean | Reward$billSplitGroupArgs<ExtArgs>
  }, ExtArgs["result"]["reward"]>

  export type RewardSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    amount?: boolean
    status?: boolean
    earnedAt?: boolean
    expiresAt?: boolean
    metadata?: boolean
    billSplitGroupId?: boolean
  }

  export type RewardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "amount" | "status" | "earnedAt" | "expiresAt" | "metadata" | "billSplitGroupId", ExtArgs["result"]["reward"]>
  export type RewardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    billSplitGroup?: boolean | Reward$billSplitGroupArgs<ExtArgs>
  }
  export type RewardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    billSplitGroup?: boolean | Reward$billSplitGroupArgs<ExtArgs>
  }
  export type RewardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    billSplitGroup?: boolean | Reward$billSplitGroupArgs<ExtArgs>
  }

  export type $RewardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reward"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      billSplitGroup: Prisma.$BillSplitGroupPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      type: $Enums.RewardType
      amount: bigint
      status: $Enums.RewardStatus
      earnedAt: Date
      expiresAt: Date | null
      metadata: Prisma.JsonValue | null
      billSplitGroupId: number | null
    }, ExtArgs["result"]["reward"]>
    composites: {}
  }

  type RewardGetPayload<S extends boolean | null | undefined | RewardDefaultArgs> = $Result.GetResult<Prisma.$RewardPayload, S>

  type RewardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RewardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RewardCountAggregateInputType | true
    }

  export interface RewardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reward'], meta: { name: 'Reward' } }
    /**
     * Find zero or one Reward that matches the filter.
     * @param {RewardFindUniqueArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RewardFindUniqueArgs>(args: SelectSubset<T, RewardFindUniqueArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reward that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RewardFindUniqueOrThrowArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RewardFindUniqueOrThrowArgs>(args: SelectSubset<T, RewardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reward that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardFindFirstArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RewardFindFirstArgs>(args?: SelectSubset<T, RewardFindFirstArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reward that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardFindFirstOrThrowArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RewardFindFirstOrThrowArgs>(args?: SelectSubset<T, RewardFindFirstOrThrowArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rewards
     * const rewards = await prisma.reward.findMany()
     * 
     * // Get first 10 Rewards
     * const rewards = await prisma.reward.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rewardWithIdOnly = await prisma.reward.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RewardFindManyArgs>(args?: SelectSubset<T, RewardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reward.
     * @param {RewardCreateArgs} args - Arguments to create a Reward.
     * @example
     * // Create one Reward
     * const Reward = await prisma.reward.create({
     *   data: {
     *     // ... data to create a Reward
     *   }
     * })
     * 
     */
    create<T extends RewardCreateArgs>(args: SelectSubset<T, RewardCreateArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rewards.
     * @param {RewardCreateManyArgs} args - Arguments to create many Rewards.
     * @example
     * // Create many Rewards
     * const reward = await prisma.reward.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RewardCreateManyArgs>(args?: SelectSubset<T, RewardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rewards and returns the data saved in the database.
     * @param {RewardCreateManyAndReturnArgs} args - Arguments to create many Rewards.
     * @example
     * // Create many Rewards
     * const reward = await prisma.reward.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rewards and only return the `id`
     * const rewardWithIdOnly = await prisma.reward.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RewardCreateManyAndReturnArgs>(args?: SelectSubset<T, RewardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Reward.
     * @param {RewardDeleteArgs} args - Arguments to delete one Reward.
     * @example
     * // Delete one Reward
     * const Reward = await prisma.reward.delete({
     *   where: {
     *     // ... filter to delete one Reward
     *   }
     * })
     * 
     */
    delete<T extends RewardDeleteArgs>(args: SelectSubset<T, RewardDeleteArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reward.
     * @param {RewardUpdateArgs} args - Arguments to update one Reward.
     * @example
     * // Update one Reward
     * const reward = await prisma.reward.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RewardUpdateArgs>(args: SelectSubset<T, RewardUpdateArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rewards.
     * @param {RewardDeleteManyArgs} args - Arguments to filter Rewards to delete.
     * @example
     * // Delete a few Rewards
     * const { count } = await prisma.reward.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RewardDeleteManyArgs>(args?: SelectSubset<T, RewardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rewards
     * const reward = await prisma.reward.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RewardUpdateManyArgs>(args: SelectSubset<T, RewardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rewards and returns the data updated in the database.
     * @param {RewardUpdateManyAndReturnArgs} args - Arguments to update many Rewards.
     * @example
     * // Update many Rewards
     * const reward = await prisma.reward.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Rewards and only return the `id`
     * const rewardWithIdOnly = await prisma.reward.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RewardUpdateManyAndReturnArgs>(args: SelectSubset<T, RewardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Reward.
     * @param {RewardUpsertArgs} args - Arguments to update or create a Reward.
     * @example
     * // Update or create a Reward
     * const reward = await prisma.reward.upsert({
     *   create: {
     *     // ... data to create a Reward
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reward we want to update
     *   }
     * })
     */
    upsert<T extends RewardUpsertArgs>(args: SelectSubset<T, RewardUpsertArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardCountArgs} args - Arguments to filter Rewards to count.
     * @example
     * // Count the number of Rewards
     * const count = await prisma.reward.count({
     *   where: {
     *     // ... the filter for the Rewards we want to count
     *   }
     * })
    **/
    count<T extends RewardCountArgs>(
      args?: Subset<T, RewardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RewardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RewardAggregateArgs>(args: Subset<T, RewardAggregateArgs>): Prisma.PrismaPromise<GetRewardAggregateType<T>>

    /**
     * Group by Reward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RewardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RewardGroupByArgs['orderBy'] }
        : { orderBy?: RewardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RewardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRewardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reward model
   */
  readonly fields: RewardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reward.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RewardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    billSplitGroup<T extends Reward$billSplitGroupArgs<ExtArgs> = {}>(args?: Subset<T, Reward$billSplitGroupArgs<ExtArgs>>): Prisma__BillSplitGroupClient<$Result.GetResult<Prisma.$BillSplitGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reward model
   */
  interface RewardFieldRefs {
    readonly id: FieldRef<"Reward", 'Int'>
    readonly userId: FieldRef<"Reward", 'Int'>
    readonly type: FieldRef<"Reward", 'RewardType'>
    readonly amount: FieldRef<"Reward", 'BigInt'>
    readonly status: FieldRef<"Reward", 'RewardStatus'>
    readonly earnedAt: FieldRef<"Reward", 'DateTime'>
    readonly expiresAt: FieldRef<"Reward", 'DateTime'>
    readonly metadata: FieldRef<"Reward", 'Json'>
    readonly billSplitGroupId: FieldRef<"Reward", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Reward findUnique
   */
  export type RewardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * Filter, which Reward to fetch.
     */
    where: RewardWhereUniqueInput
  }

  /**
   * Reward findUniqueOrThrow
   */
  export type RewardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * Filter, which Reward to fetch.
     */
    where: RewardWhereUniqueInput
  }

  /**
   * Reward findFirst
   */
  export type RewardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * Filter, which Reward to fetch.
     */
    where?: RewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rewards to fetch.
     */
    orderBy?: RewardOrderByWithRelationInput | RewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rewards.
     */
    cursor?: RewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rewards.
     */
    distinct?: RewardScalarFieldEnum | RewardScalarFieldEnum[]
  }

  /**
   * Reward findFirstOrThrow
   */
  export type RewardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * Filter, which Reward to fetch.
     */
    where?: RewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rewards to fetch.
     */
    orderBy?: RewardOrderByWithRelationInput | RewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rewards.
     */
    cursor?: RewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rewards.
     */
    distinct?: RewardScalarFieldEnum | RewardScalarFieldEnum[]
  }

  /**
   * Reward findMany
   */
  export type RewardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * Filter, which Rewards to fetch.
     */
    where?: RewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rewards to fetch.
     */
    orderBy?: RewardOrderByWithRelationInput | RewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rewards.
     */
    cursor?: RewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rewards.
     */
    skip?: number
    distinct?: RewardScalarFieldEnum | RewardScalarFieldEnum[]
  }

  /**
   * Reward create
   */
  export type RewardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * The data needed to create a Reward.
     */
    data: XOR<RewardCreateInput, RewardUncheckedCreateInput>
  }

  /**
   * Reward createMany
   */
  export type RewardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rewards.
     */
    data: RewardCreateManyInput | RewardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reward createManyAndReturn
   */
  export type RewardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * The data used to create many Rewards.
     */
    data: RewardCreateManyInput | RewardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reward update
   */
  export type RewardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * The data needed to update a Reward.
     */
    data: XOR<RewardUpdateInput, RewardUncheckedUpdateInput>
    /**
     * Choose, which Reward to update.
     */
    where: RewardWhereUniqueInput
  }

  /**
   * Reward updateMany
   */
  export type RewardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rewards.
     */
    data: XOR<RewardUpdateManyMutationInput, RewardUncheckedUpdateManyInput>
    /**
     * Filter which Rewards to update
     */
    where?: RewardWhereInput
    /**
     * Limit how many Rewards to update.
     */
    limit?: number
  }

  /**
   * Reward updateManyAndReturn
   */
  export type RewardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * The data used to update Rewards.
     */
    data: XOR<RewardUpdateManyMutationInput, RewardUncheckedUpdateManyInput>
    /**
     * Filter which Rewards to update
     */
    where?: RewardWhereInput
    /**
     * Limit how many Rewards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reward upsert
   */
  export type RewardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * The filter to search for the Reward to update in case it exists.
     */
    where: RewardWhereUniqueInput
    /**
     * In case the Reward found by the `where` argument doesn't exist, create a new Reward with this data.
     */
    create: XOR<RewardCreateInput, RewardUncheckedCreateInput>
    /**
     * In case the Reward was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RewardUpdateInput, RewardUncheckedUpdateInput>
  }

  /**
   * Reward delete
   */
  export type RewardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * Filter which Reward to delete.
     */
    where: RewardWhereUniqueInput
  }

  /**
   * Reward deleteMany
   */
  export type RewardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rewards to delete
     */
    where?: RewardWhereInput
    /**
     * Limit how many Rewards to delete.
     */
    limit?: number
  }

  /**
   * Reward.billSplitGroup
   */
  export type Reward$billSplitGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitGroup
     */
    select?: BillSplitGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitGroup
     */
    omit?: BillSplitGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitGroupInclude<ExtArgs> | null
    where?: BillSplitGroupWhereInput
  }

  /**
   * Reward without action
   */
  export type RewardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
  }


  /**
   * Model Referral
   */

  export type AggregateReferral = {
    _count: ReferralCountAggregateOutputType | null
    _avg: ReferralAvgAggregateOutputType | null
    _sum: ReferralSumAggregateOutputType | null
    _min: ReferralMinAggregateOutputType | null
    _max: ReferralMaxAggregateOutputType | null
  }

  export type ReferralAvgAggregateOutputType = {
    id: number | null
    referrerId: number | null
    referredUserId: number | null
  }

  export type ReferralSumAggregateOutputType = {
    id: number | null
    referrerId: number | null
    referredUserId: number | null
  }

  export type ReferralMinAggregateOutputType = {
    id: number | null
    referrerId: number | null
    referredUserId: number | null
    referralCode: string | null
  }

  export type ReferralMaxAggregateOutputType = {
    id: number | null
    referrerId: number | null
    referredUserId: number | null
    referralCode: string | null
  }

  export type ReferralCountAggregateOutputType = {
    id: number
    referrerId: number
    referredUserId: number
    referralCode: number
    _all: number
  }


  export type ReferralAvgAggregateInputType = {
    id?: true
    referrerId?: true
    referredUserId?: true
  }

  export type ReferralSumAggregateInputType = {
    id?: true
    referrerId?: true
    referredUserId?: true
  }

  export type ReferralMinAggregateInputType = {
    id?: true
    referrerId?: true
    referredUserId?: true
    referralCode?: true
  }

  export type ReferralMaxAggregateInputType = {
    id?: true
    referrerId?: true
    referredUserId?: true
    referralCode?: true
  }

  export type ReferralCountAggregateInputType = {
    id?: true
    referrerId?: true
    referredUserId?: true
    referralCode?: true
    _all?: true
  }

  export type ReferralAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referral to aggregate.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Referrals
    **/
    _count?: true | ReferralCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReferralAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReferralSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferralMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferralMaxAggregateInputType
  }

  export type GetReferralAggregateType<T extends ReferralAggregateArgs> = {
        [P in keyof T & keyof AggregateReferral]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferral[P]>
      : GetScalarType<T[P], AggregateReferral[P]>
  }




  export type ReferralGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithAggregationInput | ReferralOrderByWithAggregationInput[]
    by: ReferralScalarFieldEnum[] | ReferralScalarFieldEnum
    having?: ReferralScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferralCountAggregateInputType | true
    _avg?: ReferralAvgAggregateInputType
    _sum?: ReferralSumAggregateInputType
    _min?: ReferralMinAggregateInputType
    _max?: ReferralMaxAggregateInputType
  }

  export type ReferralGroupByOutputType = {
    id: number
    referrerId: number
    referredUserId: number | null
    referralCode: string
    _count: ReferralCountAggregateOutputType | null
    _avg: ReferralAvgAggregateOutputType | null
    _sum: ReferralSumAggregateOutputType | null
    _min: ReferralMinAggregateOutputType | null
    _max: ReferralMaxAggregateOutputType | null
  }

  type GetReferralGroupByPayload<T extends ReferralGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferralGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferralGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferralGroupByOutputType[P]>
            : GetScalarType<T[P], ReferralGroupByOutputType[P]>
        }
      >
    >


  export type ReferralSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referrerId?: boolean
    referredUserId?: boolean
    referralCode?: boolean
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referred?: boolean | Referral$referredArgs<ExtArgs>
  }, ExtArgs["result"]["referral"]>

  export type ReferralSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referrerId?: boolean
    referredUserId?: boolean
    referralCode?: boolean
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referred?: boolean | Referral$referredArgs<ExtArgs>
  }, ExtArgs["result"]["referral"]>

  export type ReferralSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referrerId?: boolean
    referredUserId?: boolean
    referralCode?: boolean
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referred?: boolean | Referral$referredArgs<ExtArgs>
  }, ExtArgs["result"]["referral"]>

  export type ReferralSelectScalar = {
    id?: boolean
    referrerId?: boolean
    referredUserId?: boolean
    referralCode?: boolean
  }

  export type ReferralOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "referrerId" | "referredUserId" | "referralCode", ExtArgs["result"]["referral"]>
  export type ReferralInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referred?: boolean | Referral$referredArgs<ExtArgs>
  }
  export type ReferralIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referred?: boolean | Referral$referredArgs<ExtArgs>
  }
  export type ReferralIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referred?: boolean | Referral$referredArgs<ExtArgs>
  }

  export type $ReferralPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Referral"
    objects: {
      referrer: Prisma.$UserPayload<ExtArgs>
      referred: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      referrerId: number
      referredUserId: number | null
      referralCode: string
    }, ExtArgs["result"]["referral"]>
    composites: {}
  }

  type ReferralGetPayload<S extends boolean | null | undefined | ReferralDefaultArgs> = $Result.GetResult<Prisma.$ReferralPayload, S>

  type ReferralCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReferralFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReferralCountAggregateInputType | true
    }

  export interface ReferralDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Referral'], meta: { name: 'Referral' } }
    /**
     * Find zero or one Referral that matches the filter.
     * @param {ReferralFindUniqueArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferralFindUniqueArgs>(args: SelectSubset<T, ReferralFindUniqueArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Referral that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReferralFindUniqueOrThrowArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferralFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferralFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Referral that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindFirstArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferralFindFirstArgs>(args?: SelectSubset<T, ReferralFindFirstArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Referral that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindFirstOrThrowArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferralFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferralFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Referrals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Referrals
     * const referrals = await prisma.referral.findMany()
     * 
     * // Get first 10 Referrals
     * const referrals = await prisma.referral.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referralWithIdOnly = await prisma.referral.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReferralFindManyArgs>(args?: SelectSubset<T, ReferralFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Referral.
     * @param {ReferralCreateArgs} args - Arguments to create a Referral.
     * @example
     * // Create one Referral
     * const Referral = await prisma.referral.create({
     *   data: {
     *     // ... data to create a Referral
     *   }
     * })
     * 
     */
    create<T extends ReferralCreateArgs>(args: SelectSubset<T, ReferralCreateArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Referrals.
     * @param {ReferralCreateManyArgs} args - Arguments to create many Referrals.
     * @example
     * // Create many Referrals
     * const referral = await prisma.referral.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferralCreateManyArgs>(args?: SelectSubset<T, ReferralCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Referrals and returns the data saved in the database.
     * @param {ReferralCreateManyAndReturnArgs} args - Arguments to create many Referrals.
     * @example
     * // Create many Referrals
     * const referral = await prisma.referral.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Referrals and only return the `id`
     * const referralWithIdOnly = await prisma.referral.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReferralCreateManyAndReturnArgs>(args?: SelectSubset<T, ReferralCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Referral.
     * @param {ReferralDeleteArgs} args - Arguments to delete one Referral.
     * @example
     * // Delete one Referral
     * const Referral = await prisma.referral.delete({
     *   where: {
     *     // ... filter to delete one Referral
     *   }
     * })
     * 
     */
    delete<T extends ReferralDeleteArgs>(args: SelectSubset<T, ReferralDeleteArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Referral.
     * @param {ReferralUpdateArgs} args - Arguments to update one Referral.
     * @example
     * // Update one Referral
     * const referral = await prisma.referral.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferralUpdateArgs>(args: SelectSubset<T, ReferralUpdateArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Referrals.
     * @param {ReferralDeleteManyArgs} args - Arguments to filter Referrals to delete.
     * @example
     * // Delete a few Referrals
     * const { count } = await prisma.referral.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferralDeleteManyArgs>(args?: SelectSubset<T, ReferralDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Referrals
     * const referral = await prisma.referral.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferralUpdateManyArgs>(args: SelectSubset<T, ReferralUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referrals and returns the data updated in the database.
     * @param {ReferralUpdateManyAndReturnArgs} args - Arguments to update many Referrals.
     * @example
     * // Update many Referrals
     * const referral = await prisma.referral.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Referrals and only return the `id`
     * const referralWithIdOnly = await prisma.referral.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReferralUpdateManyAndReturnArgs>(args: SelectSubset<T, ReferralUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Referral.
     * @param {ReferralUpsertArgs} args - Arguments to update or create a Referral.
     * @example
     * // Update or create a Referral
     * const referral = await prisma.referral.upsert({
     *   create: {
     *     // ... data to create a Referral
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Referral we want to update
     *   }
     * })
     */
    upsert<T extends ReferralUpsertArgs>(args: SelectSubset<T, ReferralUpsertArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralCountArgs} args - Arguments to filter Referrals to count.
     * @example
     * // Count the number of Referrals
     * const count = await prisma.referral.count({
     *   where: {
     *     // ... the filter for the Referrals we want to count
     *   }
     * })
    **/
    count<T extends ReferralCountArgs>(
      args?: Subset<T, ReferralCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferralCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Referral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferralAggregateArgs>(args: Subset<T, ReferralAggregateArgs>): Prisma.PrismaPromise<GetReferralAggregateType<T>>

    /**
     * Group by Referral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferralGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferralGroupByArgs['orderBy'] }
        : { orderBy?: ReferralGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferralGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferralGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Referral model
   */
  readonly fields: ReferralFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Referral.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferralClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    referrer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    referred<T extends Referral$referredArgs<ExtArgs> = {}>(args?: Subset<T, Referral$referredArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Referral model
   */
  interface ReferralFieldRefs {
    readonly id: FieldRef<"Referral", 'Int'>
    readonly referrerId: FieldRef<"Referral", 'Int'>
    readonly referredUserId: FieldRef<"Referral", 'Int'>
    readonly referralCode: FieldRef<"Referral", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Referral findUnique
   */
  export type ReferralFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral findUniqueOrThrow
   */
  export type ReferralFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral findFirst
   */
  export type ReferralFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral findFirstOrThrow
   */
  export type ReferralFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral findMany
   */
  export type ReferralFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referrals to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral create
   */
  export type ReferralCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The data needed to create a Referral.
     */
    data: XOR<ReferralCreateInput, ReferralUncheckedCreateInput>
  }

  /**
   * Referral createMany
   */
  export type ReferralCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Referrals.
     */
    data: ReferralCreateManyInput | ReferralCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Referral createManyAndReturn
   */
  export type ReferralCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * The data used to create many Referrals.
     */
    data: ReferralCreateManyInput | ReferralCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Referral update
   */
  export type ReferralUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The data needed to update a Referral.
     */
    data: XOR<ReferralUpdateInput, ReferralUncheckedUpdateInput>
    /**
     * Choose, which Referral to update.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral updateMany
   */
  export type ReferralUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Referrals.
     */
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyInput>
    /**
     * Filter which Referrals to update
     */
    where?: ReferralWhereInput
    /**
     * Limit how many Referrals to update.
     */
    limit?: number
  }

  /**
   * Referral updateManyAndReturn
   */
  export type ReferralUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * The data used to update Referrals.
     */
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyInput>
    /**
     * Filter which Referrals to update
     */
    where?: ReferralWhereInput
    /**
     * Limit how many Referrals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Referral upsert
   */
  export type ReferralUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The filter to search for the Referral to update in case it exists.
     */
    where: ReferralWhereUniqueInput
    /**
     * In case the Referral found by the `where` argument doesn't exist, create a new Referral with this data.
     */
    create: XOR<ReferralCreateInput, ReferralUncheckedCreateInput>
    /**
     * In case the Referral was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferralUpdateInput, ReferralUncheckedUpdateInput>
  }

  /**
   * Referral delete
   */
  export type ReferralDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter which Referral to delete.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral deleteMany
   */
  export type ReferralDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referrals to delete
     */
    where?: ReferralWhereInput
    /**
     * Limit how many Referrals to delete.
     */
    limit?: number
  }

  /**
   * Referral.referred
   */
  export type Referral$referredArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Referral without action
   */
  export type ReferralDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
  }


  /**
   * Model WrongSendRequest
   */

  export type AggregateWrongSendRequest = {
    _count: WrongSendRequestCountAggregateOutputType | null
    _avg: WrongSendRequestAvgAggregateOutputType | null
    _sum: WrongSendRequestSumAggregateOutputType | null
    _min: WrongSendRequestMinAggregateOutputType | null
    _max: WrongSendRequestMaxAggregateOutputType | null
  }

  export type WrongSendRequestAvgAggregateOutputType = {
    id: number | null
    txnId: number | null
    senderId: number | null
    amount: number | null
  }

  export type WrongSendRequestSumAggregateOutputType = {
    id: number | null
    txnId: number | null
    senderId: number | null
    amount: bigint | null
  }

  export type WrongSendRequestMinAggregateOutputType = {
    id: number | null
    txnId: number | null
    senderId: number | null
    receiverNumber: string | null
    amount: bigint | null
    status: $Enums.WrongSendStatus | null
    expiresAt: Date | null
    penaltyPaid: boolean | null
    razorpayRefundId: string | null
    createdAt: Date | null
  }

  export type WrongSendRequestMaxAggregateOutputType = {
    id: number | null
    txnId: number | null
    senderId: number | null
    receiverNumber: string | null
    amount: bigint | null
    status: $Enums.WrongSendStatus | null
    expiresAt: Date | null
    penaltyPaid: boolean | null
    razorpayRefundId: string | null
    createdAt: Date | null
  }

  export type WrongSendRequestCountAggregateOutputType = {
    id: number
    txnId: number
    senderId: number
    receiverNumber: number
    amount: number
    status: number
    expiresAt: number
    penaltyPaid: number
    razorpayRefundId: number
    createdAt: number
    _all: number
  }


  export type WrongSendRequestAvgAggregateInputType = {
    id?: true
    txnId?: true
    senderId?: true
    amount?: true
  }

  export type WrongSendRequestSumAggregateInputType = {
    id?: true
    txnId?: true
    senderId?: true
    amount?: true
  }

  export type WrongSendRequestMinAggregateInputType = {
    id?: true
    txnId?: true
    senderId?: true
    receiverNumber?: true
    amount?: true
    status?: true
    expiresAt?: true
    penaltyPaid?: true
    razorpayRefundId?: true
    createdAt?: true
  }

  export type WrongSendRequestMaxAggregateInputType = {
    id?: true
    txnId?: true
    senderId?: true
    receiverNumber?: true
    amount?: true
    status?: true
    expiresAt?: true
    penaltyPaid?: true
    razorpayRefundId?: true
    createdAt?: true
  }

  export type WrongSendRequestCountAggregateInputType = {
    id?: true
    txnId?: true
    senderId?: true
    receiverNumber?: true
    amount?: true
    status?: true
    expiresAt?: true
    penaltyPaid?: true
    razorpayRefundId?: true
    createdAt?: true
    _all?: true
  }

  export type WrongSendRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WrongSendRequest to aggregate.
     */
    where?: WrongSendRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WrongSendRequests to fetch.
     */
    orderBy?: WrongSendRequestOrderByWithRelationInput | WrongSendRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WrongSendRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WrongSendRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WrongSendRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WrongSendRequests
    **/
    _count?: true | WrongSendRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WrongSendRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WrongSendRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WrongSendRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WrongSendRequestMaxAggregateInputType
  }

  export type GetWrongSendRequestAggregateType<T extends WrongSendRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateWrongSendRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWrongSendRequest[P]>
      : GetScalarType<T[P], AggregateWrongSendRequest[P]>
  }




  export type WrongSendRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WrongSendRequestWhereInput
    orderBy?: WrongSendRequestOrderByWithAggregationInput | WrongSendRequestOrderByWithAggregationInput[]
    by: WrongSendRequestScalarFieldEnum[] | WrongSendRequestScalarFieldEnum
    having?: WrongSendRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WrongSendRequestCountAggregateInputType | true
    _avg?: WrongSendRequestAvgAggregateInputType
    _sum?: WrongSendRequestSumAggregateInputType
    _min?: WrongSendRequestMinAggregateInputType
    _max?: WrongSendRequestMaxAggregateInputType
  }

  export type WrongSendRequestGroupByOutputType = {
    id: number
    txnId: number
    senderId: number
    receiverNumber: string
    amount: bigint
    status: $Enums.WrongSendStatus
    expiresAt: Date
    penaltyPaid: boolean
    razorpayRefundId: string | null
    createdAt: Date
    _count: WrongSendRequestCountAggregateOutputType | null
    _avg: WrongSendRequestAvgAggregateOutputType | null
    _sum: WrongSendRequestSumAggregateOutputType | null
    _min: WrongSendRequestMinAggregateOutputType | null
    _max: WrongSendRequestMaxAggregateOutputType | null
  }

  type GetWrongSendRequestGroupByPayload<T extends WrongSendRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WrongSendRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WrongSendRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WrongSendRequestGroupByOutputType[P]>
            : GetScalarType<T[P], WrongSendRequestGroupByOutputType[P]>
        }
      >
    >


  export type WrongSendRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    txnId?: boolean
    senderId?: boolean
    receiverNumber?: boolean
    amount?: boolean
    status?: boolean
    expiresAt?: boolean
    penaltyPaid?: boolean
    razorpayRefundId?: boolean
    createdAt?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    transaction?: boolean | p2pTransferDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wrongSendRequest"]>

  export type WrongSendRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    txnId?: boolean
    senderId?: boolean
    receiverNumber?: boolean
    amount?: boolean
    status?: boolean
    expiresAt?: boolean
    penaltyPaid?: boolean
    razorpayRefundId?: boolean
    createdAt?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    transaction?: boolean | p2pTransferDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wrongSendRequest"]>

  export type WrongSendRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    txnId?: boolean
    senderId?: boolean
    receiverNumber?: boolean
    amount?: boolean
    status?: boolean
    expiresAt?: boolean
    penaltyPaid?: boolean
    razorpayRefundId?: boolean
    createdAt?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    transaction?: boolean | p2pTransferDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wrongSendRequest"]>

  export type WrongSendRequestSelectScalar = {
    id?: boolean
    txnId?: boolean
    senderId?: boolean
    receiverNumber?: boolean
    amount?: boolean
    status?: boolean
    expiresAt?: boolean
    penaltyPaid?: boolean
    razorpayRefundId?: boolean
    createdAt?: boolean
  }

  export type WrongSendRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "txnId" | "senderId" | "receiverNumber" | "amount" | "status" | "expiresAt" | "penaltyPaid" | "razorpayRefundId" | "createdAt", ExtArgs["result"]["wrongSendRequest"]>
  export type WrongSendRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    transaction?: boolean | p2pTransferDefaultArgs<ExtArgs>
  }
  export type WrongSendRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    transaction?: boolean | p2pTransferDefaultArgs<ExtArgs>
  }
  export type WrongSendRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    transaction?: boolean | p2pTransferDefaultArgs<ExtArgs>
  }

  export type $WrongSendRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WrongSendRequest"
    objects: {
      sender: Prisma.$UserPayload<ExtArgs>
      transaction: Prisma.$p2pTransferPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      txnId: number
      senderId: number
      receiverNumber: string
      amount: bigint
      status: $Enums.WrongSendStatus
      expiresAt: Date
      penaltyPaid: boolean
      razorpayRefundId: string | null
      createdAt: Date
    }, ExtArgs["result"]["wrongSendRequest"]>
    composites: {}
  }

  type WrongSendRequestGetPayload<S extends boolean | null | undefined | WrongSendRequestDefaultArgs> = $Result.GetResult<Prisma.$WrongSendRequestPayload, S>

  type WrongSendRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WrongSendRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WrongSendRequestCountAggregateInputType | true
    }

  export interface WrongSendRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WrongSendRequest'], meta: { name: 'WrongSendRequest' } }
    /**
     * Find zero or one WrongSendRequest that matches the filter.
     * @param {WrongSendRequestFindUniqueArgs} args - Arguments to find a WrongSendRequest
     * @example
     * // Get one WrongSendRequest
     * const wrongSendRequest = await prisma.wrongSendRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WrongSendRequestFindUniqueArgs>(args: SelectSubset<T, WrongSendRequestFindUniqueArgs<ExtArgs>>): Prisma__WrongSendRequestClient<$Result.GetResult<Prisma.$WrongSendRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WrongSendRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WrongSendRequestFindUniqueOrThrowArgs} args - Arguments to find a WrongSendRequest
     * @example
     * // Get one WrongSendRequest
     * const wrongSendRequest = await prisma.wrongSendRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WrongSendRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, WrongSendRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WrongSendRequestClient<$Result.GetResult<Prisma.$WrongSendRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WrongSendRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WrongSendRequestFindFirstArgs} args - Arguments to find a WrongSendRequest
     * @example
     * // Get one WrongSendRequest
     * const wrongSendRequest = await prisma.wrongSendRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WrongSendRequestFindFirstArgs>(args?: SelectSubset<T, WrongSendRequestFindFirstArgs<ExtArgs>>): Prisma__WrongSendRequestClient<$Result.GetResult<Prisma.$WrongSendRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WrongSendRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WrongSendRequestFindFirstOrThrowArgs} args - Arguments to find a WrongSendRequest
     * @example
     * // Get one WrongSendRequest
     * const wrongSendRequest = await prisma.wrongSendRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WrongSendRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, WrongSendRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__WrongSendRequestClient<$Result.GetResult<Prisma.$WrongSendRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WrongSendRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WrongSendRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WrongSendRequests
     * const wrongSendRequests = await prisma.wrongSendRequest.findMany()
     * 
     * // Get first 10 WrongSendRequests
     * const wrongSendRequests = await prisma.wrongSendRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wrongSendRequestWithIdOnly = await prisma.wrongSendRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WrongSendRequestFindManyArgs>(args?: SelectSubset<T, WrongSendRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WrongSendRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WrongSendRequest.
     * @param {WrongSendRequestCreateArgs} args - Arguments to create a WrongSendRequest.
     * @example
     * // Create one WrongSendRequest
     * const WrongSendRequest = await prisma.wrongSendRequest.create({
     *   data: {
     *     // ... data to create a WrongSendRequest
     *   }
     * })
     * 
     */
    create<T extends WrongSendRequestCreateArgs>(args: SelectSubset<T, WrongSendRequestCreateArgs<ExtArgs>>): Prisma__WrongSendRequestClient<$Result.GetResult<Prisma.$WrongSendRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WrongSendRequests.
     * @param {WrongSendRequestCreateManyArgs} args - Arguments to create many WrongSendRequests.
     * @example
     * // Create many WrongSendRequests
     * const wrongSendRequest = await prisma.wrongSendRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WrongSendRequestCreateManyArgs>(args?: SelectSubset<T, WrongSendRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WrongSendRequests and returns the data saved in the database.
     * @param {WrongSendRequestCreateManyAndReturnArgs} args - Arguments to create many WrongSendRequests.
     * @example
     * // Create many WrongSendRequests
     * const wrongSendRequest = await prisma.wrongSendRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WrongSendRequests and only return the `id`
     * const wrongSendRequestWithIdOnly = await prisma.wrongSendRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WrongSendRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, WrongSendRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WrongSendRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WrongSendRequest.
     * @param {WrongSendRequestDeleteArgs} args - Arguments to delete one WrongSendRequest.
     * @example
     * // Delete one WrongSendRequest
     * const WrongSendRequest = await prisma.wrongSendRequest.delete({
     *   where: {
     *     // ... filter to delete one WrongSendRequest
     *   }
     * })
     * 
     */
    delete<T extends WrongSendRequestDeleteArgs>(args: SelectSubset<T, WrongSendRequestDeleteArgs<ExtArgs>>): Prisma__WrongSendRequestClient<$Result.GetResult<Prisma.$WrongSendRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WrongSendRequest.
     * @param {WrongSendRequestUpdateArgs} args - Arguments to update one WrongSendRequest.
     * @example
     * // Update one WrongSendRequest
     * const wrongSendRequest = await prisma.wrongSendRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WrongSendRequestUpdateArgs>(args: SelectSubset<T, WrongSendRequestUpdateArgs<ExtArgs>>): Prisma__WrongSendRequestClient<$Result.GetResult<Prisma.$WrongSendRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WrongSendRequests.
     * @param {WrongSendRequestDeleteManyArgs} args - Arguments to filter WrongSendRequests to delete.
     * @example
     * // Delete a few WrongSendRequests
     * const { count } = await prisma.wrongSendRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WrongSendRequestDeleteManyArgs>(args?: SelectSubset<T, WrongSendRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WrongSendRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WrongSendRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WrongSendRequests
     * const wrongSendRequest = await prisma.wrongSendRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WrongSendRequestUpdateManyArgs>(args: SelectSubset<T, WrongSendRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WrongSendRequests and returns the data updated in the database.
     * @param {WrongSendRequestUpdateManyAndReturnArgs} args - Arguments to update many WrongSendRequests.
     * @example
     * // Update many WrongSendRequests
     * const wrongSendRequest = await prisma.wrongSendRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WrongSendRequests and only return the `id`
     * const wrongSendRequestWithIdOnly = await prisma.wrongSendRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WrongSendRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, WrongSendRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WrongSendRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WrongSendRequest.
     * @param {WrongSendRequestUpsertArgs} args - Arguments to update or create a WrongSendRequest.
     * @example
     * // Update or create a WrongSendRequest
     * const wrongSendRequest = await prisma.wrongSendRequest.upsert({
     *   create: {
     *     // ... data to create a WrongSendRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WrongSendRequest we want to update
     *   }
     * })
     */
    upsert<T extends WrongSendRequestUpsertArgs>(args: SelectSubset<T, WrongSendRequestUpsertArgs<ExtArgs>>): Prisma__WrongSendRequestClient<$Result.GetResult<Prisma.$WrongSendRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WrongSendRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WrongSendRequestCountArgs} args - Arguments to filter WrongSendRequests to count.
     * @example
     * // Count the number of WrongSendRequests
     * const count = await prisma.wrongSendRequest.count({
     *   where: {
     *     // ... the filter for the WrongSendRequests we want to count
     *   }
     * })
    **/
    count<T extends WrongSendRequestCountArgs>(
      args?: Subset<T, WrongSendRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WrongSendRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WrongSendRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WrongSendRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WrongSendRequestAggregateArgs>(args: Subset<T, WrongSendRequestAggregateArgs>): Prisma.PrismaPromise<GetWrongSendRequestAggregateType<T>>

    /**
     * Group by WrongSendRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WrongSendRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WrongSendRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WrongSendRequestGroupByArgs['orderBy'] }
        : { orderBy?: WrongSendRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WrongSendRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWrongSendRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WrongSendRequest model
   */
  readonly fields: WrongSendRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WrongSendRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WrongSendRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transaction<T extends p2pTransferDefaultArgs<ExtArgs> = {}>(args?: Subset<T, p2pTransferDefaultArgs<ExtArgs>>): Prisma__p2pTransferClient<$Result.GetResult<Prisma.$p2pTransferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WrongSendRequest model
   */
  interface WrongSendRequestFieldRefs {
    readonly id: FieldRef<"WrongSendRequest", 'Int'>
    readonly txnId: FieldRef<"WrongSendRequest", 'Int'>
    readonly senderId: FieldRef<"WrongSendRequest", 'Int'>
    readonly receiverNumber: FieldRef<"WrongSendRequest", 'String'>
    readonly amount: FieldRef<"WrongSendRequest", 'BigInt'>
    readonly status: FieldRef<"WrongSendRequest", 'WrongSendStatus'>
    readonly expiresAt: FieldRef<"WrongSendRequest", 'DateTime'>
    readonly penaltyPaid: FieldRef<"WrongSendRequest", 'Boolean'>
    readonly razorpayRefundId: FieldRef<"WrongSendRequest", 'String'>
    readonly createdAt: FieldRef<"WrongSendRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WrongSendRequest findUnique
   */
  export type WrongSendRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WrongSendRequest
     */
    select?: WrongSendRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WrongSendRequest
     */
    omit?: WrongSendRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WrongSendRequestInclude<ExtArgs> | null
    /**
     * Filter, which WrongSendRequest to fetch.
     */
    where: WrongSendRequestWhereUniqueInput
  }

  /**
   * WrongSendRequest findUniqueOrThrow
   */
  export type WrongSendRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WrongSendRequest
     */
    select?: WrongSendRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WrongSendRequest
     */
    omit?: WrongSendRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WrongSendRequestInclude<ExtArgs> | null
    /**
     * Filter, which WrongSendRequest to fetch.
     */
    where: WrongSendRequestWhereUniqueInput
  }

  /**
   * WrongSendRequest findFirst
   */
  export type WrongSendRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WrongSendRequest
     */
    select?: WrongSendRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WrongSendRequest
     */
    omit?: WrongSendRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WrongSendRequestInclude<ExtArgs> | null
    /**
     * Filter, which WrongSendRequest to fetch.
     */
    where?: WrongSendRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WrongSendRequests to fetch.
     */
    orderBy?: WrongSendRequestOrderByWithRelationInput | WrongSendRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WrongSendRequests.
     */
    cursor?: WrongSendRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WrongSendRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WrongSendRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WrongSendRequests.
     */
    distinct?: WrongSendRequestScalarFieldEnum | WrongSendRequestScalarFieldEnum[]
  }

  /**
   * WrongSendRequest findFirstOrThrow
   */
  export type WrongSendRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WrongSendRequest
     */
    select?: WrongSendRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WrongSendRequest
     */
    omit?: WrongSendRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WrongSendRequestInclude<ExtArgs> | null
    /**
     * Filter, which WrongSendRequest to fetch.
     */
    where?: WrongSendRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WrongSendRequests to fetch.
     */
    orderBy?: WrongSendRequestOrderByWithRelationInput | WrongSendRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WrongSendRequests.
     */
    cursor?: WrongSendRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WrongSendRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WrongSendRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WrongSendRequests.
     */
    distinct?: WrongSendRequestScalarFieldEnum | WrongSendRequestScalarFieldEnum[]
  }

  /**
   * WrongSendRequest findMany
   */
  export type WrongSendRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WrongSendRequest
     */
    select?: WrongSendRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WrongSendRequest
     */
    omit?: WrongSendRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WrongSendRequestInclude<ExtArgs> | null
    /**
     * Filter, which WrongSendRequests to fetch.
     */
    where?: WrongSendRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WrongSendRequests to fetch.
     */
    orderBy?: WrongSendRequestOrderByWithRelationInput | WrongSendRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WrongSendRequests.
     */
    cursor?: WrongSendRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WrongSendRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WrongSendRequests.
     */
    skip?: number
    distinct?: WrongSendRequestScalarFieldEnum | WrongSendRequestScalarFieldEnum[]
  }

  /**
   * WrongSendRequest create
   */
  export type WrongSendRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WrongSendRequest
     */
    select?: WrongSendRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WrongSendRequest
     */
    omit?: WrongSendRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WrongSendRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a WrongSendRequest.
     */
    data: XOR<WrongSendRequestCreateInput, WrongSendRequestUncheckedCreateInput>
  }

  /**
   * WrongSendRequest createMany
   */
  export type WrongSendRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WrongSendRequests.
     */
    data: WrongSendRequestCreateManyInput | WrongSendRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WrongSendRequest createManyAndReturn
   */
  export type WrongSendRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WrongSendRequest
     */
    select?: WrongSendRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WrongSendRequest
     */
    omit?: WrongSendRequestOmit<ExtArgs> | null
    /**
     * The data used to create many WrongSendRequests.
     */
    data: WrongSendRequestCreateManyInput | WrongSendRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WrongSendRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WrongSendRequest update
   */
  export type WrongSendRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WrongSendRequest
     */
    select?: WrongSendRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WrongSendRequest
     */
    omit?: WrongSendRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WrongSendRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a WrongSendRequest.
     */
    data: XOR<WrongSendRequestUpdateInput, WrongSendRequestUncheckedUpdateInput>
    /**
     * Choose, which WrongSendRequest to update.
     */
    where: WrongSendRequestWhereUniqueInput
  }

  /**
   * WrongSendRequest updateMany
   */
  export type WrongSendRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WrongSendRequests.
     */
    data: XOR<WrongSendRequestUpdateManyMutationInput, WrongSendRequestUncheckedUpdateManyInput>
    /**
     * Filter which WrongSendRequests to update
     */
    where?: WrongSendRequestWhereInput
    /**
     * Limit how many WrongSendRequests to update.
     */
    limit?: number
  }

  /**
   * WrongSendRequest updateManyAndReturn
   */
  export type WrongSendRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WrongSendRequest
     */
    select?: WrongSendRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WrongSendRequest
     */
    omit?: WrongSendRequestOmit<ExtArgs> | null
    /**
     * The data used to update WrongSendRequests.
     */
    data: XOR<WrongSendRequestUpdateManyMutationInput, WrongSendRequestUncheckedUpdateManyInput>
    /**
     * Filter which WrongSendRequests to update
     */
    where?: WrongSendRequestWhereInput
    /**
     * Limit how many WrongSendRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WrongSendRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WrongSendRequest upsert
   */
  export type WrongSendRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WrongSendRequest
     */
    select?: WrongSendRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WrongSendRequest
     */
    omit?: WrongSendRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WrongSendRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the WrongSendRequest to update in case it exists.
     */
    where: WrongSendRequestWhereUniqueInput
    /**
     * In case the WrongSendRequest found by the `where` argument doesn't exist, create a new WrongSendRequest with this data.
     */
    create: XOR<WrongSendRequestCreateInput, WrongSendRequestUncheckedCreateInput>
    /**
     * In case the WrongSendRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WrongSendRequestUpdateInput, WrongSendRequestUncheckedUpdateInput>
  }

  /**
   * WrongSendRequest delete
   */
  export type WrongSendRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WrongSendRequest
     */
    select?: WrongSendRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WrongSendRequest
     */
    omit?: WrongSendRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WrongSendRequestInclude<ExtArgs> | null
    /**
     * Filter which WrongSendRequest to delete.
     */
    where: WrongSendRequestWhereUniqueInput
  }

  /**
   * WrongSendRequest deleteMany
   */
  export type WrongSendRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WrongSendRequests to delete
     */
    where?: WrongSendRequestWhereInput
    /**
     * Limit how many WrongSendRequests to delete.
     */
    limit?: number
  }

  /**
   * WrongSendRequest without action
   */
  export type WrongSendRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WrongSendRequest
     */
    select?: WrongSendRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WrongSendRequest
     */
    omit?: WrongSendRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WrongSendRequestInclude<ExtArgs> | null
  }


  /**
   * Model BillSplitGroup
   */

  export type AggregateBillSplitGroup = {
    _count: BillSplitGroupCountAggregateOutputType | null
    _avg: BillSplitGroupAvgAggregateOutputType | null
    _sum: BillSplitGroupSumAggregateOutputType | null
    _min: BillSplitGroupMinAggregateOutputType | null
    _max: BillSplitGroupMaxAggregateOutputType | null
  }

  export type BillSplitGroupAvgAggregateOutputType = {
    id: number | null
    totalAmount: number | null
    createdById: number | null
  }

  export type BillSplitGroupSumAggregateOutputType = {
    id: number | null
    totalAmount: number | null
    createdById: number | null
  }

  export type BillSplitGroupMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    totalAmount: number | null
    currency: string | null
    createdById: number | null
    createdAt: Date | null
    settledAt: Date | null
    status: string | null
  }

  export type BillSplitGroupMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    totalAmount: number | null
    currency: string | null
    createdById: number | null
    createdAt: Date | null
    settledAt: Date | null
    status: string | null
  }

  export type BillSplitGroupCountAggregateOutputType = {
    id: number
    name: number
    description: number
    totalAmount: number
    currency: number
    createdById: number
    createdAt: number
    settledAt: number
    status: number
    _all: number
  }


  export type BillSplitGroupAvgAggregateInputType = {
    id?: true
    totalAmount?: true
    createdById?: true
  }

  export type BillSplitGroupSumAggregateInputType = {
    id?: true
    totalAmount?: true
    createdById?: true
  }

  export type BillSplitGroupMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    totalAmount?: true
    currency?: true
    createdById?: true
    createdAt?: true
    settledAt?: true
    status?: true
  }

  export type BillSplitGroupMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    totalAmount?: true
    currency?: true
    createdById?: true
    createdAt?: true
    settledAt?: true
    status?: true
  }

  export type BillSplitGroupCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    totalAmount?: true
    currency?: true
    createdById?: true
    createdAt?: true
    settledAt?: true
    status?: true
    _all?: true
  }

  export type BillSplitGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillSplitGroup to aggregate.
     */
    where?: BillSplitGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillSplitGroups to fetch.
     */
    orderBy?: BillSplitGroupOrderByWithRelationInput | BillSplitGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillSplitGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillSplitGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillSplitGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BillSplitGroups
    **/
    _count?: true | BillSplitGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillSplitGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillSplitGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillSplitGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillSplitGroupMaxAggregateInputType
  }

  export type GetBillSplitGroupAggregateType<T extends BillSplitGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateBillSplitGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBillSplitGroup[P]>
      : GetScalarType<T[P], AggregateBillSplitGroup[P]>
  }




  export type BillSplitGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillSplitGroupWhereInput
    orderBy?: BillSplitGroupOrderByWithAggregationInput | BillSplitGroupOrderByWithAggregationInput[]
    by: BillSplitGroupScalarFieldEnum[] | BillSplitGroupScalarFieldEnum
    having?: BillSplitGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillSplitGroupCountAggregateInputType | true
    _avg?: BillSplitGroupAvgAggregateInputType
    _sum?: BillSplitGroupSumAggregateInputType
    _min?: BillSplitGroupMinAggregateInputType
    _max?: BillSplitGroupMaxAggregateInputType
  }

  export type BillSplitGroupGroupByOutputType = {
    id: number
    name: string
    description: string | null
    totalAmount: number
    currency: string
    createdById: number
    createdAt: Date
    settledAt: Date | null
    status: string
    _count: BillSplitGroupCountAggregateOutputType | null
    _avg: BillSplitGroupAvgAggregateOutputType | null
    _sum: BillSplitGroupSumAggregateOutputType | null
    _min: BillSplitGroupMinAggregateOutputType | null
    _max: BillSplitGroupMaxAggregateOutputType | null
  }

  type GetBillSplitGroupGroupByPayload<T extends BillSplitGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillSplitGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillSplitGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillSplitGroupGroupByOutputType[P]>
            : GetScalarType<T[P], BillSplitGroupGroupByOutputType[P]>
        }
      >
    >


  export type BillSplitGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    totalAmount?: boolean
    currency?: boolean
    createdById?: boolean
    createdAt?: boolean
    settledAt?: boolean
    status?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | BillSplitGroup$membersArgs<ExtArgs>
    payments?: boolean | BillSplitGroup$paymentsArgs<ExtArgs>
    rewards?: boolean | BillSplitGroup$rewardsArgs<ExtArgs>
    _count?: boolean | BillSplitGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billSplitGroup"]>

  export type BillSplitGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    totalAmount?: boolean
    currency?: boolean
    createdById?: boolean
    createdAt?: boolean
    settledAt?: boolean
    status?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billSplitGroup"]>

  export type BillSplitGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    totalAmount?: boolean
    currency?: boolean
    createdById?: boolean
    createdAt?: boolean
    settledAt?: boolean
    status?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billSplitGroup"]>

  export type BillSplitGroupSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    totalAmount?: boolean
    currency?: boolean
    createdById?: boolean
    createdAt?: boolean
    settledAt?: boolean
    status?: boolean
  }

  export type BillSplitGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "totalAmount" | "currency" | "createdById" | "createdAt" | "settledAt" | "status", ExtArgs["result"]["billSplitGroup"]>
  export type BillSplitGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | BillSplitGroup$membersArgs<ExtArgs>
    payments?: boolean | BillSplitGroup$paymentsArgs<ExtArgs>
    rewards?: boolean | BillSplitGroup$rewardsArgs<ExtArgs>
    _count?: boolean | BillSplitGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BillSplitGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BillSplitGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BillSplitGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BillSplitGroup"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      members: Prisma.$BillSplitMemberPayload<ExtArgs>[]
      payments: Prisma.$BillSplitPaymentPayload<ExtArgs>[]
      rewards: Prisma.$RewardPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      totalAmount: number
      currency: string
      createdById: number
      createdAt: Date
      settledAt: Date | null
      status: string
    }, ExtArgs["result"]["billSplitGroup"]>
    composites: {}
  }

  type BillSplitGroupGetPayload<S extends boolean | null | undefined | BillSplitGroupDefaultArgs> = $Result.GetResult<Prisma.$BillSplitGroupPayload, S>

  type BillSplitGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BillSplitGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BillSplitGroupCountAggregateInputType | true
    }

  export interface BillSplitGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BillSplitGroup'], meta: { name: 'BillSplitGroup' } }
    /**
     * Find zero or one BillSplitGroup that matches the filter.
     * @param {BillSplitGroupFindUniqueArgs} args - Arguments to find a BillSplitGroup
     * @example
     * // Get one BillSplitGroup
     * const billSplitGroup = await prisma.billSplitGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillSplitGroupFindUniqueArgs>(args: SelectSubset<T, BillSplitGroupFindUniqueArgs<ExtArgs>>): Prisma__BillSplitGroupClient<$Result.GetResult<Prisma.$BillSplitGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BillSplitGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BillSplitGroupFindUniqueOrThrowArgs} args - Arguments to find a BillSplitGroup
     * @example
     * // Get one BillSplitGroup
     * const billSplitGroup = await prisma.billSplitGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillSplitGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, BillSplitGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillSplitGroupClient<$Result.GetResult<Prisma.$BillSplitGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillSplitGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillSplitGroupFindFirstArgs} args - Arguments to find a BillSplitGroup
     * @example
     * // Get one BillSplitGroup
     * const billSplitGroup = await prisma.billSplitGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillSplitGroupFindFirstArgs>(args?: SelectSubset<T, BillSplitGroupFindFirstArgs<ExtArgs>>): Prisma__BillSplitGroupClient<$Result.GetResult<Prisma.$BillSplitGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillSplitGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillSplitGroupFindFirstOrThrowArgs} args - Arguments to find a BillSplitGroup
     * @example
     * // Get one BillSplitGroup
     * const billSplitGroup = await prisma.billSplitGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillSplitGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, BillSplitGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillSplitGroupClient<$Result.GetResult<Prisma.$BillSplitGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BillSplitGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillSplitGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BillSplitGroups
     * const billSplitGroups = await prisma.billSplitGroup.findMany()
     * 
     * // Get first 10 BillSplitGroups
     * const billSplitGroups = await prisma.billSplitGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billSplitGroupWithIdOnly = await prisma.billSplitGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillSplitGroupFindManyArgs>(args?: SelectSubset<T, BillSplitGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillSplitGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BillSplitGroup.
     * @param {BillSplitGroupCreateArgs} args - Arguments to create a BillSplitGroup.
     * @example
     * // Create one BillSplitGroup
     * const BillSplitGroup = await prisma.billSplitGroup.create({
     *   data: {
     *     // ... data to create a BillSplitGroup
     *   }
     * })
     * 
     */
    create<T extends BillSplitGroupCreateArgs>(args: SelectSubset<T, BillSplitGroupCreateArgs<ExtArgs>>): Prisma__BillSplitGroupClient<$Result.GetResult<Prisma.$BillSplitGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BillSplitGroups.
     * @param {BillSplitGroupCreateManyArgs} args - Arguments to create many BillSplitGroups.
     * @example
     * // Create many BillSplitGroups
     * const billSplitGroup = await prisma.billSplitGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillSplitGroupCreateManyArgs>(args?: SelectSubset<T, BillSplitGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BillSplitGroups and returns the data saved in the database.
     * @param {BillSplitGroupCreateManyAndReturnArgs} args - Arguments to create many BillSplitGroups.
     * @example
     * // Create many BillSplitGroups
     * const billSplitGroup = await prisma.billSplitGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BillSplitGroups and only return the `id`
     * const billSplitGroupWithIdOnly = await prisma.billSplitGroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BillSplitGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, BillSplitGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillSplitGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BillSplitGroup.
     * @param {BillSplitGroupDeleteArgs} args - Arguments to delete one BillSplitGroup.
     * @example
     * // Delete one BillSplitGroup
     * const BillSplitGroup = await prisma.billSplitGroup.delete({
     *   where: {
     *     // ... filter to delete one BillSplitGroup
     *   }
     * })
     * 
     */
    delete<T extends BillSplitGroupDeleteArgs>(args: SelectSubset<T, BillSplitGroupDeleteArgs<ExtArgs>>): Prisma__BillSplitGroupClient<$Result.GetResult<Prisma.$BillSplitGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BillSplitGroup.
     * @param {BillSplitGroupUpdateArgs} args - Arguments to update one BillSplitGroup.
     * @example
     * // Update one BillSplitGroup
     * const billSplitGroup = await prisma.billSplitGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillSplitGroupUpdateArgs>(args: SelectSubset<T, BillSplitGroupUpdateArgs<ExtArgs>>): Prisma__BillSplitGroupClient<$Result.GetResult<Prisma.$BillSplitGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BillSplitGroups.
     * @param {BillSplitGroupDeleteManyArgs} args - Arguments to filter BillSplitGroups to delete.
     * @example
     * // Delete a few BillSplitGroups
     * const { count } = await prisma.billSplitGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillSplitGroupDeleteManyArgs>(args?: SelectSubset<T, BillSplitGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillSplitGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillSplitGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BillSplitGroups
     * const billSplitGroup = await prisma.billSplitGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillSplitGroupUpdateManyArgs>(args: SelectSubset<T, BillSplitGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillSplitGroups and returns the data updated in the database.
     * @param {BillSplitGroupUpdateManyAndReturnArgs} args - Arguments to update many BillSplitGroups.
     * @example
     * // Update many BillSplitGroups
     * const billSplitGroup = await prisma.billSplitGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BillSplitGroups and only return the `id`
     * const billSplitGroupWithIdOnly = await prisma.billSplitGroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BillSplitGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, BillSplitGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillSplitGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BillSplitGroup.
     * @param {BillSplitGroupUpsertArgs} args - Arguments to update or create a BillSplitGroup.
     * @example
     * // Update or create a BillSplitGroup
     * const billSplitGroup = await prisma.billSplitGroup.upsert({
     *   create: {
     *     // ... data to create a BillSplitGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BillSplitGroup we want to update
     *   }
     * })
     */
    upsert<T extends BillSplitGroupUpsertArgs>(args: SelectSubset<T, BillSplitGroupUpsertArgs<ExtArgs>>): Prisma__BillSplitGroupClient<$Result.GetResult<Prisma.$BillSplitGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BillSplitGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillSplitGroupCountArgs} args - Arguments to filter BillSplitGroups to count.
     * @example
     * // Count the number of BillSplitGroups
     * const count = await prisma.billSplitGroup.count({
     *   where: {
     *     // ... the filter for the BillSplitGroups we want to count
     *   }
     * })
    **/
    count<T extends BillSplitGroupCountArgs>(
      args?: Subset<T, BillSplitGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillSplitGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BillSplitGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillSplitGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillSplitGroupAggregateArgs>(args: Subset<T, BillSplitGroupAggregateArgs>): Prisma.PrismaPromise<GetBillSplitGroupAggregateType<T>>

    /**
     * Group by BillSplitGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillSplitGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillSplitGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillSplitGroupGroupByArgs['orderBy'] }
        : { orderBy?: BillSplitGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillSplitGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillSplitGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BillSplitGroup model
   */
  readonly fields: BillSplitGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BillSplitGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillSplitGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    members<T extends BillSplitGroup$membersArgs<ExtArgs> = {}>(args?: Subset<T, BillSplitGroup$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillSplitMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends BillSplitGroup$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, BillSplitGroup$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillSplitPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rewards<T extends BillSplitGroup$rewardsArgs<ExtArgs> = {}>(args?: Subset<T, BillSplitGroup$rewardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BillSplitGroup model
   */
  interface BillSplitGroupFieldRefs {
    readonly id: FieldRef<"BillSplitGroup", 'Int'>
    readonly name: FieldRef<"BillSplitGroup", 'String'>
    readonly description: FieldRef<"BillSplitGroup", 'String'>
    readonly totalAmount: FieldRef<"BillSplitGroup", 'Int'>
    readonly currency: FieldRef<"BillSplitGroup", 'String'>
    readonly createdById: FieldRef<"BillSplitGroup", 'Int'>
    readonly createdAt: FieldRef<"BillSplitGroup", 'DateTime'>
    readonly settledAt: FieldRef<"BillSplitGroup", 'DateTime'>
    readonly status: FieldRef<"BillSplitGroup", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BillSplitGroup findUnique
   */
  export type BillSplitGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitGroup
     */
    select?: BillSplitGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitGroup
     */
    omit?: BillSplitGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitGroupInclude<ExtArgs> | null
    /**
     * Filter, which BillSplitGroup to fetch.
     */
    where: BillSplitGroupWhereUniqueInput
  }

  /**
   * BillSplitGroup findUniqueOrThrow
   */
  export type BillSplitGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitGroup
     */
    select?: BillSplitGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitGroup
     */
    omit?: BillSplitGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitGroupInclude<ExtArgs> | null
    /**
     * Filter, which BillSplitGroup to fetch.
     */
    where: BillSplitGroupWhereUniqueInput
  }

  /**
   * BillSplitGroup findFirst
   */
  export type BillSplitGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitGroup
     */
    select?: BillSplitGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitGroup
     */
    omit?: BillSplitGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitGroupInclude<ExtArgs> | null
    /**
     * Filter, which BillSplitGroup to fetch.
     */
    where?: BillSplitGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillSplitGroups to fetch.
     */
    orderBy?: BillSplitGroupOrderByWithRelationInput | BillSplitGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillSplitGroups.
     */
    cursor?: BillSplitGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillSplitGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillSplitGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillSplitGroups.
     */
    distinct?: BillSplitGroupScalarFieldEnum | BillSplitGroupScalarFieldEnum[]
  }

  /**
   * BillSplitGroup findFirstOrThrow
   */
  export type BillSplitGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitGroup
     */
    select?: BillSplitGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitGroup
     */
    omit?: BillSplitGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitGroupInclude<ExtArgs> | null
    /**
     * Filter, which BillSplitGroup to fetch.
     */
    where?: BillSplitGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillSplitGroups to fetch.
     */
    orderBy?: BillSplitGroupOrderByWithRelationInput | BillSplitGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillSplitGroups.
     */
    cursor?: BillSplitGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillSplitGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillSplitGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillSplitGroups.
     */
    distinct?: BillSplitGroupScalarFieldEnum | BillSplitGroupScalarFieldEnum[]
  }

  /**
   * BillSplitGroup findMany
   */
  export type BillSplitGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitGroup
     */
    select?: BillSplitGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitGroup
     */
    omit?: BillSplitGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitGroupInclude<ExtArgs> | null
    /**
     * Filter, which BillSplitGroups to fetch.
     */
    where?: BillSplitGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillSplitGroups to fetch.
     */
    orderBy?: BillSplitGroupOrderByWithRelationInput | BillSplitGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BillSplitGroups.
     */
    cursor?: BillSplitGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillSplitGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillSplitGroups.
     */
    skip?: number
    distinct?: BillSplitGroupScalarFieldEnum | BillSplitGroupScalarFieldEnum[]
  }

  /**
   * BillSplitGroup create
   */
  export type BillSplitGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitGroup
     */
    select?: BillSplitGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitGroup
     */
    omit?: BillSplitGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a BillSplitGroup.
     */
    data: XOR<BillSplitGroupCreateInput, BillSplitGroupUncheckedCreateInput>
  }

  /**
   * BillSplitGroup createMany
   */
  export type BillSplitGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BillSplitGroups.
     */
    data: BillSplitGroupCreateManyInput | BillSplitGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BillSplitGroup createManyAndReturn
   */
  export type BillSplitGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitGroup
     */
    select?: BillSplitGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitGroup
     */
    omit?: BillSplitGroupOmit<ExtArgs> | null
    /**
     * The data used to create many BillSplitGroups.
     */
    data: BillSplitGroupCreateManyInput | BillSplitGroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitGroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillSplitGroup update
   */
  export type BillSplitGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitGroup
     */
    select?: BillSplitGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitGroup
     */
    omit?: BillSplitGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a BillSplitGroup.
     */
    data: XOR<BillSplitGroupUpdateInput, BillSplitGroupUncheckedUpdateInput>
    /**
     * Choose, which BillSplitGroup to update.
     */
    where: BillSplitGroupWhereUniqueInput
  }

  /**
   * BillSplitGroup updateMany
   */
  export type BillSplitGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BillSplitGroups.
     */
    data: XOR<BillSplitGroupUpdateManyMutationInput, BillSplitGroupUncheckedUpdateManyInput>
    /**
     * Filter which BillSplitGroups to update
     */
    where?: BillSplitGroupWhereInput
    /**
     * Limit how many BillSplitGroups to update.
     */
    limit?: number
  }

  /**
   * BillSplitGroup updateManyAndReturn
   */
  export type BillSplitGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitGroup
     */
    select?: BillSplitGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitGroup
     */
    omit?: BillSplitGroupOmit<ExtArgs> | null
    /**
     * The data used to update BillSplitGroups.
     */
    data: XOR<BillSplitGroupUpdateManyMutationInput, BillSplitGroupUncheckedUpdateManyInput>
    /**
     * Filter which BillSplitGroups to update
     */
    where?: BillSplitGroupWhereInput
    /**
     * Limit how many BillSplitGroups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitGroupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillSplitGroup upsert
   */
  export type BillSplitGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitGroup
     */
    select?: BillSplitGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitGroup
     */
    omit?: BillSplitGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the BillSplitGroup to update in case it exists.
     */
    where: BillSplitGroupWhereUniqueInput
    /**
     * In case the BillSplitGroup found by the `where` argument doesn't exist, create a new BillSplitGroup with this data.
     */
    create: XOR<BillSplitGroupCreateInput, BillSplitGroupUncheckedCreateInput>
    /**
     * In case the BillSplitGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillSplitGroupUpdateInput, BillSplitGroupUncheckedUpdateInput>
  }

  /**
   * BillSplitGroup delete
   */
  export type BillSplitGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitGroup
     */
    select?: BillSplitGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitGroup
     */
    omit?: BillSplitGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitGroupInclude<ExtArgs> | null
    /**
     * Filter which BillSplitGroup to delete.
     */
    where: BillSplitGroupWhereUniqueInput
  }

  /**
   * BillSplitGroup deleteMany
   */
  export type BillSplitGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillSplitGroups to delete
     */
    where?: BillSplitGroupWhereInput
    /**
     * Limit how many BillSplitGroups to delete.
     */
    limit?: number
  }

  /**
   * BillSplitGroup.members
   */
  export type BillSplitGroup$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitMember
     */
    select?: BillSplitMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitMember
     */
    omit?: BillSplitMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitMemberInclude<ExtArgs> | null
    where?: BillSplitMemberWhereInput
    orderBy?: BillSplitMemberOrderByWithRelationInput | BillSplitMemberOrderByWithRelationInput[]
    cursor?: BillSplitMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillSplitMemberScalarFieldEnum | BillSplitMemberScalarFieldEnum[]
  }

  /**
   * BillSplitGroup.payments
   */
  export type BillSplitGroup$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitPayment
     */
    select?: BillSplitPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitPayment
     */
    omit?: BillSplitPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitPaymentInclude<ExtArgs> | null
    where?: BillSplitPaymentWhereInput
    orderBy?: BillSplitPaymentOrderByWithRelationInput | BillSplitPaymentOrderByWithRelationInput[]
    cursor?: BillSplitPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillSplitPaymentScalarFieldEnum | BillSplitPaymentScalarFieldEnum[]
  }

  /**
   * BillSplitGroup.rewards
   */
  export type BillSplitGroup$rewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    where?: RewardWhereInput
    orderBy?: RewardOrderByWithRelationInput | RewardOrderByWithRelationInput[]
    cursor?: RewardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RewardScalarFieldEnum | RewardScalarFieldEnum[]
  }

  /**
   * BillSplitGroup without action
   */
  export type BillSplitGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitGroup
     */
    select?: BillSplitGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitGroup
     */
    omit?: BillSplitGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitGroupInclude<ExtArgs> | null
  }


  /**
   * Model BillSplitMember
   */

  export type AggregateBillSplitMember = {
    _count: BillSplitMemberCountAggregateOutputType | null
    _avg: BillSplitMemberAvgAggregateOutputType | null
    _sum: BillSplitMemberSumAggregateOutputType | null
    _min: BillSplitMemberMinAggregateOutputType | null
    _max: BillSplitMemberMaxAggregateOutputType | null
  }

  export type BillSplitMemberAvgAggregateOutputType = {
    id: number | null
    groupId: number | null
    userId: number | null
    share: number | null
    paidAmount: number | null
  }

  export type BillSplitMemberSumAggregateOutputType = {
    id: number | null
    groupId: number | null
    userId: number | null
    share: number | null
    paidAmount: number | null
  }

  export type BillSplitMemberMinAggregateOutputType = {
    id: number | null
    groupId: number | null
    userId: number | null
    phone: string | null
    name: string | null
    share: number | null
    paid: boolean | null
    paidAt: Date | null
    paidAmount: number | null
  }

  export type BillSplitMemberMaxAggregateOutputType = {
    id: number | null
    groupId: number | null
    userId: number | null
    phone: string | null
    name: string | null
    share: number | null
    paid: boolean | null
    paidAt: Date | null
    paidAmount: number | null
  }

  export type BillSplitMemberCountAggregateOutputType = {
    id: number
    groupId: number
    userId: number
    phone: number
    name: number
    share: number
    paid: number
    paidAt: number
    paidAmount: number
    _all: number
  }


  export type BillSplitMemberAvgAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    share?: true
    paidAmount?: true
  }

  export type BillSplitMemberSumAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    share?: true
    paidAmount?: true
  }

  export type BillSplitMemberMinAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    phone?: true
    name?: true
    share?: true
    paid?: true
    paidAt?: true
    paidAmount?: true
  }

  export type BillSplitMemberMaxAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    phone?: true
    name?: true
    share?: true
    paid?: true
    paidAt?: true
    paidAmount?: true
  }

  export type BillSplitMemberCountAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    phone?: true
    name?: true
    share?: true
    paid?: true
    paidAt?: true
    paidAmount?: true
    _all?: true
  }

  export type BillSplitMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillSplitMember to aggregate.
     */
    where?: BillSplitMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillSplitMembers to fetch.
     */
    orderBy?: BillSplitMemberOrderByWithRelationInput | BillSplitMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillSplitMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillSplitMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillSplitMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BillSplitMembers
    **/
    _count?: true | BillSplitMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillSplitMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillSplitMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillSplitMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillSplitMemberMaxAggregateInputType
  }

  export type GetBillSplitMemberAggregateType<T extends BillSplitMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateBillSplitMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBillSplitMember[P]>
      : GetScalarType<T[P], AggregateBillSplitMember[P]>
  }




  export type BillSplitMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillSplitMemberWhereInput
    orderBy?: BillSplitMemberOrderByWithAggregationInput | BillSplitMemberOrderByWithAggregationInput[]
    by: BillSplitMemberScalarFieldEnum[] | BillSplitMemberScalarFieldEnum
    having?: BillSplitMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillSplitMemberCountAggregateInputType | true
    _avg?: BillSplitMemberAvgAggregateInputType
    _sum?: BillSplitMemberSumAggregateInputType
    _min?: BillSplitMemberMinAggregateInputType
    _max?: BillSplitMemberMaxAggregateInputType
  }

  export type BillSplitMemberGroupByOutputType = {
    id: number
    groupId: number
    userId: number | null
    phone: string | null
    name: string
    share: number
    paid: boolean
    paidAt: Date | null
    paidAmount: number
    _count: BillSplitMemberCountAggregateOutputType | null
    _avg: BillSplitMemberAvgAggregateOutputType | null
    _sum: BillSplitMemberSumAggregateOutputType | null
    _min: BillSplitMemberMinAggregateOutputType | null
    _max: BillSplitMemberMaxAggregateOutputType | null
  }

  type GetBillSplitMemberGroupByPayload<T extends BillSplitMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillSplitMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillSplitMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillSplitMemberGroupByOutputType[P]>
            : GetScalarType<T[P], BillSplitMemberGroupByOutputType[P]>
        }
      >
    >


  export type BillSplitMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    userId?: boolean
    phone?: boolean
    name?: boolean
    share?: boolean
    paid?: boolean
    paidAt?: boolean
    paidAmount?: boolean
    group?: boolean | BillSplitGroupDefaultArgs<ExtArgs>
    user?: boolean | BillSplitMember$userArgs<ExtArgs>
    request?: boolean | BillSplitMember$requestArgs<ExtArgs>
    payments?: boolean | BillSplitMember$paymentsArgs<ExtArgs>
    _count?: boolean | BillSplitMemberCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billSplitMember"]>

  export type BillSplitMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    userId?: boolean
    phone?: boolean
    name?: boolean
    share?: boolean
    paid?: boolean
    paidAt?: boolean
    paidAmount?: boolean
    group?: boolean | BillSplitGroupDefaultArgs<ExtArgs>
    user?: boolean | BillSplitMember$userArgs<ExtArgs>
  }, ExtArgs["result"]["billSplitMember"]>

  export type BillSplitMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    userId?: boolean
    phone?: boolean
    name?: boolean
    share?: boolean
    paid?: boolean
    paidAt?: boolean
    paidAmount?: boolean
    group?: boolean | BillSplitGroupDefaultArgs<ExtArgs>
    user?: boolean | BillSplitMember$userArgs<ExtArgs>
  }, ExtArgs["result"]["billSplitMember"]>

  export type BillSplitMemberSelectScalar = {
    id?: boolean
    groupId?: boolean
    userId?: boolean
    phone?: boolean
    name?: boolean
    share?: boolean
    paid?: boolean
    paidAt?: boolean
    paidAmount?: boolean
  }

  export type BillSplitMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "groupId" | "userId" | "phone" | "name" | "share" | "paid" | "paidAt" | "paidAmount", ExtArgs["result"]["billSplitMember"]>
  export type BillSplitMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | BillSplitGroupDefaultArgs<ExtArgs>
    user?: boolean | BillSplitMember$userArgs<ExtArgs>
    request?: boolean | BillSplitMember$requestArgs<ExtArgs>
    payments?: boolean | BillSplitMember$paymentsArgs<ExtArgs>
    _count?: boolean | BillSplitMemberCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BillSplitMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | BillSplitGroupDefaultArgs<ExtArgs>
    user?: boolean | BillSplitMember$userArgs<ExtArgs>
  }
  export type BillSplitMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | BillSplitGroupDefaultArgs<ExtArgs>
    user?: boolean | BillSplitMember$userArgs<ExtArgs>
  }

  export type $BillSplitMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BillSplitMember"
    objects: {
      group: Prisma.$BillSplitGroupPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
      request: Prisma.$P2PRequestPayload<ExtArgs> | null
      payments: Prisma.$BillSplitPaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      groupId: number
      userId: number | null
      phone: string | null
      name: string
      share: number
      paid: boolean
      paidAt: Date | null
      paidAmount: number
    }, ExtArgs["result"]["billSplitMember"]>
    composites: {}
  }

  type BillSplitMemberGetPayload<S extends boolean | null | undefined | BillSplitMemberDefaultArgs> = $Result.GetResult<Prisma.$BillSplitMemberPayload, S>

  type BillSplitMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BillSplitMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BillSplitMemberCountAggregateInputType | true
    }

  export interface BillSplitMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BillSplitMember'], meta: { name: 'BillSplitMember' } }
    /**
     * Find zero or one BillSplitMember that matches the filter.
     * @param {BillSplitMemberFindUniqueArgs} args - Arguments to find a BillSplitMember
     * @example
     * // Get one BillSplitMember
     * const billSplitMember = await prisma.billSplitMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillSplitMemberFindUniqueArgs>(args: SelectSubset<T, BillSplitMemberFindUniqueArgs<ExtArgs>>): Prisma__BillSplitMemberClient<$Result.GetResult<Prisma.$BillSplitMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BillSplitMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BillSplitMemberFindUniqueOrThrowArgs} args - Arguments to find a BillSplitMember
     * @example
     * // Get one BillSplitMember
     * const billSplitMember = await prisma.billSplitMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillSplitMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, BillSplitMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillSplitMemberClient<$Result.GetResult<Prisma.$BillSplitMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillSplitMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillSplitMemberFindFirstArgs} args - Arguments to find a BillSplitMember
     * @example
     * // Get one BillSplitMember
     * const billSplitMember = await prisma.billSplitMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillSplitMemberFindFirstArgs>(args?: SelectSubset<T, BillSplitMemberFindFirstArgs<ExtArgs>>): Prisma__BillSplitMemberClient<$Result.GetResult<Prisma.$BillSplitMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillSplitMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillSplitMemberFindFirstOrThrowArgs} args - Arguments to find a BillSplitMember
     * @example
     * // Get one BillSplitMember
     * const billSplitMember = await prisma.billSplitMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillSplitMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, BillSplitMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillSplitMemberClient<$Result.GetResult<Prisma.$BillSplitMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BillSplitMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillSplitMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BillSplitMembers
     * const billSplitMembers = await prisma.billSplitMember.findMany()
     * 
     * // Get first 10 BillSplitMembers
     * const billSplitMembers = await prisma.billSplitMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billSplitMemberWithIdOnly = await prisma.billSplitMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillSplitMemberFindManyArgs>(args?: SelectSubset<T, BillSplitMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillSplitMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BillSplitMember.
     * @param {BillSplitMemberCreateArgs} args - Arguments to create a BillSplitMember.
     * @example
     * // Create one BillSplitMember
     * const BillSplitMember = await prisma.billSplitMember.create({
     *   data: {
     *     // ... data to create a BillSplitMember
     *   }
     * })
     * 
     */
    create<T extends BillSplitMemberCreateArgs>(args: SelectSubset<T, BillSplitMemberCreateArgs<ExtArgs>>): Prisma__BillSplitMemberClient<$Result.GetResult<Prisma.$BillSplitMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BillSplitMembers.
     * @param {BillSplitMemberCreateManyArgs} args - Arguments to create many BillSplitMembers.
     * @example
     * // Create many BillSplitMembers
     * const billSplitMember = await prisma.billSplitMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillSplitMemberCreateManyArgs>(args?: SelectSubset<T, BillSplitMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BillSplitMembers and returns the data saved in the database.
     * @param {BillSplitMemberCreateManyAndReturnArgs} args - Arguments to create many BillSplitMembers.
     * @example
     * // Create many BillSplitMembers
     * const billSplitMember = await prisma.billSplitMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BillSplitMembers and only return the `id`
     * const billSplitMemberWithIdOnly = await prisma.billSplitMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BillSplitMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, BillSplitMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillSplitMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BillSplitMember.
     * @param {BillSplitMemberDeleteArgs} args - Arguments to delete one BillSplitMember.
     * @example
     * // Delete one BillSplitMember
     * const BillSplitMember = await prisma.billSplitMember.delete({
     *   where: {
     *     // ... filter to delete one BillSplitMember
     *   }
     * })
     * 
     */
    delete<T extends BillSplitMemberDeleteArgs>(args: SelectSubset<T, BillSplitMemberDeleteArgs<ExtArgs>>): Prisma__BillSplitMemberClient<$Result.GetResult<Prisma.$BillSplitMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BillSplitMember.
     * @param {BillSplitMemberUpdateArgs} args - Arguments to update one BillSplitMember.
     * @example
     * // Update one BillSplitMember
     * const billSplitMember = await prisma.billSplitMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillSplitMemberUpdateArgs>(args: SelectSubset<T, BillSplitMemberUpdateArgs<ExtArgs>>): Prisma__BillSplitMemberClient<$Result.GetResult<Prisma.$BillSplitMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BillSplitMembers.
     * @param {BillSplitMemberDeleteManyArgs} args - Arguments to filter BillSplitMembers to delete.
     * @example
     * // Delete a few BillSplitMembers
     * const { count } = await prisma.billSplitMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillSplitMemberDeleteManyArgs>(args?: SelectSubset<T, BillSplitMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillSplitMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillSplitMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BillSplitMembers
     * const billSplitMember = await prisma.billSplitMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillSplitMemberUpdateManyArgs>(args: SelectSubset<T, BillSplitMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillSplitMembers and returns the data updated in the database.
     * @param {BillSplitMemberUpdateManyAndReturnArgs} args - Arguments to update many BillSplitMembers.
     * @example
     * // Update many BillSplitMembers
     * const billSplitMember = await prisma.billSplitMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BillSplitMembers and only return the `id`
     * const billSplitMemberWithIdOnly = await prisma.billSplitMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BillSplitMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, BillSplitMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillSplitMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BillSplitMember.
     * @param {BillSplitMemberUpsertArgs} args - Arguments to update or create a BillSplitMember.
     * @example
     * // Update or create a BillSplitMember
     * const billSplitMember = await prisma.billSplitMember.upsert({
     *   create: {
     *     // ... data to create a BillSplitMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BillSplitMember we want to update
     *   }
     * })
     */
    upsert<T extends BillSplitMemberUpsertArgs>(args: SelectSubset<T, BillSplitMemberUpsertArgs<ExtArgs>>): Prisma__BillSplitMemberClient<$Result.GetResult<Prisma.$BillSplitMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BillSplitMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillSplitMemberCountArgs} args - Arguments to filter BillSplitMembers to count.
     * @example
     * // Count the number of BillSplitMembers
     * const count = await prisma.billSplitMember.count({
     *   where: {
     *     // ... the filter for the BillSplitMembers we want to count
     *   }
     * })
    **/
    count<T extends BillSplitMemberCountArgs>(
      args?: Subset<T, BillSplitMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillSplitMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BillSplitMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillSplitMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillSplitMemberAggregateArgs>(args: Subset<T, BillSplitMemberAggregateArgs>): Prisma.PrismaPromise<GetBillSplitMemberAggregateType<T>>

    /**
     * Group by BillSplitMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillSplitMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillSplitMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillSplitMemberGroupByArgs['orderBy'] }
        : { orderBy?: BillSplitMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillSplitMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillSplitMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BillSplitMember model
   */
  readonly fields: BillSplitMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BillSplitMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillSplitMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends BillSplitGroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BillSplitGroupDefaultArgs<ExtArgs>>): Prisma__BillSplitGroupClient<$Result.GetResult<Prisma.$BillSplitGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends BillSplitMember$userArgs<ExtArgs> = {}>(args?: Subset<T, BillSplitMember$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    request<T extends BillSplitMember$requestArgs<ExtArgs> = {}>(args?: Subset<T, BillSplitMember$requestArgs<ExtArgs>>): Prisma__P2PRequestClient<$Result.GetResult<Prisma.$P2PRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    payments<T extends BillSplitMember$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, BillSplitMember$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillSplitPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BillSplitMember model
   */
  interface BillSplitMemberFieldRefs {
    readonly id: FieldRef<"BillSplitMember", 'Int'>
    readonly groupId: FieldRef<"BillSplitMember", 'Int'>
    readonly userId: FieldRef<"BillSplitMember", 'Int'>
    readonly phone: FieldRef<"BillSplitMember", 'String'>
    readonly name: FieldRef<"BillSplitMember", 'String'>
    readonly share: FieldRef<"BillSplitMember", 'Int'>
    readonly paid: FieldRef<"BillSplitMember", 'Boolean'>
    readonly paidAt: FieldRef<"BillSplitMember", 'DateTime'>
    readonly paidAmount: FieldRef<"BillSplitMember", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BillSplitMember findUnique
   */
  export type BillSplitMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitMember
     */
    select?: BillSplitMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitMember
     */
    omit?: BillSplitMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitMemberInclude<ExtArgs> | null
    /**
     * Filter, which BillSplitMember to fetch.
     */
    where: BillSplitMemberWhereUniqueInput
  }

  /**
   * BillSplitMember findUniqueOrThrow
   */
  export type BillSplitMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitMember
     */
    select?: BillSplitMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitMember
     */
    omit?: BillSplitMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitMemberInclude<ExtArgs> | null
    /**
     * Filter, which BillSplitMember to fetch.
     */
    where: BillSplitMemberWhereUniqueInput
  }

  /**
   * BillSplitMember findFirst
   */
  export type BillSplitMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitMember
     */
    select?: BillSplitMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitMember
     */
    omit?: BillSplitMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitMemberInclude<ExtArgs> | null
    /**
     * Filter, which BillSplitMember to fetch.
     */
    where?: BillSplitMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillSplitMembers to fetch.
     */
    orderBy?: BillSplitMemberOrderByWithRelationInput | BillSplitMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillSplitMembers.
     */
    cursor?: BillSplitMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillSplitMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillSplitMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillSplitMembers.
     */
    distinct?: BillSplitMemberScalarFieldEnum | BillSplitMemberScalarFieldEnum[]
  }

  /**
   * BillSplitMember findFirstOrThrow
   */
  export type BillSplitMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitMember
     */
    select?: BillSplitMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitMember
     */
    omit?: BillSplitMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitMemberInclude<ExtArgs> | null
    /**
     * Filter, which BillSplitMember to fetch.
     */
    where?: BillSplitMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillSplitMembers to fetch.
     */
    orderBy?: BillSplitMemberOrderByWithRelationInput | BillSplitMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillSplitMembers.
     */
    cursor?: BillSplitMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillSplitMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillSplitMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillSplitMembers.
     */
    distinct?: BillSplitMemberScalarFieldEnum | BillSplitMemberScalarFieldEnum[]
  }

  /**
   * BillSplitMember findMany
   */
  export type BillSplitMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitMember
     */
    select?: BillSplitMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitMember
     */
    omit?: BillSplitMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitMemberInclude<ExtArgs> | null
    /**
     * Filter, which BillSplitMembers to fetch.
     */
    where?: BillSplitMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillSplitMembers to fetch.
     */
    orderBy?: BillSplitMemberOrderByWithRelationInput | BillSplitMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BillSplitMembers.
     */
    cursor?: BillSplitMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillSplitMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillSplitMembers.
     */
    skip?: number
    distinct?: BillSplitMemberScalarFieldEnum | BillSplitMemberScalarFieldEnum[]
  }

  /**
   * BillSplitMember create
   */
  export type BillSplitMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitMember
     */
    select?: BillSplitMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitMember
     */
    omit?: BillSplitMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a BillSplitMember.
     */
    data: XOR<BillSplitMemberCreateInput, BillSplitMemberUncheckedCreateInput>
  }

  /**
   * BillSplitMember createMany
   */
  export type BillSplitMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BillSplitMembers.
     */
    data: BillSplitMemberCreateManyInput | BillSplitMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BillSplitMember createManyAndReturn
   */
  export type BillSplitMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitMember
     */
    select?: BillSplitMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitMember
     */
    omit?: BillSplitMemberOmit<ExtArgs> | null
    /**
     * The data used to create many BillSplitMembers.
     */
    data: BillSplitMemberCreateManyInput | BillSplitMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillSplitMember update
   */
  export type BillSplitMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitMember
     */
    select?: BillSplitMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitMember
     */
    omit?: BillSplitMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a BillSplitMember.
     */
    data: XOR<BillSplitMemberUpdateInput, BillSplitMemberUncheckedUpdateInput>
    /**
     * Choose, which BillSplitMember to update.
     */
    where: BillSplitMemberWhereUniqueInput
  }

  /**
   * BillSplitMember updateMany
   */
  export type BillSplitMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BillSplitMembers.
     */
    data: XOR<BillSplitMemberUpdateManyMutationInput, BillSplitMemberUncheckedUpdateManyInput>
    /**
     * Filter which BillSplitMembers to update
     */
    where?: BillSplitMemberWhereInput
    /**
     * Limit how many BillSplitMembers to update.
     */
    limit?: number
  }

  /**
   * BillSplitMember updateManyAndReturn
   */
  export type BillSplitMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitMember
     */
    select?: BillSplitMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitMember
     */
    omit?: BillSplitMemberOmit<ExtArgs> | null
    /**
     * The data used to update BillSplitMembers.
     */
    data: XOR<BillSplitMemberUpdateManyMutationInput, BillSplitMemberUncheckedUpdateManyInput>
    /**
     * Filter which BillSplitMembers to update
     */
    where?: BillSplitMemberWhereInput
    /**
     * Limit how many BillSplitMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillSplitMember upsert
   */
  export type BillSplitMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitMember
     */
    select?: BillSplitMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitMember
     */
    omit?: BillSplitMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the BillSplitMember to update in case it exists.
     */
    where: BillSplitMemberWhereUniqueInput
    /**
     * In case the BillSplitMember found by the `where` argument doesn't exist, create a new BillSplitMember with this data.
     */
    create: XOR<BillSplitMemberCreateInput, BillSplitMemberUncheckedCreateInput>
    /**
     * In case the BillSplitMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillSplitMemberUpdateInput, BillSplitMemberUncheckedUpdateInput>
  }

  /**
   * BillSplitMember delete
   */
  export type BillSplitMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitMember
     */
    select?: BillSplitMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitMember
     */
    omit?: BillSplitMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitMemberInclude<ExtArgs> | null
    /**
     * Filter which BillSplitMember to delete.
     */
    where: BillSplitMemberWhereUniqueInput
  }

  /**
   * BillSplitMember deleteMany
   */
  export type BillSplitMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillSplitMembers to delete
     */
    where?: BillSplitMemberWhereInput
    /**
     * Limit how many BillSplitMembers to delete.
     */
    limit?: number
  }

  /**
   * BillSplitMember.user
   */
  export type BillSplitMember$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * BillSplitMember.request
   */
  export type BillSplitMember$requestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the P2PRequest
     */
    select?: P2PRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the P2PRequest
     */
    omit?: P2PRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: P2PRequestInclude<ExtArgs> | null
    where?: P2PRequestWhereInput
  }

  /**
   * BillSplitMember.payments
   */
  export type BillSplitMember$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitPayment
     */
    select?: BillSplitPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitPayment
     */
    omit?: BillSplitPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitPaymentInclude<ExtArgs> | null
    where?: BillSplitPaymentWhereInput
    orderBy?: BillSplitPaymentOrderByWithRelationInput | BillSplitPaymentOrderByWithRelationInput[]
    cursor?: BillSplitPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillSplitPaymentScalarFieldEnum | BillSplitPaymentScalarFieldEnum[]
  }

  /**
   * BillSplitMember without action
   */
  export type BillSplitMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitMember
     */
    select?: BillSplitMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitMember
     */
    omit?: BillSplitMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitMemberInclude<ExtArgs> | null
  }


  /**
   * Model BillSplitPayment
   */

  export type AggregateBillSplitPayment = {
    _count: BillSplitPaymentCountAggregateOutputType | null
    _avg: BillSplitPaymentAvgAggregateOutputType | null
    _sum: BillSplitPaymentSumAggregateOutputType | null
    _min: BillSplitPaymentMinAggregateOutputType | null
    _max: BillSplitPaymentMaxAggregateOutputType | null
  }

  export type BillSplitPaymentAvgAggregateOutputType = {
    id: number | null
    groupId: number | null
    memberId: number | null
    p2pTransferId: number | null
    amount: number | null
  }

  export type BillSplitPaymentSumAggregateOutputType = {
    id: number | null
    groupId: number | null
    memberId: number | null
    p2pTransferId: number | null
    amount: number | null
  }

  export type BillSplitPaymentMinAggregateOutputType = {
    id: number | null
    groupId: number | null
    memberId: number | null
    p2pTransferId: number | null
    amount: number | null
    paidAt: Date | null
  }

  export type BillSplitPaymentMaxAggregateOutputType = {
    id: number | null
    groupId: number | null
    memberId: number | null
    p2pTransferId: number | null
    amount: number | null
    paidAt: Date | null
  }

  export type BillSplitPaymentCountAggregateOutputType = {
    id: number
    groupId: number
    memberId: number
    p2pTransferId: number
    amount: number
    paidAt: number
    _all: number
  }


  export type BillSplitPaymentAvgAggregateInputType = {
    id?: true
    groupId?: true
    memberId?: true
    p2pTransferId?: true
    amount?: true
  }

  export type BillSplitPaymentSumAggregateInputType = {
    id?: true
    groupId?: true
    memberId?: true
    p2pTransferId?: true
    amount?: true
  }

  export type BillSplitPaymentMinAggregateInputType = {
    id?: true
    groupId?: true
    memberId?: true
    p2pTransferId?: true
    amount?: true
    paidAt?: true
  }

  export type BillSplitPaymentMaxAggregateInputType = {
    id?: true
    groupId?: true
    memberId?: true
    p2pTransferId?: true
    amount?: true
    paidAt?: true
  }

  export type BillSplitPaymentCountAggregateInputType = {
    id?: true
    groupId?: true
    memberId?: true
    p2pTransferId?: true
    amount?: true
    paidAt?: true
    _all?: true
  }

  export type BillSplitPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillSplitPayment to aggregate.
     */
    where?: BillSplitPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillSplitPayments to fetch.
     */
    orderBy?: BillSplitPaymentOrderByWithRelationInput | BillSplitPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillSplitPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillSplitPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillSplitPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BillSplitPayments
    **/
    _count?: true | BillSplitPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillSplitPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillSplitPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillSplitPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillSplitPaymentMaxAggregateInputType
  }

  export type GetBillSplitPaymentAggregateType<T extends BillSplitPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateBillSplitPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBillSplitPayment[P]>
      : GetScalarType<T[P], AggregateBillSplitPayment[P]>
  }




  export type BillSplitPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillSplitPaymentWhereInput
    orderBy?: BillSplitPaymentOrderByWithAggregationInput | BillSplitPaymentOrderByWithAggregationInput[]
    by: BillSplitPaymentScalarFieldEnum[] | BillSplitPaymentScalarFieldEnum
    having?: BillSplitPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillSplitPaymentCountAggregateInputType | true
    _avg?: BillSplitPaymentAvgAggregateInputType
    _sum?: BillSplitPaymentSumAggregateInputType
    _min?: BillSplitPaymentMinAggregateInputType
    _max?: BillSplitPaymentMaxAggregateInputType
  }

  export type BillSplitPaymentGroupByOutputType = {
    id: number
    groupId: number
    memberId: number
    p2pTransferId: number | null
    amount: number
    paidAt: Date
    _count: BillSplitPaymentCountAggregateOutputType | null
    _avg: BillSplitPaymentAvgAggregateOutputType | null
    _sum: BillSplitPaymentSumAggregateOutputType | null
    _min: BillSplitPaymentMinAggregateOutputType | null
    _max: BillSplitPaymentMaxAggregateOutputType | null
  }

  type GetBillSplitPaymentGroupByPayload<T extends BillSplitPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillSplitPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillSplitPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillSplitPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], BillSplitPaymentGroupByOutputType[P]>
        }
      >
    >


  export type BillSplitPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    memberId?: boolean
    p2pTransferId?: boolean
    amount?: boolean
    paidAt?: boolean
    group?: boolean | BillSplitGroupDefaultArgs<ExtArgs>
    member?: boolean | BillSplitMemberDefaultArgs<ExtArgs>
    p2pTransfer?: boolean | BillSplitPayment$p2pTransferArgs<ExtArgs>
  }, ExtArgs["result"]["billSplitPayment"]>

  export type BillSplitPaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    memberId?: boolean
    p2pTransferId?: boolean
    amount?: boolean
    paidAt?: boolean
    group?: boolean | BillSplitGroupDefaultArgs<ExtArgs>
    member?: boolean | BillSplitMemberDefaultArgs<ExtArgs>
    p2pTransfer?: boolean | BillSplitPayment$p2pTransferArgs<ExtArgs>
  }, ExtArgs["result"]["billSplitPayment"]>

  export type BillSplitPaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    memberId?: boolean
    p2pTransferId?: boolean
    amount?: boolean
    paidAt?: boolean
    group?: boolean | BillSplitGroupDefaultArgs<ExtArgs>
    member?: boolean | BillSplitMemberDefaultArgs<ExtArgs>
    p2pTransfer?: boolean | BillSplitPayment$p2pTransferArgs<ExtArgs>
  }, ExtArgs["result"]["billSplitPayment"]>

  export type BillSplitPaymentSelectScalar = {
    id?: boolean
    groupId?: boolean
    memberId?: boolean
    p2pTransferId?: boolean
    amount?: boolean
    paidAt?: boolean
  }

  export type BillSplitPaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "groupId" | "memberId" | "p2pTransferId" | "amount" | "paidAt", ExtArgs["result"]["billSplitPayment"]>
  export type BillSplitPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | BillSplitGroupDefaultArgs<ExtArgs>
    member?: boolean | BillSplitMemberDefaultArgs<ExtArgs>
    p2pTransfer?: boolean | BillSplitPayment$p2pTransferArgs<ExtArgs>
  }
  export type BillSplitPaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | BillSplitGroupDefaultArgs<ExtArgs>
    member?: boolean | BillSplitMemberDefaultArgs<ExtArgs>
    p2pTransfer?: boolean | BillSplitPayment$p2pTransferArgs<ExtArgs>
  }
  export type BillSplitPaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | BillSplitGroupDefaultArgs<ExtArgs>
    member?: boolean | BillSplitMemberDefaultArgs<ExtArgs>
    p2pTransfer?: boolean | BillSplitPayment$p2pTransferArgs<ExtArgs>
  }

  export type $BillSplitPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BillSplitPayment"
    objects: {
      group: Prisma.$BillSplitGroupPayload<ExtArgs>
      member: Prisma.$BillSplitMemberPayload<ExtArgs>
      p2pTransfer: Prisma.$p2pTransferPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      groupId: number
      memberId: number
      p2pTransferId: number | null
      amount: number
      paidAt: Date
    }, ExtArgs["result"]["billSplitPayment"]>
    composites: {}
  }

  type BillSplitPaymentGetPayload<S extends boolean | null | undefined | BillSplitPaymentDefaultArgs> = $Result.GetResult<Prisma.$BillSplitPaymentPayload, S>

  type BillSplitPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BillSplitPaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BillSplitPaymentCountAggregateInputType | true
    }

  export interface BillSplitPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BillSplitPayment'], meta: { name: 'BillSplitPayment' } }
    /**
     * Find zero or one BillSplitPayment that matches the filter.
     * @param {BillSplitPaymentFindUniqueArgs} args - Arguments to find a BillSplitPayment
     * @example
     * // Get one BillSplitPayment
     * const billSplitPayment = await prisma.billSplitPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillSplitPaymentFindUniqueArgs>(args: SelectSubset<T, BillSplitPaymentFindUniqueArgs<ExtArgs>>): Prisma__BillSplitPaymentClient<$Result.GetResult<Prisma.$BillSplitPaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BillSplitPayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BillSplitPaymentFindUniqueOrThrowArgs} args - Arguments to find a BillSplitPayment
     * @example
     * // Get one BillSplitPayment
     * const billSplitPayment = await prisma.billSplitPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillSplitPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, BillSplitPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillSplitPaymentClient<$Result.GetResult<Prisma.$BillSplitPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillSplitPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillSplitPaymentFindFirstArgs} args - Arguments to find a BillSplitPayment
     * @example
     * // Get one BillSplitPayment
     * const billSplitPayment = await prisma.billSplitPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillSplitPaymentFindFirstArgs>(args?: SelectSubset<T, BillSplitPaymentFindFirstArgs<ExtArgs>>): Prisma__BillSplitPaymentClient<$Result.GetResult<Prisma.$BillSplitPaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillSplitPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillSplitPaymentFindFirstOrThrowArgs} args - Arguments to find a BillSplitPayment
     * @example
     * // Get one BillSplitPayment
     * const billSplitPayment = await prisma.billSplitPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillSplitPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, BillSplitPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillSplitPaymentClient<$Result.GetResult<Prisma.$BillSplitPaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BillSplitPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillSplitPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BillSplitPayments
     * const billSplitPayments = await prisma.billSplitPayment.findMany()
     * 
     * // Get first 10 BillSplitPayments
     * const billSplitPayments = await prisma.billSplitPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billSplitPaymentWithIdOnly = await prisma.billSplitPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillSplitPaymentFindManyArgs>(args?: SelectSubset<T, BillSplitPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillSplitPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BillSplitPayment.
     * @param {BillSplitPaymentCreateArgs} args - Arguments to create a BillSplitPayment.
     * @example
     * // Create one BillSplitPayment
     * const BillSplitPayment = await prisma.billSplitPayment.create({
     *   data: {
     *     // ... data to create a BillSplitPayment
     *   }
     * })
     * 
     */
    create<T extends BillSplitPaymentCreateArgs>(args: SelectSubset<T, BillSplitPaymentCreateArgs<ExtArgs>>): Prisma__BillSplitPaymentClient<$Result.GetResult<Prisma.$BillSplitPaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BillSplitPayments.
     * @param {BillSplitPaymentCreateManyArgs} args - Arguments to create many BillSplitPayments.
     * @example
     * // Create many BillSplitPayments
     * const billSplitPayment = await prisma.billSplitPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillSplitPaymentCreateManyArgs>(args?: SelectSubset<T, BillSplitPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BillSplitPayments and returns the data saved in the database.
     * @param {BillSplitPaymentCreateManyAndReturnArgs} args - Arguments to create many BillSplitPayments.
     * @example
     * // Create many BillSplitPayments
     * const billSplitPayment = await prisma.billSplitPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BillSplitPayments and only return the `id`
     * const billSplitPaymentWithIdOnly = await prisma.billSplitPayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BillSplitPaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, BillSplitPaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillSplitPaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BillSplitPayment.
     * @param {BillSplitPaymentDeleteArgs} args - Arguments to delete one BillSplitPayment.
     * @example
     * // Delete one BillSplitPayment
     * const BillSplitPayment = await prisma.billSplitPayment.delete({
     *   where: {
     *     // ... filter to delete one BillSplitPayment
     *   }
     * })
     * 
     */
    delete<T extends BillSplitPaymentDeleteArgs>(args: SelectSubset<T, BillSplitPaymentDeleteArgs<ExtArgs>>): Prisma__BillSplitPaymentClient<$Result.GetResult<Prisma.$BillSplitPaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BillSplitPayment.
     * @param {BillSplitPaymentUpdateArgs} args - Arguments to update one BillSplitPayment.
     * @example
     * // Update one BillSplitPayment
     * const billSplitPayment = await prisma.billSplitPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillSplitPaymentUpdateArgs>(args: SelectSubset<T, BillSplitPaymentUpdateArgs<ExtArgs>>): Prisma__BillSplitPaymentClient<$Result.GetResult<Prisma.$BillSplitPaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BillSplitPayments.
     * @param {BillSplitPaymentDeleteManyArgs} args - Arguments to filter BillSplitPayments to delete.
     * @example
     * // Delete a few BillSplitPayments
     * const { count } = await prisma.billSplitPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillSplitPaymentDeleteManyArgs>(args?: SelectSubset<T, BillSplitPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillSplitPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillSplitPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BillSplitPayments
     * const billSplitPayment = await prisma.billSplitPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillSplitPaymentUpdateManyArgs>(args: SelectSubset<T, BillSplitPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillSplitPayments and returns the data updated in the database.
     * @param {BillSplitPaymentUpdateManyAndReturnArgs} args - Arguments to update many BillSplitPayments.
     * @example
     * // Update many BillSplitPayments
     * const billSplitPayment = await prisma.billSplitPayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BillSplitPayments and only return the `id`
     * const billSplitPaymentWithIdOnly = await prisma.billSplitPayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BillSplitPaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, BillSplitPaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillSplitPaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BillSplitPayment.
     * @param {BillSplitPaymentUpsertArgs} args - Arguments to update or create a BillSplitPayment.
     * @example
     * // Update or create a BillSplitPayment
     * const billSplitPayment = await prisma.billSplitPayment.upsert({
     *   create: {
     *     // ... data to create a BillSplitPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BillSplitPayment we want to update
     *   }
     * })
     */
    upsert<T extends BillSplitPaymentUpsertArgs>(args: SelectSubset<T, BillSplitPaymentUpsertArgs<ExtArgs>>): Prisma__BillSplitPaymentClient<$Result.GetResult<Prisma.$BillSplitPaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BillSplitPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillSplitPaymentCountArgs} args - Arguments to filter BillSplitPayments to count.
     * @example
     * // Count the number of BillSplitPayments
     * const count = await prisma.billSplitPayment.count({
     *   where: {
     *     // ... the filter for the BillSplitPayments we want to count
     *   }
     * })
    **/
    count<T extends BillSplitPaymentCountArgs>(
      args?: Subset<T, BillSplitPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillSplitPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BillSplitPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillSplitPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillSplitPaymentAggregateArgs>(args: Subset<T, BillSplitPaymentAggregateArgs>): Prisma.PrismaPromise<GetBillSplitPaymentAggregateType<T>>

    /**
     * Group by BillSplitPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillSplitPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillSplitPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillSplitPaymentGroupByArgs['orderBy'] }
        : { orderBy?: BillSplitPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillSplitPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillSplitPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BillSplitPayment model
   */
  readonly fields: BillSplitPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BillSplitPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillSplitPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends BillSplitGroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BillSplitGroupDefaultArgs<ExtArgs>>): Prisma__BillSplitGroupClient<$Result.GetResult<Prisma.$BillSplitGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    member<T extends BillSplitMemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BillSplitMemberDefaultArgs<ExtArgs>>): Prisma__BillSplitMemberClient<$Result.GetResult<Prisma.$BillSplitMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    p2pTransfer<T extends BillSplitPayment$p2pTransferArgs<ExtArgs> = {}>(args?: Subset<T, BillSplitPayment$p2pTransferArgs<ExtArgs>>): Prisma__p2pTransferClient<$Result.GetResult<Prisma.$p2pTransferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BillSplitPayment model
   */
  interface BillSplitPaymentFieldRefs {
    readonly id: FieldRef<"BillSplitPayment", 'Int'>
    readonly groupId: FieldRef<"BillSplitPayment", 'Int'>
    readonly memberId: FieldRef<"BillSplitPayment", 'Int'>
    readonly p2pTransferId: FieldRef<"BillSplitPayment", 'Int'>
    readonly amount: FieldRef<"BillSplitPayment", 'Int'>
    readonly paidAt: FieldRef<"BillSplitPayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BillSplitPayment findUnique
   */
  export type BillSplitPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitPayment
     */
    select?: BillSplitPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitPayment
     */
    omit?: BillSplitPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitPaymentInclude<ExtArgs> | null
    /**
     * Filter, which BillSplitPayment to fetch.
     */
    where: BillSplitPaymentWhereUniqueInput
  }

  /**
   * BillSplitPayment findUniqueOrThrow
   */
  export type BillSplitPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitPayment
     */
    select?: BillSplitPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitPayment
     */
    omit?: BillSplitPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitPaymentInclude<ExtArgs> | null
    /**
     * Filter, which BillSplitPayment to fetch.
     */
    where: BillSplitPaymentWhereUniqueInput
  }

  /**
   * BillSplitPayment findFirst
   */
  export type BillSplitPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitPayment
     */
    select?: BillSplitPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitPayment
     */
    omit?: BillSplitPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitPaymentInclude<ExtArgs> | null
    /**
     * Filter, which BillSplitPayment to fetch.
     */
    where?: BillSplitPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillSplitPayments to fetch.
     */
    orderBy?: BillSplitPaymentOrderByWithRelationInput | BillSplitPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillSplitPayments.
     */
    cursor?: BillSplitPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillSplitPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillSplitPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillSplitPayments.
     */
    distinct?: BillSplitPaymentScalarFieldEnum | BillSplitPaymentScalarFieldEnum[]
  }

  /**
   * BillSplitPayment findFirstOrThrow
   */
  export type BillSplitPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitPayment
     */
    select?: BillSplitPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitPayment
     */
    omit?: BillSplitPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitPaymentInclude<ExtArgs> | null
    /**
     * Filter, which BillSplitPayment to fetch.
     */
    where?: BillSplitPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillSplitPayments to fetch.
     */
    orderBy?: BillSplitPaymentOrderByWithRelationInput | BillSplitPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillSplitPayments.
     */
    cursor?: BillSplitPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillSplitPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillSplitPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillSplitPayments.
     */
    distinct?: BillSplitPaymentScalarFieldEnum | BillSplitPaymentScalarFieldEnum[]
  }

  /**
   * BillSplitPayment findMany
   */
  export type BillSplitPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitPayment
     */
    select?: BillSplitPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitPayment
     */
    omit?: BillSplitPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitPaymentInclude<ExtArgs> | null
    /**
     * Filter, which BillSplitPayments to fetch.
     */
    where?: BillSplitPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillSplitPayments to fetch.
     */
    orderBy?: BillSplitPaymentOrderByWithRelationInput | BillSplitPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BillSplitPayments.
     */
    cursor?: BillSplitPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillSplitPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillSplitPayments.
     */
    skip?: number
    distinct?: BillSplitPaymentScalarFieldEnum | BillSplitPaymentScalarFieldEnum[]
  }

  /**
   * BillSplitPayment create
   */
  export type BillSplitPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitPayment
     */
    select?: BillSplitPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitPayment
     */
    omit?: BillSplitPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a BillSplitPayment.
     */
    data: XOR<BillSplitPaymentCreateInput, BillSplitPaymentUncheckedCreateInput>
  }

  /**
   * BillSplitPayment createMany
   */
  export type BillSplitPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BillSplitPayments.
     */
    data: BillSplitPaymentCreateManyInput | BillSplitPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BillSplitPayment createManyAndReturn
   */
  export type BillSplitPaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitPayment
     */
    select?: BillSplitPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitPayment
     */
    omit?: BillSplitPaymentOmit<ExtArgs> | null
    /**
     * The data used to create many BillSplitPayments.
     */
    data: BillSplitPaymentCreateManyInput | BillSplitPaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitPaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillSplitPayment update
   */
  export type BillSplitPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitPayment
     */
    select?: BillSplitPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitPayment
     */
    omit?: BillSplitPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a BillSplitPayment.
     */
    data: XOR<BillSplitPaymentUpdateInput, BillSplitPaymentUncheckedUpdateInput>
    /**
     * Choose, which BillSplitPayment to update.
     */
    where: BillSplitPaymentWhereUniqueInput
  }

  /**
   * BillSplitPayment updateMany
   */
  export type BillSplitPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BillSplitPayments.
     */
    data: XOR<BillSplitPaymentUpdateManyMutationInput, BillSplitPaymentUncheckedUpdateManyInput>
    /**
     * Filter which BillSplitPayments to update
     */
    where?: BillSplitPaymentWhereInput
    /**
     * Limit how many BillSplitPayments to update.
     */
    limit?: number
  }

  /**
   * BillSplitPayment updateManyAndReturn
   */
  export type BillSplitPaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitPayment
     */
    select?: BillSplitPaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitPayment
     */
    omit?: BillSplitPaymentOmit<ExtArgs> | null
    /**
     * The data used to update BillSplitPayments.
     */
    data: XOR<BillSplitPaymentUpdateManyMutationInput, BillSplitPaymentUncheckedUpdateManyInput>
    /**
     * Filter which BillSplitPayments to update
     */
    where?: BillSplitPaymentWhereInput
    /**
     * Limit how many BillSplitPayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitPaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillSplitPayment upsert
   */
  export type BillSplitPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitPayment
     */
    select?: BillSplitPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitPayment
     */
    omit?: BillSplitPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the BillSplitPayment to update in case it exists.
     */
    where: BillSplitPaymentWhereUniqueInput
    /**
     * In case the BillSplitPayment found by the `where` argument doesn't exist, create a new BillSplitPayment with this data.
     */
    create: XOR<BillSplitPaymentCreateInput, BillSplitPaymentUncheckedCreateInput>
    /**
     * In case the BillSplitPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillSplitPaymentUpdateInput, BillSplitPaymentUncheckedUpdateInput>
  }

  /**
   * BillSplitPayment delete
   */
  export type BillSplitPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitPayment
     */
    select?: BillSplitPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitPayment
     */
    omit?: BillSplitPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitPaymentInclude<ExtArgs> | null
    /**
     * Filter which BillSplitPayment to delete.
     */
    where: BillSplitPaymentWhereUniqueInput
  }

  /**
   * BillSplitPayment deleteMany
   */
  export type BillSplitPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillSplitPayments to delete
     */
    where?: BillSplitPaymentWhereInput
    /**
     * Limit how many BillSplitPayments to delete.
     */
    limit?: number
  }

  /**
   * BillSplitPayment.p2pTransfer
   */
  export type BillSplitPayment$p2pTransferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p2pTransfer
     */
    select?: p2pTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the p2pTransfer
     */
    omit?: p2pTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: p2pTransferInclude<ExtArgs> | null
    where?: p2pTransferWhereInput
  }

  /**
   * BillSplitPayment without action
   */
  export type BillSplitPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillSplitPayment
     */
    select?: BillSplitPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillSplitPayment
     */
    omit?: BillSplitPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillSplitPaymentInclude<ExtArgs> | null
  }


  /**
   * Model Balance
   */

  export type AggregateBalance = {
    _count: BalanceCountAggregateOutputType | null
    _avg: BalanceAvgAggregateOutputType | null
    _sum: BalanceSumAggregateOutputType | null
    _min: BalanceMinAggregateOutputType | null
    _max: BalanceMaxAggregateOutputType | null
  }

  export type BalanceAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: number | null
    locked: number | null
  }

  export type BalanceSumAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: number | null
    locked: number | null
  }

  export type BalanceMinAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: number | null
    locked: number | null
  }

  export type BalanceMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: number | null
    locked: number | null
  }

  export type BalanceCountAggregateOutputType = {
    id: number
    userId: number
    amount: number
    locked: number
    _all: number
  }


  export type BalanceAvgAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    locked?: true
  }

  export type BalanceSumAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    locked?: true
  }

  export type BalanceMinAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    locked?: true
  }

  export type BalanceMaxAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    locked?: true
  }

  export type BalanceCountAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    locked?: true
    _all?: true
  }

  export type BalanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Balance to aggregate.
     */
    where?: BalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Balances to fetch.
     */
    orderBy?: BalanceOrderByWithRelationInput | BalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Balances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Balances
    **/
    _count?: true | BalanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BalanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BalanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BalanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BalanceMaxAggregateInputType
  }

  export type GetBalanceAggregateType<T extends BalanceAggregateArgs> = {
        [P in keyof T & keyof AggregateBalance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBalance[P]>
      : GetScalarType<T[P], AggregateBalance[P]>
  }




  export type BalanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BalanceWhereInput
    orderBy?: BalanceOrderByWithAggregationInput | BalanceOrderByWithAggregationInput[]
    by: BalanceScalarFieldEnum[] | BalanceScalarFieldEnum
    having?: BalanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BalanceCountAggregateInputType | true
    _avg?: BalanceAvgAggregateInputType
    _sum?: BalanceSumAggregateInputType
    _min?: BalanceMinAggregateInputType
    _max?: BalanceMaxAggregateInputType
  }

  export type BalanceGroupByOutputType = {
    id: number
    userId: number
    amount: number
    locked: number
    _count: BalanceCountAggregateOutputType | null
    _avg: BalanceAvgAggregateOutputType | null
    _sum: BalanceSumAggregateOutputType | null
    _min: BalanceMinAggregateOutputType | null
    _max: BalanceMaxAggregateOutputType | null
  }

  type GetBalanceGroupByPayload<T extends BalanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BalanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BalanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BalanceGroupByOutputType[P]>
            : GetScalarType<T[P], BalanceGroupByOutputType[P]>
        }
      >
    >


  export type BalanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    locked?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["balance"]>

  export type BalanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    locked?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["balance"]>

  export type BalanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    locked?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["balance"]>

  export type BalanceSelectScalar = {
    id?: boolean
    userId?: boolean
    amount?: boolean
    locked?: boolean
  }

  export type BalanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "amount" | "locked", ExtArgs["result"]["balance"]>
  export type BalanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BalanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BalanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BalancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Balance"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      amount: number
      locked: number
    }, ExtArgs["result"]["balance"]>
    composites: {}
  }

  type BalanceGetPayload<S extends boolean | null | undefined | BalanceDefaultArgs> = $Result.GetResult<Prisma.$BalancePayload, S>

  type BalanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BalanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BalanceCountAggregateInputType | true
    }

  export interface BalanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Balance'], meta: { name: 'Balance' } }
    /**
     * Find zero or one Balance that matches the filter.
     * @param {BalanceFindUniqueArgs} args - Arguments to find a Balance
     * @example
     * // Get one Balance
     * const balance = await prisma.balance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BalanceFindUniqueArgs>(args: SelectSubset<T, BalanceFindUniqueArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Balance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BalanceFindUniqueOrThrowArgs} args - Arguments to find a Balance
     * @example
     * // Get one Balance
     * const balance = await prisma.balance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BalanceFindUniqueOrThrowArgs>(args: SelectSubset<T, BalanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Balance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceFindFirstArgs} args - Arguments to find a Balance
     * @example
     * // Get one Balance
     * const balance = await prisma.balance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BalanceFindFirstArgs>(args?: SelectSubset<T, BalanceFindFirstArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Balance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceFindFirstOrThrowArgs} args - Arguments to find a Balance
     * @example
     * // Get one Balance
     * const balance = await prisma.balance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BalanceFindFirstOrThrowArgs>(args?: SelectSubset<T, BalanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Balances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Balances
     * const balances = await prisma.balance.findMany()
     * 
     * // Get first 10 Balances
     * const balances = await prisma.balance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const balanceWithIdOnly = await prisma.balance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BalanceFindManyArgs>(args?: SelectSubset<T, BalanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Balance.
     * @param {BalanceCreateArgs} args - Arguments to create a Balance.
     * @example
     * // Create one Balance
     * const Balance = await prisma.balance.create({
     *   data: {
     *     // ... data to create a Balance
     *   }
     * })
     * 
     */
    create<T extends BalanceCreateArgs>(args: SelectSubset<T, BalanceCreateArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Balances.
     * @param {BalanceCreateManyArgs} args - Arguments to create many Balances.
     * @example
     * // Create many Balances
     * const balance = await prisma.balance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BalanceCreateManyArgs>(args?: SelectSubset<T, BalanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Balances and returns the data saved in the database.
     * @param {BalanceCreateManyAndReturnArgs} args - Arguments to create many Balances.
     * @example
     * // Create many Balances
     * const balance = await prisma.balance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Balances and only return the `id`
     * const balanceWithIdOnly = await prisma.balance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BalanceCreateManyAndReturnArgs>(args?: SelectSubset<T, BalanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Balance.
     * @param {BalanceDeleteArgs} args - Arguments to delete one Balance.
     * @example
     * // Delete one Balance
     * const Balance = await prisma.balance.delete({
     *   where: {
     *     // ... filter to delete one Balance
     *   }
     * })
     * 
     */
    delete<T extends BalanceDeleteArgs>(args: SelectSubset<T, BalanceDeleteArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Balance.
     * @param {BalanceUpdateArgs} args - Arguments to update one Balance.
     * @example
     * // Update one Balance
     * const balance = await prisma.balance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BalanceUpdateArgs>(args: SelectSubset<T, BalanceUpdateArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Balances.
     * @param {BalanceDeleteManyArgs} args - Arguments to filter Balances to delete.
     * @example
     * // Delete a few Balances
     * const { count } = await prisma.balance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BalanceDeleteManyArgs>(args?: SelectSubset<T, BalanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Balances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Balances
     * const balance = await prisma.balance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BalanceUpdateManyArgs>(args: SelectSubset<T, BalanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Balances and returns the data updated in the database.
     * @param {BalanceUpdateManyAndReturnArgs} args - Arguments to update many Balances.
     * @example
     * // Update many Balances
     * const balance = await prisma.balance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Balances and only return the `id`
     * const balanceWithIdOnly = await prisma.balance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BalanceUpdateManyAndReturnArgs>(args: SelectSubset<T, BalanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Balance.
     * @param {BalanceUpsertArgs} args - Arguments to update or create a Balance.
     * @example
     * // Update or create a Balance
     * const balance = await prisma.balance.upsert({
     *   create: {
     *     // ... data to create a Balance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Balance we want to update
     *   }
     * })
     */
    upsert<T extends BalanceUpsertArgs>(args: SelectSubset<T, BalanceUpsertArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Balances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceCountArgs} args - Arguments to filter Balances to count.
     * @example
     * // Count the number of Balances
     * const count = await prisma.balance.count({
     *   where: {
     *     // ... the filter for the Balances we want to count
     *   }
     * })
    **/
    count<T extends BalanceCountArgs>(
      args?: Subset<T, BalanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BalanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Balance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BalanceAggregateArgs>(args: Subset<T, BalanceAggregateArgs>): Prisma.PrismaPromise<GetBalanceAggregateType<T>>

    /**
     * Group by Balance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BalanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BalanceGroupByArgs['orderBy'] }
        : { orderBy?: BalanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BalanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBalanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Balance model
   */
  readonly fields: BalanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Balance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BalanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Balance model
   */
  interface BalanceFieldRefs {
    readonly id: FieldRef<"Balance", 'Int'>
    readonly userId: FieldRef<"Balance", 'Int'>
    readonly amount: FieldRef<"Balance", 'Int'>
    readonly locked: FieldRef<"Balance", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Balance findUnique
   */
  export type BalanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * Filter, which Balance to fetch.
     */
    where: BalanceWhereUniqueInput
  }

  /**
   * Balance findUniqueOrThrow
   */
  export type BalanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * Filter, which Balance to fetch.
     */
    where: BalanceWhereUniqueInput
  }

  /**
   * Balance findFirst
   */
  export type BalanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * Filter, which Balance to fetch.
     */
    where?: BalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Balances to fetch.
     */
    orderBy?: BalanceOrderByWithRelationInput | BalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Balances.
     */
    cursor?: BalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Balances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Balances.
     */
    distinct?: BalanceScalarFieldEnum | BalanceScalarFieldEnum[]
  }

  /**
   * Balance findFirstOrThrow
   */
  export type BalanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * Filter, which Balance to fetch.
     */
    where?: BalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Balances to fetch.
     */
    orderBy?: BalanceOrderByWithRelationInput | BalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Balances.
     */
    cursor?: BalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Balances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Balances.
     */
    distinct?: BalanceScalarFieldEnum | BalanceScalarFieldEnum[]
  }

  /**
   * Balance findMany
   */
  export type BalanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * Filter, which Balances to fetch.
     */
    where?: BalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Balances to fetch.
     */
    orderBy?: BalanceOrderByWithRelationInput | BalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Balances.
     */
    cursor?: BalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Balances.
     */
    skip?: number
    distinct?: BalanceScalarFieldEnum | BalanceScalarFieldEnum[]
  }

  /**
   * Balance create
   */
  export type BalanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Balance.
     */
    data: XOR<BalanceCreateInput, BalanceUncheckedCreateInput>
  }

  /**
   * Balance createMany
   */
  export type BalanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Balances.
     */
    data: BalanceCreateManyInput | BalanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Balance createManyAndReturn
   */
  export type BalanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * The data used to create many Balances.
     */
    data: BalanceCreateManyInput | BalanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Balance update
   */
  export type BalanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Balance.
     */
    data: XOR<BalanceUpdateInput, BalanceUncheckedUpdateInput>
    /**
     * Choose, which Balance to update.
     */
    where: BalanceWhereUniqueInput
  }

  /**
   * Balance updateMany
   */
  export type BalanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Balances.
     */
    data: XOR<BalanceUpdateManyMutationInput, BalanceUncheckedUpdateManyInput>
    /**
     * Filter which Balances to update
     */
    where?: BalanceWhereInput
    /**
     * Limit how many Balances to update.
     */
    limit?: number
  }

  /**
   * Balance updateManyAndReturn
   */
  export type BalanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * The data used to update Balances.
     */
    data: XOR<BalanceUpdateManyMutationInput, BalanceUncheckedUpdateManyInput>
    /**
     * Filter which Balances to update
     */
    where?: BalanceWhereInput
    /**
     * Limit how many Balances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Balance upsert
   */
  export type BalanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Balance to update in case it exists.
     */
    where: BalanceWhereUniqueInput
    /**
     * In case the Balance found by the `where` argument doesn't exist, create a new Balance with this data.
     */
    create: XOR<BalanceCreateInput, BalanceUncheckedCreateInput>
    /**
     * In case the Balance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BalanceUpdateInput, BalanceUncheckedUpdateInput>
  }

  /**
   * Balance delete
   */
  export type BalanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * Filter which Balance to delete.
     */
    where: BalanceWhereUniqueInput
  }

  /**
   * Balance deleteMany
   */
  export type BalanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Balances to delete
     */
    where?: BalanceWhereInput
    /**
     * Limit how many Balances to delete.
     */
    limit?: number
  }

  /**
   * Balance without action
   */
  export type BalanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    number: 'number',
    password: 'password',
    sessionToken: 'sessionToken',
    image: 'image',
    userpin: 'userpin',
    resetOtp: 'resetOtp',
    resetExpires: 'resetExpires'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const P2pTransferScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    timestamp: 'timestamp',
    fromUserId: 'fromUserId',
    toUserId: 'toUserId',
    receiverNumber: 'receiverNumber',
    status: 'status',
    razorpayPaymentId: 'razorpayPaymentId',
    paymentMethod: 'paymentMethod',
    deviceInfo: 'deviceInfo',
    ipAddress: 'ipAddress',
    merchantId: 'merchantId',
    latitude: 'latitude',
    longitude: 'longitude',
    isFraud: 'isFraud',
    fraudScore: 'fraudScore',
    fraudReason: 'fraudReason',
    riskLevel: 'riskLevel'
  };

  export type P2pTransferScalarFieldEnum = (typeof P2pTransferScalarFieldEnum)[keyof typeof P2pTransferScalarFieldEnum]


  export const FraudLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    transactionId: 'transactionId',
    score: 'score',
    reason: 'reason',
    blocked: 'blocked',
    createdAt: 'createdAt'
  };

  export type FraudLogScalarFieldEnum = (typeof FraudLogScalarFieldEnum)[keyof typeof FraudLogScalarFieldEnum]


  export const MerchantScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    upiId: 'upiId',
    auth_type: 'auth_type'
  };

  export type MerchantScalarFieldEnum = (typeof MerchantScalarFieldEnum)[keyof typeof MerchantScalarFieldEnum]


  export const MerchantPaymentScalarFieldEnum: {
    id: 'id',
    merchantId: 'merchantId',
    qrId: 'qrId',
    amount: 'amount',
    status: 'status',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    transactionId: 'transactionId'
  };

  export type MerchantPaymentScalarFieldEnum = (typeof MerchantPaymentScalarFieldEnum)[keyof typeof MerchantPaymentScalarFieldEnum]


  export const OnRampTransactionScalarFieldEnum: {
    id: 'id',
    status: 'status',
    token: 'token',
    provider: 'provider',
    amount: 'amount',
    startTime: 'startTime',
    transactionId: 'transactionId',
    userId: 'userId'
  };

  export type OnRampTransactionScalarFieldEnum = (typeof OnRampTransactionScalarFieldEnum)[keyof typeof OnRampTransactionScalarFieldEnum]


  export const P2PRequestScalarFieldEnum: {
    id: 'id',
    senderId: 'senderId',
    receiverId: 'receiverId',
    receiverNumber: 'receiverNumber',
    amount: 'amount',
    message: 'message',
    status: 'status',
    createdAt: 'createdAt',
    settledAt: 'settledAt',
    billSplitMemberId: 'billSplitMemberId'
  };

  export type P2PRequestScalarFieldEnum = (typeof P2PRequestScalarFieldEnum)[keyof typeof P2PRequestScalarFieldEnum]


  export const BillScheduleScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    merchantId: 'merchantId',
    billType: 'billType',
    provider: 'provider',
    accountNo: 'accountNo',
    amount: 'amount',
    dueDate: 'dueDate',
    nextPayment: 'nextPayment',
    createdAt: 'createdAt',
    paymentMethod: 'paymentMethod',
    status: 'status',
    token: 'token'
  };

  export type BillScheduleScalarFieldEnum = (typeof BillScheduleScalarFieldEnum)[keyof typeof BillScheduleScalarFieldEnum]


  export const RechargePlanScalarFieldEnum: {
    id: 'id',
    operator: 'operator',
    circle: 'circle',
    planCode: 'planCode',
    amount: 'amount',
    planType: 'planType',
    validity: 'validity',
    data: 'data',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RechargePlanScalarFieldEnum = (typeof RechargePlanScalarFieldEnum)[keyof typeof RechargePlanScalarFieldEnum]


  export const RechargeOrderScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    planId: 'planId',
    mobileNumber: 'mobileNumber',
    operator: 'operator',
    circle: 'circle',
    amount: 'amount',
    status: 'status',
    providerTxnId: 'providerTxnId',
    orderId: 'orderId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RechargeOrderScalarFieldEnum = (typeof RechargeOrderScalarFieldEnum)[keyof typeof RechargeOrderScalarFieldEnum]


  export const RewardScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    amount: 'amount',
    status: 'status',
    earnedAt: 'earnedAt',
    expiresAt: 'expiresAt',
    metadata: 'metadata',
    billSplitGroupId: 'billSplitGroupId'
  };

  export type RewardScalarFieldEnum = (typeof RewardScalarFieldEnum)[keyof typeof RewardScalarFieldEnum]


  export const ReferralScalarFieldEnum: {
    id: 'id',
    referrerId: 'referrerId',
    referredUserId: 'referredUserId',
    referralCode: 'referralCode'
  };

  export type ReferralScalarFieldEnum = (typeof ReferralScalarFieldEnum)[keyof typeof ReferralScalarFieldEnum]


  export const WrongSendRequestScalarFieldEnum: {
    id: 'id',
    txnId: 'txnId',
    senderId: 'senderId',
    receiverNumber: 'receiverNumber',
    amount: 'amount',
    status: 'status',
    expiresAt: 'expiresAt',
    penaltyPaid: 'penaltyPaid',
    razorpayRefundId: 'razorpayRefundId',
    createdAt: 'createdAt'
  };

  export type WrongSendRequestScalarFieldEnum = (typeof WrongSendRequestScalarFieldEnum)[keyof typeof WrongSendRequestScalarFieldEnum]


  export const BillSplitGroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    totalAmount: 'totalAmount',
    currency: 'currency',
    createdById: 'createdById',
    createdAt: 'createdAt',
    settledAt: 'settledAt',
    status: 'status'
  };

  export type BillSplitGroupScalarFieldEnum = (typeof BillSplitGroupScalarFieldEnum)[keyof typeof BillSplitGroupScalarFieldEnum]


  export const BillSplitMemberScalarFieldEnum: {
    id: 'id',
    groupId: 'groupId',
    userId: 'userId',
    phone: 'phone',
    name: 'name',
    share: 'share',
    paid: 'paid',
    paidAt: 'paidAt',
    paidAmount: 'paidAmount'
  };

  export type BillSplitMemberScalarFieldEnum = (typeof BillSplitMemberScalarFieldEnum)[keyof typeof BillSplitMemberScalarFieldEnum]


  export const BillSplitPaymentScalarFieldEnum: {
    id: 'id',
    groupId: 'groupId',
    memberId: 'memberId',
    p2pTransferId: 'p2pTransferId',
    amount: 'amount',
    paidAt: 'paidAt'
  };

  export type BillSplitPaymentScalarFieldEnum = (typeof BillSplitPaymentScalarFieldEnum)[keyof typeof BillSplitPaymentScalarFieldEnum]


  export const BalanceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    amount: 'amount',
    locked: 'locked'
  };

  export type BalanceScalarFieldEnum = (typeof BalanceScalarFieldEnum)[keyof typeof BalanceScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'AuthType'
   */
  export type EnumAuthTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthType'>
    


  /**
   * Reference to a field of type 'AuthType[]'
   */
  export type ListEnumAuthTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthType[]'>
    


  /**
   * Reference to a field of type 'OnRampStatus'
   */
  export type EnumOnRampStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OnRampStatus'>
    


  /**
   * Reference to a field of type 'OnRampStatus[]'
   */
  export type ListEnumOnRampStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OnRampStatus[]'>
    


  /**
   * Reference to a field of type 'P2PRequestStatus'
   */
  export type EnumP2PRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'P2PRequestStatus'>
    


  /**
   * Reference to a field of type 'P2PRequestStatus[]'
   */
  export type ListEnumP2PRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'P2PRequestStatus[]'>
    


  /**
   * Reference to a field of type 'RewardType'
   */
  export type EnumRewardTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RewardType'>
    


  /**
   * Reference to a field of type 'RewardType[]'
   */
  export type ListEnumRewardTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RewardType[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'RewardStatus'
   */
  export type EnumRewardStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RewardStatus'>
    


  /**
   * Reference to a field of type 'RewardStatus[]'
   */
  export type ListEnumRewardStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RewardStatus[]'>
    


  /**
   * Reference to a field of type 'WrongSendStatus'
   */
  export type EnumWrongSendStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WrongSendStatus'>
    


  /**
   * Reference to a field of type 'WrongSendStatus[]'
   */
  export type ListEnumWrongSendStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WrongSendStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    number?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    sessionToken?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    userpin?: StringFilter<"User"> | string
    resetOtp?: StringNullableFilter<"User"> | string | null
    resetExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    OnRampTransaction?: OnRampTransactionListRelationFilter
    Balance?: BalanceListRelationFilter
    sentTransfers?: P2pTransferListRelationFilter
    receivedTransfers?: P2pTransferListRelationFilter
    sentRequests?: P2PRequestListRelationFilter
    receivedRequests?: P2PRequestListRelationFilter
    billSchedules?: BillScheduleListRelationFilter
    merchantPayments?: MerchantPaymentListRelationFilter
    rechargeOrders?: RechargeOrderListRelationFilter
    rewards?: RewardListRelationFilter
    referralsAsReferrer?: ReferralListRelationFilter
    referralsAsReferred?: ReferralListRelationFilter
    wrongSendRequests?: WrongSendRequestListRelationFilter
    createdGroups?: BillSplitGroupListRelationFilter
    billSplitMembers?: BillSplitMemberListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    number?: SortOrder
    password?: SortOrder
    sessionToken?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    userpin?: SortOrder
    resetOtp?: SortOrderInput | SortOrder
    resetExpires?: SortOrderInput | SortOrder
    OnRampTransaction?: OnRampTransactionOrderByRelationAggregateInput
    Balance?: BalanceOrderByRelationAggregateInput
    sentTransfers?: p2pTransferOrderByRelationAggregateInput
    receivedTransfers?: p2pTransferOrderByRelationAggregateInput
    sentRequests?: P2PRequestOrderByRelationAggregateInput
    receivedRequests?: P2PRequestOrderByRelationAggregateInput
    billSchedules?: BillScheduleOrderByRelationAggregateInput
    merchantPayments?: MerchantPaymentOrderByRelationAggregateInput
    rechargeOrders?: RechargeOrderOrderByRelationAggregateInput
    rewards?: RewardOrderByRelationAggregateInput
    referralsAsReferrer?: ReferralOrderByRelationAggregateInput
    referralsAsReferred?: ReferralOrderByRelationAggregateInput
    wrongSendRequests?: WrongSendRequestOrderByRelationAggregateInput
    createdGroups?: BillSplitGroupOrderByRelationAggregateInput
    billSplitMembers?: BillSplitMemberOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    number?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    sessionToken?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    userpin?: StringFilter<"User"> | string
    resetOtp?: StringNullableFilter<"User"> | string | null
    resetExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    OnRampTransaction?: OnRampTransactionListRelationFilter
    Balance?: BalanceListRelationFilter
    sentTransfers?: P2pTransferListRelationFilter
    receivedTransfers?: P2pTransferListRelationFilter
    sentRequests?: P2PRequestListRelationFilter
    receivedRequests?: P2PRequestListRelationFilter
    billSchedules?: BillScheduleListRelationFilter
    merchantPayments?: MerchantPaymentListRelationFilter
    rechargeOrders?: RechargeOrderListRelationFilter
    rewards?: RewardListRelationFilter
    referralsAsReferrer?: ReferralListRelationFilter
    referralsAsReferred?: ReferralListRelationFilter
    wrongSendRequests?: WrongSendRequestListRelationFilter
    createdGroups?: BillSplitGroupListRelationFilter
    billSplitMembers?: BillSplitMemberListRelationFilter
  }, "id" | "email" | "number">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    number?: SortOrder
    password?: SortOrder
    sessionToken?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    userpin?: SortOrder
    resetOtp?: SortOrderInput | SortOrder
    resetExpires?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    number?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    sessionToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    userpin?: StringWithAggregatesFilter<"User"> | string
    resetOtp?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type p2pTransferWhereInput = {
    AND?: p2pTransferWhereInput | p2pTransferWhereInput[]
    OR?: p2pTransferWhereInput[]
    NOT?: p2pTransferWhereInput | p2pTransferWhereInput[]
    id?: IntFilter<"p2pTransfer"> | number
    amount?: IntFilter<"p2pTransfer"> | number
    timestamp?: DateTimeFilter<"p2pTransfer"> | Date | string
    fromUserId?: IntFilter<"p2pTransfer"> | number
    toUserId?: IntNullableFilter<"p2pTransfer"> | number | null
    receiverNumber?: StringNullableFilter<"p2pTransfer"> | string | null
    status?: StringFilter<"p2pTransfer"> | string
    razorpayPaymentId?: StringNullableFilter<"p2pTransfer"> | string | null
    paymentMethod?: StringFilter<"p2pTransfer"> | string
    deviceInfo?: JsonNullableFilter<"p2pTransfer">
    ipAddress?: StringNullableFilter<"p2pTransfer"> | string | null
    merchantId?: IntNullableFilter<"p2pTransfer"> | number | null
    latitude?: FloatNullableFilter<"p2pTransfer"> | number | null
    longitude?: FloatNullableFilter<"p2pTransfer"> | number | null
    isFraud?: BoolNullableFilter<"p2pTransfer"> | boolean | null
    fraudScore?: FloatNullableFilter<"p2pTransfer"> | number | null
    fraudReason?: StringNullableFilter<"p2pTransfer"> | string | null
    riskLevel?: StringNullableFilter<"p2pTransfer"> | string | null
    fromUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    toUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    wrongSendRequest?: XOR<WrongSendRequestNullableScalarRelationFilter, WrongSendRequestWhereInput> | null
    billSplitPayment?: XOR<BillSplitPaymentNullableScalarRelationFilter, BillSplitPaymentWhereInput> | null
  }

  export type p2pTransferOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    timestamp?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrderInput | SortOrder
    receiverNumber?: SortOrderInput | SortOrder
    status?: SortOrder
    razorpayPaymentId?: SortOrderInput | SortOrder
    paymentMethod?: SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    merchantId?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    isFraud?: SortOrderInput | SortOrder
    fraudScore?: SortOrderInput | SortOrder
    fraudReason?: SortOrderInput | SortOrder
    riskLevel?: SortOrderInput | SortOrder
    fromUser?: UserOrderByWithRelationInput
    toUser?: UserOrderByWithRelationInput
    wrongSendRequest?: WrongSendRequestOrderByWithRelationInput
    billSplitPayment?: BillSplitPaymentOrderByWithRelationInput
  }

  export type p2pTransferWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    razorpayPaymentId?: string
    AND?: p2pTransferWhereInput | p2pTransferWhereInput[]
    OR?: p2pTransferWhereInput[]
    NOT?: p2pTransferWhereInput | p2pTransferWhereInput[]
    amount?: IntFilter<"p2pTransfer"> | number
    timestamp?: DateTimeFilter<"p2pTransfer"> | Date | string
    fromUserId?: IntFilter<"p2pTransfer"> | number
    toUserId?: IntNullableFilter<"p2pTransfer"> | number | null
    receiverNumber?: StringNullableFilter<"p2pTransfer"> | string | null
    status?: StringFilter<"p2pTransfer"> | string
    paymentMethod?: StringFilter<"p2pTransfer"> | string
    deviceInfo?: JsonNullableFilter<"p2pTransfer">
    ipAddress?: StringNullableFilter<"p2pTransfer"> | string | null
    merchantId?: IntNullableFilter<"p2pTransfer"> | number | null
    latitude?: FloatNullableFilter<"p2pTransfer"> | number | null
    longitude?: FloatNullableFilter<"p2pTransfer"> | number | null
    isFraud?: BoolNullableFilter<"p2pTransfer"> | boolean | null
    fraudScore?: FloatNullableFilter<"p2pTransfer"> | number | null
    fraudReason?: StringNullableFilter<"p2pTransfer"> | string | null
    riskLevel?: StringNullableFilter<"p2pTransfer"> | string | null
    fromUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    toUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    wrongSendRequest?: XOR<WrongSendRequestNullableScalarRelationFilter, WrongSendRequestWhereInput> | null
    billSplitPayment?: XOR<BillSplitPaymentNullableScalarRelationFilter, BillSplitPaymentWhereInput> | null
  }, "id" | "razorpayPaymentId">

  export type p2pTransferOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    timestamp?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrderInput | SortOrder
    receiverNumber?: SortOrderInput | SortOrder
    status?: SortOrder
    razorpayPaymentId?: SortOrderInput | SortOrder
    paymentMethod?: SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    merchantId?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    isFraud?: SortOrderInput | SortOrder
    fraudScore?: SortOrderInput | SortOrder
    fraudReason?: SortOrderInput | SortOrder
    riskLevel?: SortOrderInput | SortOrder
    _count?: p2pTransferCountOrderByAggregateInput
    _avg?: p2pTransferAvgOrderByAggregateInput
    _max?: p2pTransferMaxOrderByAggregateInput
    _min?: p2pTransferMinOrderByAggregateInput
    _sum?: p2pTransferSumOrderByAggregateInput
  }

  export type p2pTransferScalarWhereWithAggregatesInput = {
    AND?: p2pTransferScalarWhereWithAggregatesInput | p2pTransferScalarWhereWithAggregatesInput[]
    OR?: p2pTransferScalarWhereWithAggregatesInput[]
    NOT?: p2pTransferScalarWhereWithAggregatesInput | p2pTransferScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"p2pTransfer"> | number
    amount?: IntWithAggregatesFilter<"p2pTransfer"> | number
    timestamp?: DateTimeWithAggregatesFilter<"p2pTransfer"> | Date | string
    fromUserId?: IntWithAggregatesFilter<"p2pTransfer"> | number
    toUserId?: IntNullableWithAggregatesFilter<"p2pTransfer"> | number | null
    receiverNumber?: StringNullableWithAggregatesFilter<"p2pTransfer"> | string | null
    status?: StringWithAggregatesFilter<"p2pTransfer"> | string
    razorpayPaymentId?: StringNullableWithAggregatesFilter<"p2pTransfer"> | string | null
    paymentMethod?: StringWithAggregatesFilter<"p2pTransfer"> | string
    deviceInfo?: JsonNullableWithAggregatesFilter<"p2pTransfer">
    ipAddress?: StringNullableWithAggregatesFilter<"p2pTransfer"> | string | null
    merchantId?: IntNullableWithAggregatesFilter<"p2pTransfer"> | number | null
    latitude?: FloatNullableWithAggregatesFilter<"p2pTransfer"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"p2pTransfer"> | number | null
    isFraud?: BoolNullableWithAggregatesFilter<"p2pTransfer"> | boolean | null
    fraudScore?: FloatNullableWithAggregatesFilter<"p2pTransfer"> | number | null
    fraudReason?: StringNullableWithAggregatesFilter<"p2pTransfer"> | string | null
    riskLevel?: StringNullableWithAggregatesFilter<"p2pTransfer"> | string | null
  }

  export type FraudLogWhereInput = {
    AND?: FraudLogWhereInput | FraudLogWhereInput[]
    OR?: FraudLogWhereInput[]
    NOT?: FraudLogWhereInput | FraudLogWhereInput[]
    id?: IntFilter<"FraudLog"> | number
    userId?: IntFilter<"FraudLog"> | number
    transactionId?: IntNullableFilter<"FraudLog"> | number | null
    score?: FloatFilter<"FraudLog"> | number
    reason?: StringFilter<"FraudLog"> | string
    blocked?: BoolFilter<"FraudLog"> | boolean
    createdAt?: DateTimeFilter<"FraudLog"> | Date | string
  }

  export type FraudLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    score?: SortOrder
    reason?: SortOrder
    blocked?: SortOrder
    createdAt?: SortOrder
  }

  export type FraudLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FraudLogWhereInput | FraudLogWhereInput[]
    OR?: FraudLogWhereInput[]
    NOT?: FraudLogWhereInput | FraudLogWhereInput[]
    userId?: IntFilter<"FraudLog"> | number
    transactionId?: IntNullableFilter<"FraudLog"> | number | null
    score?: FloatFilter<"FraudLog"> | number
    reason?: StringFilter<"FraudLog"> | string
    blocked?: BoolFilter<"FraudLog"> | boolean
    createdAt?: DateTimeFilter<"FraudLog"> | Date | string
  }, "id">

  export type FraudLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    score?: SortOrder
    reason?: SortOrder
    blocked?: SortOrder
    createdAt?: SortOrder
    _count?: FraudLogCountOrderByAggregateInput
    _avg?: FraudLogAvgOrderByAggregateInput
    _max?: FraudLogMaxOrderByAggregateInput
    _min?: FraudLogMinOrderByAggregateInput
    _sum?: FraudLogSumOrderByAggregateInput
  }

  export type FraudLogScalarWhereWithAggregatesInput = {
    AND?: FraudLogScalarWhereWithAggregatesInput | FraudLogScalarWhereWithAggregatesInput[]
    OR?: FraudLogScalarWhereWithAggregatesInput[]
    NOT?: FraudLogScalarWhereWithAggregatesInput | FraudLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FraudLog"> | number
    userId?: IntWithAggregatesFilter<"FraudLog"> | number
    transactionId?: IntNullableWithAggregatesFilter<"FraudLog"> | number | null
    score?: FloatWithAggregatesFilter<"FraudLog"> | number
    reason?: StringWithAggregatesFilter<"FraudLog"> | string
    blocked?: BoolWithAggregatesFilter<"FraudLog"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"FraudLog"> | Date | string
  }

  export type MerchantWhereInput = {
    AND?: MerchantWhereInput | MerchantWhereInput[]
    OR?: MerchantWhereInput[]
    NOT?: MerchantWhereInput | MerchantWhereInput[]
    id?: IntFilter<"Merchant"> | number
    email?: StringFilter<"Merchant"> | string
    name?: StringNullableFilter<"Merchant"> | string | null
    upiId?: StringNullableFilter<"Merchant"> | string | null
    auth_type?: EnumAuthTypeFilter<"Merchant"> | $Enums.AuthType
    billSchedules?: BillScheduleListRelationFilter
    payments?: MerchantPaymentListRelationFilter
  }

  export type MerchantOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    upiId?: SortOrderInput | SortOrder
    auth_type?: SortOrder
    billSchedules?: BillScheduleOrderByRelationAggregateInput
    payments?: MerchantPaymentOrderByRelationAggregateInput
  }

  export type MerchantWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    upiId?: string
    AND?: MerchantWhereInput | MerchantWhereInput[]
    OR?: MerchantWhereInput[]
    NOT?: MerchantWhereInput | MerchantWhereInput[]
    name?: StringNullableFilter<"Merchant"> | string | null
    auth_type?: EnumAuthTypeFilter<"Merchant"> | $Enums.AuthType
    billSchedules?: BillScheduleListRelationFilter
    payments?: MerchantPaymentListRelationFilter
  }, "id" | "email" | "upiId">

  export type MerchantOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    upiId?: SortOrderInput | SortOrder
    auth_type?: SortOrder
    _count?: MerchantCountOrderByAggregateInput
    _avg?: MerchantAvgOrderByAggregateInput
    _max?: MerchantMaxOrderByAggregateInput
    _min?: MerchantMinOrderByAggregateInput
    _sum?: MerchantSumOrderByAggregateInput
  }

  export type MerchantScalarWhereWithAggregatesInput = {
    AND?: MerchantScalarWhereWithAggregatesInput | MerchantScalarWhereWithAggregatesInput[]
    OR?: MerchantScalarWhereWithAggregatesInput[]
    NOT?: MerchantScalarWhereWithAggregatesInput | MerchantScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Merchant"> | number
    email?: StringWithAggregatesFilter<"Merchant"> | string
    name?: StringNullableWithAggregatesFilter<"Merchant"> | string | null
    upiId?: StringNullableWithAggregatesFilter<"Merchant"> | string | null
    auth_type?: EnumAuthTypeWithAggregatesFilter<"Merchant"> | $Enums.AuthType
  }

  export type MerchantPaymentWhereInput = {
    AND?: MerchantPaymentWhereInput | MerchantPaymentWhereInput[]
    OR?: MerchantPaymentWhereInput[]
    NOT?: MerchantPaymentWhereInput | MerchantPaymentWhereInput[]
    id?: IntFilter<"MerchantPayment"> | number
    merchantId?: IntFilter<"MerchantPayment"> | number
    qrId?: StringFilter<"MerchantPayment"> | string
    amount?: IntFilter<"MerchantPayment"> | number
    status?: StringFilter<"MerchantPayment"> | string
    userId?: IntNullableFilter<"MerchantPayment"> | number | null
    createdAt?: DateTimeFilter<"MerchantPayment"> | Date | string
    updatedAt?: DateTimeFilter<"MerchantPayment"> | Date | string
    transactionId?: StringNullableFilter<"MerchantPayment"> | string | null
    merchant?: XOR<MerchantScalarRelationFilter, MerchantWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type MerchantPaymentOrderByWithRelationInput = {
    id?: SortOrder
    merchantId?: SortOrder
    qrId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    merchant?: MerchantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type MerchantPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    qrId?: string
    transactionId?: string
    AND?: MerchantPaymentWhereInput | MerchantPaymentWhereInput[]
    OR?: MerchantPaymentWhereInput[]
    NOT?: MerchantPaymentWhereInput | MerchantPaymentWhereInput[]
    merchantId?: IntFilter<"MerchantPayment"> | number
    amount?: IntFilter<"MerchantPayment"> | number
    status?: StringFilter<"MerchantPayment"> | string
    userId?: IntNullableFilter<"MerchantPayment"> | number | null
    createdAt?: DateTimeFilter<"MerchantPayment"> | Date | string
    updatedAt?: DateTimeFilter<"MerchantPayment"> | Date | string
    merchant?: XOR<MerchantScalarRelationFilter, MerchantWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "qrId" | "transactionId">

  export type MerchantPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    merchantId?: SortOrder
    qrId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    _count?: MerchantPaymentCountOrderByAggregateInput
    _avg?: MerchantPaymentAvgOrderByAggregateInput
    _max?: MerchantPaymentMaxOrderByAggregateInput
    _min?: MerchantPaymentMinOrderByAggregateInput
    _sum?: MerchantPaymentSumOrderByAggregateInput
  }

  export type MerchantPaymentScalarWhereWithAggregatesInput = {
    AND?: MerchantPaymentScalarWhereWithAggregatesInput | MerchantPaymentScalarWhereWithAggregatesInput[]
    OR?: MerchantPaymentScalarWhereWithAggregatesInput[]
    NOT?: MerchantPaymentScalarWhereWithAggregatesInput | MerchantPaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MerchantPayment"> | number
    merchantId?: IntWithAggregatesFilter<"MerchantPayment"> | number
    qrId?: StringWithAggregatesFilter<"MerchantPayment"> | string
    amount?: IntWithAggregatesFilter<"MerchantPayment"> | number
    status?: StringWithAggregatesFilter<"MerchantPayment"> | string
    userId?: IntNullableWithAggregatesFilter<"MerchantPayment"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"MerchantPayment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MerchantPayment"> | Date | string
    transactionId?: StringNullableWithAggregatesFilter<"MerchantPayment"> | string | null
  }

  export type OnRampTransactionWhereInput = {
    AND?: OnRampTransactionWhereInput | OnRampTransactionWhereInput[]
    OR?: OnRampTransactionWhereInput[]
    NOT?: OnRampTransactionWhereInput | OnRampTransactionWhereInput[]
    id?: IntFilter<"OnRampTransaction"> | number
    status?: EnumOnRampStatusFilter<"OnRampTransaction"> | $Enums.OnRampStatus
    token?: StringFilter<"OnRampTransaction"> | string
    provider?: StringFilter<"OnRampTransaction"> | string
    amount?: IntFilter<"OnRampTransaction"> | number
    startTime?: DateTimeFilter<"OnRampTransaction"> | Date | string
    transactionId?: StringNullableFilter<"OnRampTransaction"> | string | null
    userId?: IntFilter<"OnRampTransaction"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type OnRampTransactionOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    token?: SortOrder
    provider?: SortOrder
    amount?: SortOrder
    startTime?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type OnRampTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    transactionId?: string
    AND?: OnRampTransactionWhereInput | OnRampTransactionWhereInput[]
    OR?: OnRampTransactionWhereInput[]
    NOT?: OnRampTransactionWhereInput | OnRampTransactionWhereInput[]
    status?: EnumOnRampStatusFilter<"OnRampTransaction"> | $Enums.OnRampStatus
    provider?: StringFilter<"OnRampTransaction"> | string
    amount?: IntFilter<"OnRampTransaction"> | number
    startTime?: DateTimeFilter<"OnRampTransaction"> | Date | string
    userId?: IntFilter<"OnRampTransaction"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token" | "transactionId">

  export type OnRampTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    token?: SortOrder
    provider?: SortOrder
    amount?: SortOrder
    startTime?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: OnRampTransactionCountOrderByAggregateInput
    _avg?: OnRampTransactionAvgOrderByAggregateInput
    _max?: OnRampTransactionMaxOrderByAggregateInput
    _min?: OnRampTransactionMinOrderByAggregateInput
    _sum?: OnRampTransactionSumOrderByAggregateInput
  }

  export type OnRampTransactionScalarWhereWithAggregatesInput = {
    AND?: OnRampTransactionScalarWhereWithAggregatesInput | OnRampTransactionScalarWhereWithAggregatesInput[]
    OR?: OnRampTransactionScalarWhereWithAggregatesInput[]
    NOT?: OnRampTransactionScalarWhereWithAggregatesInput | OnRampTransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OnRampTransaction"> | number
    status?: EnumOnRampStatusWithAggregatesFilter<"OnRampTransaction"> | $Enums.OnRampStatus
    token?: StringWithAggregatesFilter<"OnRampTransaction"> | string
    provider?: StringWithAggregatesFilter<"OnRampTransaction"> | string
    amount?: IntWithAggregatesFilter<"OnRampTransaction"> | number
    startTime?: DateTimeWithAggregatesFilter<"OnRampTransaction"> | Date | string
    transactionId?: StringNullableWithAggregatesFilter<"OnRampTransaction"> | string | null
    userId?: IntWithAggregatesFilter<"OnRampTransaction"> | number
  }

  export type P2PRequestWhereInput = {
    AND?: P2PRequestWhereInput | P2PRequestWhereInput[]
    OR?: P2PRequestWhereInput[]
    NOT?: P2PRequestWhereInput | P2PRequestWhereInput[]
    id?: IntFilter<"P2PRequest"> | number
    senderId?: IntFilter<"P2PRequest"> | number
    receiverId?: IntNullableFilter<"P2PRequest"> | number | null
    receiverNumber?: StringFilter<"P2PRequest"> | string
    amount?: IntFilter<"P2PRequest"> | number
    message?: StringNullableFilter<"P2PRequest"> | string | null
    status?: EnumP2PRequestStatusFilter<"P2PRequest"> | $Enums.P2PRequestStatus
    createdAt?: DateTimeFilter<"P2PRequest"> | Date | string
    settledAt?: DateTimeNullableFilter<"P2PRequest"> | Date | string | null
    billSplitMemberId?: IntNullableFilter<"P2PRequest"> | number | null
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    receiver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    billSplitMember?: XOR<BillSplitMemberNullableScalarRelationFilter, BillSplitMemberWhereInput> | null
  }

  export type P2PRequestOrderByWithRelationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrderInput | SortOrder
    receiverNumber?: SortOrder
    amount?: SortOrder
    message?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    settledAt?: SortOrderInput | SortOrder
    billSplitMemberId?: SortOrderInput | SortOrder
    sender?: UserOrderByWithRelationInput
    receiver?: UserOrderByWithRelationInput
    billSplitMember?: BillSplitMemberOrderByWithRelationInput
  }

  export type P2PRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    billSplitMemberId?: number
    AND?: P2PRequestWhereInput | P2PRequestWhereInput[]
    OR?: P2PRequestWhereInput[]
    NOT?: P2PRequestWhereInput | P2PRequestWhereInput[]
    senderId?: IntFilter<"P2PRequest"> | number
    receiverId?: IntNullableFilter<"P2PRequest"> | number | null
    receiverNumber?: StringFilter<"P2PRequest"> | string
    amount?: IntFilter<"P2PRequest"> | number
    message?: StringNullableFilter<"P2PRequest"> | string | null
    status?: EnumP2PRequestStatusFilter<"P2PRequest"> | $Enums.P2PRequestStatus
    createdAt?: DateTimeFilter<"P2PRequest"> | Date | string
    settledAt?: DateTimeNullableFilter<"P2PRequest"> | Date | string | null
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    receiver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    billSplitMember?: XOR<BillSplitMemberNullableScalarRelationFilter, BillSplitMemberWhereInput> | null
  }, "id" | "billSplitMemberId">

  export type P2PRequestOrderByWithAggregationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrderInput | SortOrder
    receiverNumber?: SortOrder
    amount?: SortOrder
    message?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    settledAt?: SortOrderInput | SortOrder
    billSplitMemberId?: SortOrderInput | SortOrder
    _count?: P2PRequestCountOrderByAggregateInput
    _avg?: P2PRequestAvgOrderByAggregateInput
    _max?: P2PRequestMaxOrderByAggregateInput
    _min?: P2PRequestMinOrderByAggregateInput
    _sum?: P2PRequestSumOrderByAggregateInput
  }

  export type P2PRequestScalarWhereWithAggregatesInput = {
    AND?: P2PRequestScalarWhereWithAggregatesInput | P2PRequestScalarWhereWithAggregatesInput[]
    OR?: P2PRequestScalarWhereWithAggregatesInput[]
    NOT?: P2PRequestScalarWhereWithAggregatesInput | P2PRequestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"P2PRequest"> | number
    senderId?: IntWithAggregatesFilter<"P2PRequest"> | number
    receiverId?: IntNullableWithAggregatesFilter<"P2PRequest"> | number | null
    receiverNumber?: StringWithAggregatesFilter<"P2PRequest"> | string
    amount?: IntWithAggregatesFilter<"P2PRequest"> | number
    message?: StringNullableWithAggregatesFilter<"P2PRequest"> | string | null
    status?: EnumP2PRequestStatusWithAggregatesFilter<"P2PRequest"> | $Enums.P2PRequestStatus
    createdAt?: DateTimeWithAggregatesFilter<"P2PRequest"> | Date | string
    settledAt?: DateTimeNullableWithAggregatesFilter<"P2PRequest"> | Date | string | null
    billSplitMemberId?: IntNullableWithAggregatesFilter<"P2PRequest"> | number | null
  }

  export type BillScheduleWhereInput = {
    AND?: BillScheduleWhereInput | BillScheduleWhereInput[]
    OR?: BillScheduleWhereInput[]
    NOT?: BillScheduleWhereInput | BillScheduleWhereInput[]
    id?: IntFilter<"BillSchedule"> | number
    userId?: IntFilter<"BillSchedule"> | number
    merchantId?: IntNullableFilter<"BillSchedule"> | number | null
    billType?: StringFilter<"BillSchedule"> | string
    provider?: StringFilter<"BillSchedule"> | string
    accountNo?: StringFilter<"BillSchedule"> | string
    amount?: IntFilter<"BillSchedule"> | number
    dueDate?: DateTimeFilter<"BillSchedule"> | Date | string
    nextPayment?: DateTimeNullableFilter<"BillSchedule"> | Date | string | null
    createdAt?: DateTimeFilter<"BillSchedule"> | Date | string
    paymentMethod?: StringFilter<"BillSchedule"> | string
    status?: StringFilter<"BillSchedule"> | string
    token?: StringNullableFilter<"BillSchedule"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    merchant?: XOR<MerchantNullableScalarRelationFilter, MerchantWhereInput> | null
  }

  export type BillScheduleOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    merchantId?: SortOrderInput | SortOrder
    billType?: SortOrder
    provider?: SortOrder
    accountNo?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    nextPayment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    token?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    merchant?: MerchantOrderByWithRelationInput
  }

  export type BillScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    AND?: BillScheduleWhereInput | BillScheduleWhereInput[]
    OR?: BillScheduleWhereInput[]
    NOT?: BillScheduleWhereInput | BillScheduleWhereInput[]
    userId?: IntFilter<"BillSchedule"> | number
    merchantId?: IntNullableFilter<"BillSchedule"> | number | null
    billType?: StringFilter<"BillSchedule"> | string
    provider?: StringFilter<"BillSchedule"> | string
    accountNo?: StringFilter<"BillSchedule"> | string
    amount?: IntFilter<"BillSchedule"> | number
    dueDate?: DateTimeFilter<"BillSchedule"> | Date | string
    nextPayment?: DateTimeNullableFilter<"BillSchedule"> | Date | string | null
    createdAt?: DateTimeFilter<"BillSchedule"> | Date | string
    paymentMethod?: StringFilter<"BillSchedule"> | string
    status?: StringFilter<"BillSchedule"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    merchant?: XOR<MerchantNullableScalarRelationFilter, MerchantWhereInput> | null
  }, "id" | "token">

  export type BillScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    merchantId?: SortOrderInput | SortOrder
    billType?: SortOrder
    provider?: SortOrder
    accountNo?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    nextPayment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    token?: SortOrderInput | SortOrder
    _count?: BillScheduleCountOrderByAggregateInput
    _avg?: BillScheduleAvgOrderByAggregateInput
    _max?: BillScheduleMaxOrderByAggregateInput
    _min?: BillScheduleMinOrderByAggregateInput
    _sum?: BillScheduleSumOrderByAggregateInput
  }

  export type BillScheduleScalarWhereWithAggregatesInput = {
    AND?: BillScheduleScalarWhereWithAggregatesInput | BillScheduleScalarWhereWithAggregatesInput[]
    OR?: BillScheduleScalarWhereWithAggregatesInput[]
    NOT?: BillScheduleScalarWhereWithAggregatesInput | BillScheduleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BillSchedule"> | number
    userId?: IntWithAggregatesFilter<"BillSchedule"> | number
    merchantId?: IntNullableWithAggregatesFilter<"BillSchedule"> | number | null
    billType?: StringWithAggregatesFilter<"BillSchedule"> | string
    provider?: StringWithAggregatesFilter<"BillSchedule"> | string
    accountNo?: StringWithAggregatesFilter<"BillSchedule"> | string
    amount?: IntWithAggregatesFilter<"BillSchedule"> | number
    dueDate?: DateTimeWithAggregatesFilter<"BillSchedule"> | Date | string
    nextPayment?: DateTimeNullableWithAggregatesFilter<"BillSchedule"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BillSchedule"> | Date | string
    paymentMethod?: StringWithAggregatesFilter<"BillSchedule"> | string
    status?: StringWithAggregatesFilter<"BillSchedule"> | string
    token?: StringNullableWithAggregatesFilter<"BillSchedule"> | string | null
  }

  export type RechargePlanWhereInput = {
    AND?: RechargePlanWhereInput | RechargePlanWhereInput[]
    OR?: RechargePlanWhereInput[]
    NOT?: RechargePlanWhereInput | RechargePlanWhereInput[]
    id?: IntFilter<"RechargePlan"> | number
    operator?: StringFilter<"RechargePlan"> | string
    circle?: StringFilter<"RechargePlan"> | string
    planCode?: StringFilter<"RechargePlan"> | string
    amount?: IntFilter<"RechargePlan"> | number
    planType?: StringFilter<"RechargePlan"> | string
    validity?: StringNullableFilter<"RechargePlan"> | string | null
    data?: StringNullableFilter<"RechargePlan"> | string | null
    description?: StringNullableFilter<"RechargePlan"> | string | null
    createdAt?: DateTimeFilter<"RechargePlan"> | Date | string
    updatedAt?: DateTimeFilter<"RechargePlan"> | Date | string
    rechargeOrders?: RechargeOrderListRelationFilter
  }

  export type RechargePlanOrderByWithRelationInput = {
    id?: SortOrder
    operator?: SortOrder
    circle?: SortOrder
    planCode?: SortOrder
    amount?: SortOrder
    planType?: SortOrder
    validity?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rechargeOrders?: RechargeOrderOrderByRelationAggregateInput
  }

  export type RechargePlanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RechargePlanWhereInput | RechargePlanWhereInput[]
    OR?: RechargePlanWhereInput[]
    NOT?: RechargePlanWhereInput | RechargePlanWhereInput[]
    operator?: StringFilter<"RechargePlan"> | string
    circle?: StringFilter<"RechargePlan"> | string
    planCode?: StringFilter<"RechargePlan"> | string
    amount?: IntFilter<"RechargePlan"> | number
    planType?: StringFilter<"RechargePlan"> | string
    validity?: StringNullableFilter<"RechargePlan"> | string | null
    data?: StringNullableFilter<"RechargePlan"> | string | null
    description?: StringNullableFilter<"RechargePlan"> | string | null
    createdAt?: DateTimeFilter<"RechargePlan"> | Date | string
    updatedAt?: DateTimeFilter<"RechargePlan"> | Date | string
    rechargeOrders?: RechargeOrderListRelationFilter
  }, "id">

  export type RechargePlanOrderByWithAggregationInput = {
    id?: SortOrder
    operator?: SortOrder
    circle?: SortOrder
    planCode?: SortOrder
    amount?: SortOrder
    planType?: SortOrder
    validity?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RechargePlanCountOrderByAggregateInput
    _avg?: RechargePlanAvgOrderByAggregateInput
    _max?: RechargePlanMaxOrderByAggregateInput
    _min?: RechargePlanMinOrderByAggregateInput
    _sum?: RechargePlanSumOrderByAggregateInput
  }

  export type RechargePlanScalarWhereWithAggregatesInput = {
    AND?: RechargePlanScalarWhereWithAggregatesInput | RechargePlanScalarWhereWithAggregatesInput[]
    OR?: RechargePlanScalarWhereWithAggregatesInput[]
    NOT?: RechargePlanScalarWhereWithAggregatesInput | RechargePlanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RechargePlan"> | number
    operator?: StringWithAggregatesFilter<"RechargePlan"> | string
    circle?: StringWithAggregatesFilter<"RechargePlan"> | string
    planCode?: StringWithAggregatesFilter<"RechargePlan"> | string
    amount?: IntWithAggregatesFilter<"RechargePlan"> | number
    planType?: StringWithAggregatesFilter<"RechargePlan"> | string
    validity?: StringNullableWithAggregatesFilter<"RechargePlan"> | string | null
    data?: StringNullableWithAggregatesFilter<"RechargePlan"> | string | null
    description?: StringNullableWithAggregatesFilter<"RechargePlan"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RechargePlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RechargePlan"> | Date | string
  }

  export type RechargeOrderWhereInput = {
    AND?: RechargeOrderWhereInput | RechargeOrderWhereInput[]
    OR?: RechargeOrderWhereInput[]
    NOT?: RechargeOrderWhereInput | RechargeOrderWhereInput[]
    id?: IntFilter<"RechargeOrder"> | number
    userId?: IntFilter<"RechargeOrder"> | number
    planId?: IntNullableFilter<"RechargeOrder"> | number | null
    mobileNumber?: StringFilter<"RechargeOrder"> | string
    operator?: StringFilter<"RechargeOrder"> | string
    circle?: StringFilter<"RechargeOrder"> | string
    amount?: IntFilter<"RechargeOrder"> | number
    status?: StringFilter<"RechargeOrder"> | string
    providerTxnId?: StringNullableFilter<"RechargeOrder"> | string | null
    orderId?: StringFilter<"RechargeOrder"> | string
    createdAt?: DateTimeFilter<"RechargeOrder"> | Date | string
    updatedAt?: DateTimeFilter<"RechargeOrder"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    plan?: XOR<RechargePlanNullableScalarRelationFilter, RechargePlanWhereInput> | null
  }

  export type RechargeOrderOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrderInput | SortOrder
    mobileNumber?: SortOrder
    operator?: SortOrder
    circle?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    providerTxnId?: SortOrderInput | SortOrder
    orderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    plan?: RechargePlanOrderByWithRelationInput
  }

  export type RechargeOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    orderId?: string
    AND?: RechargeOrderWhereInput | RechargeOrderWhereInput[]
    OR?: RechargeOrderWhereInput[]
    NOT?: RechargeOrderWhereInput | RechargeOrderWhereInput[]
    userId?: IntFilter<"RechargeOrder"> | number
    planId?: IntNullableFilter<"RechargeOrder"> | number | null
    mobileNumber?: StringFilter<"RechargeOrder"> | string
    operator?: StringFilter<"RechargeOrder"> | string
    circle?: StringFilter<"RechargeOrder"> | string
    amount?: IntFilter<"RechargeOrder"> | number
    status?: StringFilter<"RechargeOrder"> | string
    providerTxnId?: StringNullableFilter<"RechargeOrder"> | string | null
    createdAt?: DateTimeFilter<"RechargeOrder"> | Date | string
    updatedAt?: DateTimeFilter<"RechargeOrder"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    plan?: XOR<RechargePlanNullableScalarRelationFilter, RechargePlanWhereInput> | null
  }, "id" | "orderId">

  export type RechargeOrderOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrderInput | SortOrder
    mobileNumber?: SortOrder
    operator?: SortOrder
    circle?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    providerTxnId?: SortOrderInput | SortOrder
    orderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RechargeOrderCountOrderByAggregateInput
    _avg?: RechargeOrderAvgOrderByAggregateInput
    _max?: RechargeOrderMaxOrderByAggregateInput
    _min?: RechargeOrderMinOrderByAggregateInput
    _sum?: RechargeOrderSumOrderByAggregateInput
  }

  export type RechargeOrderScalarWhereWithAggregatesInput = {
    AND?: RechargeOrderScalarWhereWithAggregatesInput | RechargeOrderScalarWhereWithAggregatesInput[]
    OR?: RechargeOrderScalarWhereWithAggregatesInput[]
    NOT?: RechargeOrderScalarWhereWithAggregatesInput | RechargeOrderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RechargeOrder"> | number
    userId?: IntWithAggregatesFilter<"RechargeOrder"> | number
    planId?: IntNullableWithAggregatesFilter<"RechargeOrder"> | number | null
    mobileNumber?: StringWithAggregatesFilter<"RechargeOrder"> | string
    operator?: StringWithAggregatesFilter<"RechargeOrder"> | string
    circle?: StringWithAggregatesFilter<"RechargeOrder"> | string
    amount?: IntWithAggregatesFilter<"RechargeOrder"> | number
    status?: StringWithAggregatesFilter<"RechargeOrder"> | string
    providerTxnId?: StringNullableWithAggregatesFilter<"RechargeOrder"> | string | null
    orderId?: StringWithAggregatesFilter<"RechargeOrder"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RechargeOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RechargeOrder"> | Date | string
  }

  export type RewardWhereInput = {
    AND?: RewardWhereInput | RewardWhereInput[]
    OR?: RewardWhereInput[]
    NOT?: RewardWhereInput | RewardWhereInput[]
    id?: IntFilter<"Reward"> | number
    userId?: IntFilter<"Reward"> | number
    type?: EnumRewardTypeFilter<"Reward"> | $Enums.RewardType
    amount?: BigIntFilter<"Reward"> | bigint | number
    status?: EnumRewardStatusFilter<"Reward"> | $Enums.RewardStatus
    earnedAt?: DateTimeFilter<"Reward"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Reward"> | Date | string | null
    metadata?: JsonNullableFilter<"Reward">
    billSplitGroupId?: IntNullableFilter<"Reward"> | number | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    billSplitGroup?: XOR<BillSplitGroupNullableScalarRelationFilter, BillSplitGroupWhereInput> | null
  }

  export type RewardOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    earnedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    billSplitGroupId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    billSplitGroup?: BillSplitGroupOrderByWithRelationInput
  }

  export type RewardWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RewardWhereInput | RewardWhereInput[]
    OR?: RewardWhereInput[]
    NOT?: RewardWhereInput | RewardWhereInput[]
    userId?: IntFilter<"Reward"> | number
    type?: EnumRewardTypeFilter<"Reward"> | $Enums.RewardType
    amount?: BigIntFilter<"Reward"> | bigint | number
    status?: EnumRewardStatusFilter<"Reward"> | $Enums.RewardStatus
    earnedAt?: DateTimeFilter<"Reward"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Reward"> | Date | string | null
    metadata?: JsonNullableFilter<"Reward">
    billSplitGroupId?: IntNullableFilter<"Reward"> | number | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    billSplitGroup?: XOR<BillSplitGroupNullableScalarRelationFilter, BillSplitGroupWhereInput> | null
  }, "id">

  export type RewardOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    earnedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    billSplitGroupId?: SortOrderInput | SortOrder
    _count?: RewardCountOrderByAggregateInput
    _avg?: RewardAvgOrderByAggregateInput
    _max?: RewardMaxOrderByAggregateInput
    _min?: RewardMinOrderByAggregateInput
    _sum?: RewardSumOrderByAggregateInput
  }

  export type RewardScalarWhereWithAggregatesInput = {
    AND?: RewardScalarWhereWithAggregatesInput | RewardScalarWhereWithAggregatesInput[]
    OR?: RewardScalarWhereWithAggregatesInput[]
    NOT?: RewardScalarWhereWithAggregatesInput | RewardScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Reward"> | number
    userId?: IntWithAggregatesFilter<"Reward"> | number
    type?: EnumRewardTypeWithAggregatesFilter<"Reward"> | $Enums.RewardType
    amount?: BigIntWithAggregatesFilter<"Reward"> | bigint | number
    status?: EnumRewardStatusWithAggregatesFilter<"Reward"> | $Enums.RewardStatus
    earnedAt?: DateTimeWithAggregatesFilter<"Reward"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Reward"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Reward">
    billSplitGroupId?: IntNullableWithAggregatesFilter<"Reward"> | number | null
  }

  export type ReferralWhereInput = {
    AND?: ReferralWhereInput | ReferralWhereInput[]
    OR?: ReferralWhereInput[]
    NOT?: ReferralWhereInput | ReferralWhereInput[]
    id?: IntFilter<"Referral"> | number
    referrerId?: IntFilter<"Referral"> | number
    referredUserId?: IntNullableFilter<"Referral"> | number | null
    referralCode?: StringFilter<"Referral"> | string
    referrer?: XOR<UserScalarRelationFilter, UserWhereInput>
    referred?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ReferralOrderByWithRelationInput = {
    id?: SortOrder
    referrerId?: SortOrder
    referredUserId?: SortOrderInput | SortOrder
    referralCode?: SortOrder
    referrer?: UserOrderByWithRelationInput
    referred?: UserOrderByWithRelationInput
  }

  export type ReferralWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    referralCode?: string
    AND?: ReferralWhereInput | ReferralWhereInput[]
    OR?: ReferralWhereInput[]
    NOT?: ReferralWhereInput | ReferralWhereInput[]
    referrerId?: IntFilter<"Referral"> | number
    referredUserId?: IntNullableFilter<"Referral"> | number | null
    referrer?: XOR<UserScalarRelationFilter, UserWhereInput>
    referred?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "referralCode">

  export type ReferralOrderByWithAggregationInput = {
    id?: SortOrder
    referrerId?: SortOrder
    referredUserId?: SortOrderInput | SortOrder
    referralCode?: SortOrder
    _count?: ReferralCountOrderByAggregateInput
    _avg?: ReferralAvgOrderByAggregateInput
    _max?: ReferralMaxOrderByAggregateInput
    _min?: ReferralMinOrderByAggregateInput
    _sum?: ReferralSumOrderByAggregateInput
  }

  export type ReferralScalarWhereWithAggregatesInput = {
    AND?: ReferralScalarWhereWithAggregatesInput | ReferralScalarWhereWithAggregatesInput[]
    OR?: ReferralScalarWhereWithAggregatesInput[]
    NOT?: ReferralScalarWhereWithAggregatesInput | ReferralScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Referral"> | number
    referrerId?: IntWithAggregatesFilter<"Referral"> | number
    referredUserId?: IntNullableWithAggregatesFilter<"Referral"> | number | null
    referralCode?: StringWithAggregatesFilter<"Referral"> | string
  }

  export type WrongSendRequestWhereInput = {
    AND?: WrongSendRequestWhereInput | WrongSendRequestWhereInput[]
    OR?: WrongSendRequestWhereInput[]
    NOT?: WrongSendRequestWhereInput | WrongSendRequestWhereInput[]
    id?: IntFilter<"WrongSendRequest"> | number
    txnId?: IntFilter<"WrongSendRequest"> | number
    senderId?: IntFilter<"WrongSendRequest"> | number
    receiverNumber?: StringFilter<"WrongSendRequest"> | string
    amount?: BigIntFilter<"WrongSendRequest"> | bigint | number
    status?: EnumWrongSendStatusFilter<"WrongSendRequest"> | $Enums.WrongSendStatus
    expiresAt?: DateTimeFilter<"WrongSendRequest"> | Date | string
    penaltyPaid?: BoolFilter<"WrongSendRequest"> | boolean
    razorpayRefundId?: StringNullableFilter<"WrongSendRequest"> | string | null
    createdAt?: DateTimeFilter<"WrongSendRequest"> | Date | string
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    transaction?: XOR<P2pTransferScalarRelationFilter, p2pTransferWhereInput>
  }

  export type WrongSendRequestOrderByWithRelationInput = {
    id?: SortOrder
    txnId?: SortOrder
    senderId?: SortOrder
    receiverNumber?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    penaltyPaid?: SortOrder
    razorpayRefundId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    sender?: UserOrderByWithRelationInput
    transaction?: p2pTransferOrderByWithRelationInput
  }

  export type WrongSendRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    txnId?: number
    razorpayRefundId?: string
    AND?: WrongSendRequestWhereInput | WrongSendRequestWhereInput[]
    OR?: WrongSendRequestWhereInput[]
    NOT?: WrongSendRequestWhereInput | WrongSendRequestWhereInput[]
    senderId?: IntFilter<"WrongSendRequest"> | number
    receiverNumber?: StringFilter<"WrongSendRequest"> | string
    amount?: BigIntFilter<"WrongSendRequest"> | bigint | number
    status?: EnumWrongSendStatusFilter<"WrongSendRequest"> | $Enums.WrongSendStatus
    expiresAt?: DateTimeFilter<"WrongSendRequest"> | Date | string
    penaltyPaid?: BoolFilter<"WrongSendRequest"> | boolean
    createdAt?: DateTimeFilter<"WrongSendRequest"> | Date | string
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    transaction?: XOR<P2pTransferScalarRelationFilter, p2pTransferWhereInput>
  }, "id" | "txnId" | "razorpayRefundId">

  export type WrongSendRequestOrderByWithAggregationInput = {
    id?: SortOrder
    txnId?: SortOrder
    senderId?: SortOrder
    receiverNumber?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    penaltyPaid?: SortOrder
    razorpayRefundId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: WrongSendRequestCountOrderByAggregateInput
    _avg?: WrongSendRequestAvgOrderByAggregateInput
    _max?: WrongSendRequestMaxOrderByAggregateInput
    _min?: WrongSendRequestMinOrderByAggregateInput
    _sum?: WrongSendRequestSumOrderByAggregateInput
  }

  export type WrongSendRequestScalarWhereWithAggregatesInput = {
    AND?: WrongSendRequestScalarWhereWithAggregatesInput | WrongSendRequestScalarWhereWithAggregatesInput[]
    OR?: WrongSendRequestScalarWhereWithAggregatesInput[]
    NOT?: WrongSendRequestScalarWhereWithAggregatesInput | WrongSendRequestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WrongSendRequest"> | number
    txnId?: IntWithAggregatesFilter<"WrongSendRequest"> | number
    senderId?: IntWithAggregatesFilter<"WrongSendRequest"> | number
    receiverNumber?: StringWithAggregatesFilter<"WrongSendRequest"> | string
    amount?: BigIntWithAggregatesFilter<"WrongSendRequest"> | bigint | number
    status?: EnumWrongSendStatusWithAggregatesFilter<"WrongSendRequest"> | $Enums.WrongSendStatus
    expiresAt?: DateTimeWithAggregatesFilter<"WrongSendRequest"> | Date | string
    penaltyPaid?: BoolWithAggregatesFilter<"WrongSendRequest"> | boolean
    razorpayRefundId?: StringNullableWithAggregatesFilter<"WrongSendRequest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WrongSendRequest"> | Date | string
  }

  export type BillSplitGroupWhereInput = {
    AND?: BillSplitGroupWhereInput | BillSplitGroupWhereInput[]
    OR?: BillSplitGroupWhereInput[]
    NOT?: BillSplitGroupWhereInput | BillSplitGroupWhereInput[]
    id?: IntFilter<"BillSplitGroup"> | number
    name?: StringFilter<"BillSplitGroup"> | string
    description?: StringNullableFilter<"BillSplitGroup"> | string | null
    totalAmount?: IntFilter<"BillSplitGroup"> | number
    currency?: StringFilter<"BillSplitGroup"> | string
    createdById?: IntFilter<"BillSplitGroup"> | number
    createdAt?: DateTimeFilter<"BillSplitGroup"> | Date | string
    settledAt?: DateTimeNullableFilter<"BillSplitGroup"> | Date | string | null
    status?: StringFilter<"BillSplitGroup"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    members?: BillSplitMemberListRelationFilter
    payments?: BillSplitPaymentListRelationFilter
    rewards?: RewardListRelationFilter
  }

  export type BillSplitGroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    settledAt?: SortOrderInput | SortOrder
    status?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    members?: BillSplitMemberOrderByRelationAggregateInput
    payments?: BillSplitPaymentOrderByRelationAggregateInput
    rewards?: RewardOrderByRelationAggregateInput
  }

  export type BillSplitGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BillSplitGroupWhereInput | BillSplitGroupWhereInput[]
    OR?: BillSplitGroupWhereInput[]
    NOT?: BillSplitGroupWhereInput | BillSplitGroupWhereInput[]
    name?: StringFilter<"BillSplitGroup"> | string
    description?: StringNullableFilter<"BillSplitGroup"> | string | null
    totalAmount?: IntFilter<"BillSplitGroup"> | number
    currency?: StringFilter<"BillSplitGroup"> | string
    createdById?: IntFilter<"BillSplitGroup"> | number
    createdAt?: DateTimeFilter<"BillSplitGroup"> | Date | string
    settledAt?: DateTimeNullableFilter<"BillSplitGroup"> | Date | string | null
    status?: StringFilter<"BillSplitGroup"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    members?: BillSplitMemberListRelationFilter
    payments?: BillSplitPaymentListRelationFilter
    rewards?: RewardListRelationFilter
  }, "id">

  export type BillSplitGroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    settledAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: BillSplitGroupCountOrderByAggregateInput
    _avg?: BillSplitGroupAvgOrderByAggregateInput
    _max?: BillSplitGroupMaxOrderByAggregateInput
    _min?: BillSplitGroupMinOrderByAggregateInput
    _sum?: BillSplitGroupSumOrderByAggregateInput
  }

  export type BillSplitGroupScalarWhereWithAggregatesInput = {
    AND?: BillSplitGroupScalarWhereWithAggregatesInput | BillSplitGroupScalarWhereWithAggregatesInput[]
    OR?: BillSplitGroupScalarWhereWithAggregatesInput[]
    NOT?: BillSplitGroupScalarWhereWithAggregatesInput | BillSplitGroupScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BillSplitGroup"> | number
    name?: StringWithAggregatesFilter<"BillSplitGroup"> | string
    description?: StringNullableWithAggregatesFilter<"BillSplitGroup"> | string | null
    totalAmount?: IntWithAggregatesFilter<"BillSplitGroup"> | number
    currency?: StringWithAggregatesFilter<"BillSplitGroup"> | string
    createdById?: IntWithAggregatesFilter<"BillSplitGroup"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BillSplitGroup"> | Date | string
    settledAt?: DateTimeNullableWithAggregatesFilter<"BillSplitGroup"> | Date | string | null
    status?: StringWithAggregatesFilter<"BillSplitGroup"> | string
  }

  export type BillSplitMemberWhereInput = {
    AND?: BillSplitMemberWhereInput | BillSplitMemberWhereInput[]
    OR?: BillSplitMemberWhereInput[]
    NOT?: BillSplitMemberWhereInput | BillSplitMemberWhereInput[]
    id?: IntFilter<"BillSplitMember"> | number
    groupId?: IntFilter<"BillSplitMember"> | number
    userId?: IntNullableFilter<"BillSplitMember"> | number | null
    phone?: StringNullableFilter<"BillSplitMember"> | string | null
    name?: StringFilter<"BillSplitMember"> | string
    share?: IntFilter<"BillSplitMember"> | number
    paid?: BoolFilter<"BillSplitMember"> | boolean
    paidAt?: DateTimeNullableFilter<"BillSplitMember"> | Date | string | null
    paidAmount?: IntFilter<"BillSplitMember"> | number
    group?: XOR<BillSplitGroupScalarRelationFilter, BillSplitGroupWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    request?: XOR<P2PRequestNullableScalarRelationFilter, P2PRequestWhereInput> | null
    payments?: BillSplitPaymentListRelationFilter
  }

  export type BillSplitMemberOrderByWithRelationInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    name?: SortOrder
    share?: SortOrder
    paid?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    paidAmount?: SortOrder
    group?: BillSplitGroupOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    request?: P2PRequestOrderByWithRelationInput
    payments?: BillSplitPaymentOrderByRelationAggregateInput
  }

  export type BillSplitMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BillSplitMemberWhereInput | BillSplitMemberWhereInput[]
    OR?: BillSplitMemberWhereInput[]
    NOT?: BillSplitMemberWhereInput | BillSplitMemberWhereInput[]
    groupId?: IntFilter<"BillSplitMember"> | number
    userId?: IntNullableFilter<"BillSplitMember"> | number | null
    phone?: StringNullableFilter<"BillSplitMember"> | string | null
    name?: StringFilter<"BillSplitMember"> | string
    share?: IntFilter<"BillSplitMember"> | number
    paid?: BoolFilter<"BillSplitMember"> | boolean
    paidAt?: DateTimeNullableFilter<"BillSplitMember"> | Date | string | null
    paidAmount?: IntFilter<"BillSplitMember"> | number
    group?: XOR<BillSplitGroupScalarRelationFilter, BillSplitGroupWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    request?: XOR<P2PRequestNullableScalarRelationFilter, P2PRequestWhereInput> | null
    payments?: BillSplitPaymentListRelationFilter
  }, "id">

  export type BillSplitMemberOrderByWithAggregationInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    name?: SortOrder
    share?: SortOrder
    paid?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    paidAmount?: SortOrder
    _count?: BillSplitMemberCountOrderByAggregateInput
    _avg?: BillSplitMemberAvgOrderByAggregateInput
    _max?: BillSplitMemberMaxOrderByAggregateInput
    _min?: BillSplitMemberMinOrderByAggregateInput
    _sum?: BillSplitMemberSumOrderByAggregateInput
  }

  export type BillSplitMemberScalarWhereWithAggregatesInput = {
    AND?: BillSplitMemberScalarWhereWithAggregatesInput | BillSplitMemberScalarWhereWithAggregatesInput[]
    OR?: BillSplitMemberScalarWhereWithAggregatesInput[]
    NOT?: BillSplitMemberScalarWhereWithAggregatesInput | BillSplitMemberScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BillSplitMember"> | number
    groupId?: IntWithAggregatesFilter<"BillSplitMember"> | number
    userId?: IntNullableWithAggregatesFilter<"BillSplitMember"> | number | null
    phone?: StringNullableWithAggregatesFilter<"BillSplitMember"> | string | null
    name?: StringWithAggregatesFilter<"BillSplitMember"> | string
    share?: IntWithAggregatesFilter<"BillSplitMember"> | number
    paid?: BoolWithAggregatesFilter<"BillSplitMember"> | boolean
    paidAt?: DateTimeNullableWithAggregatesFilter<"BillSplitMember"> | Date | string | null
    paidAmount?: IntWithAggregatesFilter<"BillSplitMember"> | number
  }

  export type BillSplitPaymentWhereInput = {
    AND?: BillSplitPaymentWhereInput | BillSplitPaymentWhereInput[]
    OR?: BillSplitPaymentWhereInput[]
    NOT?: BillSplitPaymentWhereInput | BillSplitPaymentWhereInput[]
    id?: IntFilter<"BillSplitPayment"> | number
    groupId?: IntFilter<"BillSplitPayment"> | number
    memberId?: IntFilter<"BillSplitPayment"> | number
    p2pTransferId?: IntNullableFilter<"BillSplitPayment"> | number | null
    amount?: IntFilter<"BillSplitPayment"> | number
    paidAt?: DateTimeFilter<"BillSplitPayment"> | Date | string
    group?: XOR<BillSplitGroupScalarRelationFilter, BillSplitGroupWhereInput>
    member?: XOR<BillSplitMemberScalarRelationFilter, BillSplitMemberWhereInput>
    p2pTransfer?: XOR<P2pTransferNullableScalarRelationFilter, p2pTransferWhereInput> | null
  }

  export type BillSplitPaymentOrderByWithRelationInput = {
    id?: SortOrder
    groupId?: SortOrder
    memberId?: SortOrder
    p2pTransferId?: SortOrderInput | SortOrder
    amount?: SortOrder
    paidAt?: SortOrder
    group?: BillSplitGroupOrderByWithRelationInput
    member?: BillSplitMemberOrderByWithRelationInput
    p2pTransfer?: p2pTransferOrderByWithRelationInput
  }

  export type BillSplitPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    p2pTransferId?: number
    AND?: BillSplitPaymentWhereInput | BillSplitPaymentWhereInput[]
    OR?: BillSplitPaymentWhereInput[]
    NOT?: BillSplitPaymentWhereInput | BillSplitPaymentWhereInput[]
    groupId?: IntFilter<"BillSplitPayment"> | number
    memberId?: IntFilter<"BillSplitPayment"> | number
    amount?: IntFilter<"BillSplitPayment"> | number
    paidAt?: DateTimeFilter<"BillSplitPayment"> | Date | string
    group?: XOR<BillSplitGroupScalarRelationFilter, BillSplitGroupWhereInput>
    member?: XOR<BillSplitMemberScalarRelationFilter, BillSplitMemberWhereInput>
    p2pTransfer?: XOR<P2pTransferNullableScalarRelationFilter, p2pTransferWhereInput> | null
  }, "id" | "p2pTransferId">

  export type BillSplitPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    groupId?: SortOrder
    memberId?: SortOrder
    p2pTransferId?: SortOrderInput | SortOrder
    amount?: SortOrder
    paidAt?: SortOrder
    _count?: BillSplitPaymentCountOrderByAggregateInput
    _avg?: BillSplitPaymentAvgOrderByAggregateInput
    _max?: BillSplitPaymentMaxOrderByAggregateInput
    _min?: BillSplitPaymentMinOrderByAggregateInput
    _sum?: BillSplitPaymentSumOrderByAggregateInput
  }

  export type BillSplitPaymentScalarWhereWithAggregatesInput = {
    AND?: BillSplitPaymentScalarWhereWithAggregatesInput | BillSplitPaymentScalarWhereWithAggregatesInput[]
    OR?: BillSplitPaymentScalarWhereWithAggregatesInput[]
    NOT?: BillSplitPaymentScalarWhereWithAggregatesInput | BillSplitPaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BillSplitPayment"> | number
    groupId?: IntWithAggregatesFilter<"BillSplitPayment"> | number
    memberId?: IntWithAggregatesFilter<"BillSplitPayment"> | number
    p2pTransferId?: IntNullableWithAggregatesFilter<"BillSplitPayment"> | number | null
    amount?: IntWithAggregatesFilter<"BillSplitPayment"> | number
    paidAt?: DateTimeWithAggregatesFilter<"BillSplitPayment"> | Date | string
  }

  export type BalanceWhereInput = {
    AND?: BalanceWhereInput | BalanceWhereInput[]
    OR?: BalanceWhereInput[]
    NOT?: BalanceWhereInput | BalanceWhereInput[]
    id?: IntFilter<"Balance"> | number
    userId?: IntFilter<"Balance"> | number
    amount?: IntFilter<"Balance"> | number
    locked?: IntFilter<"Balance"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BalanceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    locked?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type BalanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: BalanceWhereInput | BalanceWhereInput[]
    OR?: BalanceWhereInput[]
    NOT?: BalanceWhereInput | BalanceWhereInput[]
    amount?: IntFilter<"Balance"> | number
    locked?: IntFilter<"Balance"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type BalanceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    locked?: SortOrder
    _count?: BalanceCountOrderByAggregateInput
    _avg?: BalanceAvgOrderByAggregateInput
    _max?: BalanceMaxOrderByAggregateInput
    _min?: BalanceMinOrderByAggregateInput
    _sum?: BalanceSumOrderByAggregateInput
  }

  export type BalanceScalarWhereWithAggregatesInput = {
    AND?: BalanceScalarWhereWithAggregatesInput | BalanceScalarWhereWithAggregatesInput[]
    OR?: BalanceScalarWhereWithAggregatesInput[]
    NOT?: BalanceScalarWhereWithAggregatesInput | BalanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Balance"> | number
    userId?: IntWithAggregatesFilter<"Balance"> | number
    amount?: IntWithAggregatesFilter<"Balance"> | number
    locked?: IntWithAggregatesFilter<"Balance"> | number
  }

  export type UserCreateInput = {
    email?: string | null
    name?: string | null
    number: string
    password: string
    sessionToken?: string | null
    image?: string | null
    userpin: string
    resetOtp?: string | null
    resetExpires?: Date | string | null
    OnRampTransaction?: OnRampTransactionCreateNestedManyWithoutUserInput
    Balance?: BalanceCreateNestedManyWithoutUserInput
    sentTransfers?: p2pTransferCreateNestedManyWithoutFromUserInput
    receivedTransfers?: p2pTransferCreateNestedManyWithoutToUserInput
    sentRequests?: P2PRequestCreateNestedManyWithoutSenderInput
    receivedRequests?: P2PRequestCreateNestedManyWithoutReceiverInput
    billSchedules?: BillScheduleCreateNestedManyWithoutUserInput
    merchantPayments?: MerchantPaymentCreateNestedManyWithoutUserInput
    rechargeOrders?: RechargeOrderCreateNestedManyWithoutUserInput
    rewards?: RewardCreateNestedManyWithoutUserInput
    referralsAsReferrer?: ReferralCreateNestedManyWithoutReferrerInput
    referralsAsReferred?: ReferralCreateNestedManyWithoutReferredInput
    wrongSendRequests?: WrongSendRequestCreateNestedManyWithoutSenderInput
    createdGroups?: BillSplitGroupCreateNestedManyWithoutCreatedByInput
    billSplitMembers?: BillSplitMemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email?: string | null
    name?: string | null
    number: string
    password: string
    sessionToken?: string | null
    image?: string | null
    userpin: string
    resetOtp?: string | null
    resetExpires?: Date | string | null
    OnRampTransaction?: OnRampTransactionUncheckedCreateNestedManyWithoutUserInput
    Balance?: BalanceUncheckedCreateNestedManyWithoutUserInput
    sentTransfers?: p2pTransferUncheckedCreateNestedManyWithoutFromUserInput
    receivedTransfers?: p2pTransferUncheckedCreateNestedManyWithoutToUserInput
    sentRequests?: P2PRequestUncheckedCreateNestedManyWithoutSenderInput
    receivedRequests?: P2PRequestUncheckedCreateNestedManyWithoutReceiverInput
    billSchedules?: BillScheduleUncheckedCreateNestedManyWithoutUserInput
    merchantPayments?: MerchantPaymentUncheckedCreateNestedManyWithoutUserInput
    rechargeOrders?: RechargeOrderUncheckedCreateNestedManyWithoutUserInput
    rewards?: RewardUncheckedCreateNestedManyWithoutUserInput
    referralsAsReferrer?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referralsAsReferred?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    wrongSendRequests?: WrongSendRequestUncheckedCreateNestedManyWithoutSenderInput
    createdGroups?: BillSplitGroupUncheckedCreateNestedManyWithoutCreatedByInput
    billSplitMembers?: BillSplitMemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    userpin?: StringFieldUpdateOperationsInput | string
    resetOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OnRampTransaction?: OnRampTransactionUpdateManyWithoutUserNestedInput
    Balance?: BalanceUpdateManyWithoutUserNestedInput
    sentTransfers?: p2pTransferUpdateManyWithoutFromUserNestedInput
    receivedTransfers?: p2pTransferUpdateManyWithoutToUserNestedInput
    sentRequests?: P2PRequestUpdateManyWithoutSenderNestedInput
    receivedRequests?: P2PRequestUpdateManyWithoutReceiverNestedInput
    billSchedules?: BillScheduleUpdateManyWithoutUserNestedInput
    merchantPayments?: MerchantPaymentUpdateManyWithoutUserNestedInput
    rechargeOrders?: RechargeOrderUpdateManyWithoutUserNestedInput
    rewards?: RewardUpdateManyWithoutUserNestedInput
    referralsAsReferrer?: ReferralUpdateManyWithoutReferrerNestedInput
    referralsAsReferred?: ReferralUpdateManyWithoutReferredNestedInput
    wrongSendRequests?: WrongSendRequestUpdateManyWithoutSenderNestedInput
    createdGroups?: BillSplitGroupUpdateManyWithoutCreatedByNestedInput
    billSplitMembers?: BillSplitMemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    userpin?: StringFieldUpdateOperationsInput | string
    resetOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OnRampTransaction?: OnRampTransactionUncheckedUpdateManyWithoutUserNestedInput
    Balance?: BalanceUncheckedUpdateManyWithoutUserNestedInput
    sentTransfers?: p2pTransferUncheckedUpdateManyWithoutFromUserNestedInput
    receivedTransfers?: p2pTransferUncheckedUpdateManyWithoutToUserNestedInput
    sentRequests?: P2PRequestUncheckedUpdateManyWithoutSenderNestedInput
    receivedRequests?: P2PRequestUncheckedUpdateManyWithoutReceiverNestedInput
    billSchedules?: BillScheduleUncheckedUpdateManyWithoutUserNestedInput
    merchantPayments?: MerchantPaymentUncheckedUpdateManyWithoutUserNestedInput
    rechargeOrders?: RechargeOrderUncheckedUpdateManyWithoutUserNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutUserNestedInput
    referralsAsReferrer?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referralsAsReferred?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    wrongSendRequests?: WrongSendRequestUncheckedUpdateManyWithoutSenderNestedInput
    createdGroups?: BillSplitGroupUncheckedUpdateManyWithoutCreatedByNestedInput
    billSplitMembers?: BillSplitMemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email?: string | null
    name?: string | null
    number: string
    password: string
    sessionToken?: string | null
    image?: string | null
    userpin: string
    resetOtp?: string | null
    resetExpires?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    userpin?: StringFieldUpdateOperationsInput | string
    resetOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    userpin?: StringFieldUpdateOperationsInput | string
    resetOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type p2pTransferCreateInput = {
    amount: number
    timestamp: Date | string
    receiverNumber?: string | null
    status?: string
    razorpayPaymentId?: string | null
    paymentMethod?: string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    merchantId?: number | null
    latitude?: number | null
    longitude?: number | null
    isFraud?: boolean | null
    fraudScore?: number | null
    fraudReason?: string | null
    riskLevel?: string | null
    fromUser: UserCreateNestedOneWithoutSentTransfersInput
    toUser?: UserCreateNestedOneWithoutReceivedTransfersInput
    wrongSendRequest?: WrongSendRequestCreateNestedOneWithoutTransactionInput
    billSplitPayment?: BillSplitPaymentCreateNestedOneWithoutP2pTransferInput
  }

  export type p2pTransferUncheckedCreateInput = {
    id?: number
    amount: number
    timestamp: Date | string
    fromUserId: number
    toUserId?: number | null
    receiverNumber?: string | null
    status?: string
    razorpayPaymentId?: string | null
    paymentMethod?: string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    merchantId?: number | null
    latitude?: number | null
    longitude?: number | null
    isFraud?: boolean | null
    fraudScore?: number | null
    fraudReason?: string | null
    riskLevel?: string | null
    wrongSendRequest?: WrongSendRequestUncheckedCreateNestedOneWithoutTransactionInput
    billSplitPayment?: BillSplitPaymentUncheckedCreateNestedOneWithoutP2pTransferInput
  }

  export type p2pTransferUpdateInput = {
    amount?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    isFraud?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fraudScore?: NullableFloatFieldUpdateOperationsInput | number | null
    fraudReason?: NullableStringFieldUpdateOperationsInput | string | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    fromUser?: UserUpdateOneRequiredWithoutSentTransfersNestedInput
    toUser?: UserUpdateOneWithoutReceivedTransfersNestedInput
    wrongSendRequest?: WrongSendRequestUpdateOneWithoutTransactionNestedInput
    billSplitPayment?: BillSplitPaymentUpdateOneWithoutP2pTransferNestedInput
  }

  export type p2pTransferUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    fromUserId?: IntFieldUpdateOperationsInput | number
    toUserId?: NullableIntFieldUpdateOperationsInput | number | null
    receiverNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    isFraud?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fraudScore?: NullableFloatFieldUpdateOperationsInput | number | null
    fraudReason?: NullableStringFieldUpdateOperationsInput | string | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    wrongSendRequest?: WrongSendRequestUncheckedUpdateOneWithoutTransactionNestedInput
    billSplitPayment?: BillSplitPaymentUncheckedUpdateOneWithoutP2pTransferNestedInput
  }

  export type p2pTransferCreateManyInput = {
    id?: number
    amount: number
    timestamp: Date | string
    fromUserId: number
    toUserId?: number | null
    receiverNumber?: string | null
    status?: string
    razorpayPaymentId?: string | null
    paymentMethod?: string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    merchantId?: number | null
    latitude?: number | null
    longitude?: number | null
    isFraud?: boolean | null
    fraudScore?: number | null
    fraudReason?: string | null
    riskLevel?: string | null
  }

  export type p2pTransferUpdateManyMutationInput = {
    amount?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    isFraud?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fraudScore?: NullableFloatFieldUpdateOperationsInput | number | null
    fraudReason?: NullableStringFieldUpdateOperationsInput | string | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type p2pTransferUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    fromUserId?: IntFieldUpdateOperationsInput | number
    toUserId?: NullableIntFieldUpdateOperationsInput | number | null
    receiverNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    isFraud?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fraudScore?: NullableFloatFieldUpdateOperationsInput | number | null
    fraudReason?: NullableStringFieldUpdateOperationsInput | string | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FraudLogCreateInput = {
    userId: number
    transactionId?: number | null
    score: number
    reason: string
    blocked: boolean
    createdAt?: Date | string
  }

  export type FraudLogUncheckedCreateInput = {
    id?: number
    userId: number
    transactionId?: number | null
    score: number
    reason: string
    blocked: boolean
    createdAt?: Date | string
  }

  export type FraudLogUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    score?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    blocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FraudLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    score?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    blocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FraudLogCreateManyInput = {
    id?: number
    userId: number
    transactionId?: number | null
    score: number
    reason: string
    blocked: boolean
    createdAt?: Date | string
  }

  export type FraudLogUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    score?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    blocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FraudLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    score?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    blocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MerchantCreateInput = {
    email: string
    name?: string | null
    upiId?: string | null
    auth_type: $Enums.AuthType
    billSchedules?: BillScheduleCreateNestedManyWithoutMerchantInput
    payments?: MerchantPaymentCreateNestedManyWithoutMerchantInput
  }

  export type MerchantUncheckedCreateInput = {
    id?: number
    email: string
    name?: string | null
    upiId?: string | null
    auth_type: $Enums.AuthType
    billSchedules?: BillScheduleUncheckedCreateNestedManyWithoutMerchantInput
    payments?: MerchantPaymentUncheckedCreateNestedManyWithoutMerchantInput
  }

  export type MerchantUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    auth_type?: EnumAuthTypeFieldUpdateOperationsInput | $Enums.AuthType
    billSchedules?: BillScheduleUpdateManyWithoutMerchantNestedInput
    payments?: MerchantPaymentUpdateManyWithoutMerchantNestedInput
  }

  export type MerchantUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    auth_type?: EnumAuthTypeFieldUpdateOperationsInput | $Enums.AuthType
    billSchedules?: BillScheduleUncheckedUpdateManyWithoutMerchantNestedInput
    payments?: MerchantPaymentUncheckedUpdateManyWithoutMerchantNestedInput
  }

  export type MerchantCreateManyInput = {
    id?: number
    email: string
    name?: string | null
    upiId?: string | null
    auth_type: $Enums.AuthType
  }

  export type MerchantUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    auth_type?: EnumAuthTypeFieldUpdateOperationsInput | $Enums.AuthType
  }

  export type MerchantUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    auth_type?: EnumAuthTypeFieldUpdateOperationsInput | $Enums.AuthType
  }

  export type MerchantPaymentCreateInput = {
    qrId: string
    amount: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionId?: string | null
    merchant: MerchantCreateNestedOneWithoutPaymentsInput
    user?: UserCreateNestedOneWithoutMerchantPaymentsInput
  }

  export type MerchantPaymentUncheckedCreateInput = {
    id?: number
    merchantId: number
    qrId: string
    amount: number
    status: string
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionId?: string | null
  }

  export type MerchantPaymentUpdateInput = {
    qrId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: MerchantUpdateOneRequiredWithoutPaymentsNestedInput
    user?: UserUpdateOneWithoutMerchantPaymentsNestedInput
  }

  export type MerchantPaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    merchantId?: IntFieldUpdateOperationsInput | number
    qrId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MerchantPaymentCreateManyInput = {
    id?: number
    merchantId: number
    qrId: string
    amount: number
    status: string
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionId?: string | null
  }

  export type MerchantPaymentUpdateManyMutationInput = {
    qrId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MerchantPaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    merchantId?: IntFieldUpdateOperationsInput | number
    qrId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OnRampTransactionCreateInput = {
    status: $Enums.OnRampStatus
    token: string
    provider: string
    amount: number
    startTime?: Date | string
    transactionId?: string | null
    user: UserCreateNestedOneWithoutOnRampTransactionInput
  }

  export type OnRampTransactionUncheckedCreateInput = {
    id?: number
    status: $Enums.OnRampStatus
    token: string
    provider: string
    amount: number
    startTime?: Date | string
    transactionId?: string | null
    userId: number
  }

  export type OnRampTransactionUpdateInput = {
    status?: EnumOnRampStatusFieldUpdateOperationsInput | $Enums.OnRampStatus
    token?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutOnRampTransactionNestedInput
  }

  export type OnRampTransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumOnRampStatusFieldUpdateOperationsInput | $Enums.OnRampStatus
    token?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type OnRampTransactionCreateManyInput = {
    id?: number
    status: $Enums.OnRampStatus
    token: string
    provider: string
    amount: number
    startTime?: Date | string
    transactionId?: string | null
    userId: number
  }

  export type OnRampTransactionUpdateManyMutationInput = {
    status?: EnumOnRampStatusFieldUpdateOperationsInput | $Enums.OnRampStatus
    token?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OnRampTransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumOnRampStatusFieldUpdateOperationsInput | $Enums.OnRampStatus
    token?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type P2PRequestCreateInput = {
    receiverNumber: string
    amount: number
    message?: string | null
    status?: $Enums.P2PRequestStatus
    createdAt?: Date | string
    settledAt?: Date | string | null
    sender: UserCreateNestedOneWithoutSentRequestsInput
    receiver?: UserCreateNestedOneWithoutReceivedRequestsInput
    billSplitMember?: BillSplitMemberCreateNestedOneWithoutRequestInput
  }

  export type P2PRequestUncheckedCreateInput = {
    id?: number
    senderId: number
    receiverId?: number | null
    receiverNumber: string
    amount: number
    message?: string | null
    status?: $Enums.P2PRequestStatus
    createdAt?: Date | string
    settledAt?: Date | string | null
    billSplitMemberId?: number | null
  }

  export type P2PRequestUpdateInput = {
    receiverNumber?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumP2PRequestStatusFieldUpdateOperationsInput | $Enums.P2PRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sender?: UserUpdateOneRequiredWithoutSentRequestsNestedInput
    receiver?: UserUpdateOneWithoutReceivedRequestsNestedInput
    billSplitMember?: BillSplitMemberUpdateOneWithoutRequestNestedInput
  }

  export type P2PRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    receiverId?: NullableIntFieldUpdateOperationsInput | number | null
    receiverNumber?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumP2PRequestStatusFieldUpdateOperationsInput | $Enums.P2PRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billSplitMemberId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type P2PRequestCreateManyInput = {
    id?: number
    senderId: number
    receiverId?: number | null
    receiverNumber: string
    amount: number
    message?: string | null
    status?: $Enums.P2PRequestStatus
    createdAt?: Date | string
    settledAt?: Date | string | null
    billSplitMemberId?: number | null
  }

  export type P2PRequestUpdateManyMutationInput = {
    receiverNumber?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumP2PRequestStatusFieldUpdateOperationsInput | $Enums.P2PRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type P2PRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    receiverId?: NullableIntFieldUpdateOperationsInput | number | null
    receiverNumber?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumP2PRequestStatusFieldUpdateOperationsInput | $Enums.P2PRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billSplitMemberId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BillScheduleCreateInput = {
    billType: string
    provider: string
    accountNo: string
    amount: number
    dueDate: Date | string
    nextPayment?: Date | string | null
    createdAt?: Date | string
    paymentMethod?: string
    status?: string
    token?: string | null
    user: UserCreateNestedOneWithoutBillSchedulesInput
    merchant?: MerchantCreateNestedOneWithoutBillSchedulesInput
  }

  export type BillScheduleUncheckedCreateInput = {
    id?: number
    userId: number
    merchantId?: number | null
    billType: string
    provider: string
    accountNo: string
    amount: number
    dueDate: Date | string
    nextPayment?: Date | string | null
    createdAt?: Date | string
    paymentMethod?: string
    status?: string
    token?: string | null
  }

  export type BillScheduleUpdateInput = {
    billType?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    accountNo?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextPayment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutBillSchedulesNestedInput
    merchant?: MerchantUpdateOneWithoutBillSchedulesNestedInput
  }

  export type BillScheduleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    merchantId?: NullableIntFieldUpdateOperationsInput | number | null
    billType?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    accountNo?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextPayment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BillScheduleCreateManyInput = {
    id?: number
    userId: number
    merchantId?: number | null
    billType: string
    provider: string
    accountNo: string
    amount: number
    dueDate: Date | string
    nextPayment?: Date | string | null
    createdAt?: Date | string
    paymentMethod?: string
    status?: string
    token?: string | null
  }

  export type BillScheduleUpdateManyMutationInput = {
    billType?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    accountNo?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextPayment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BillScheduleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    merchantId?: NullableIntFieldUpdateOperationsInput | number | null
    billType?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    accountNo?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextPayment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RechargePlanCreateInput = {
    operator: string
    circle: string
    planCode: string
    amount: number
    planType: string
    validity?: string | null
    data?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rechargeOrders?: RechargeOrderCreateNestedManyWithoutPlanInput
  }

  export type RechargePlanUncheckedCreateInput = {
    id?: number
    operator: string
    circle: string
    planCode: string
    amount: number
    planType: string
    validity?: string | null
    data?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rechargeOrders?: RechargeOrderUncheckedCreateNestedManyWithoutPlanInput
  }

  export type RechargePlanUpdateInput = {
    operator?: StringFieldUpdateOperationsInput | string
    circle?: StringFieldUpdateOperationsInput | string
    planCode?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    planType?: StringFieldUpdateOperationsInput | string
    validity?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rechargeOrders?: RechargeOrderUpdateManyWithoutPlanNestedInput
  }

  export type RechargePlanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    operator?: StringFieldUpdateOperationsInput | string
    circle?: StringFieldUpdateOperationsInput | string
    planCode?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    planType?: StringFieldUpdateOperationsInput | string
    validity?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rechargeOrders?: RechargeOrderUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type RechargePlanCreateManyInput = {
    id?: number
    operator: string
    circle: string
    planCode: string
    amount: number
    planType: string
    validity?: string | null
    data?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RechargePlanUpdateManyMutationInput = {
    operator?: StringFieldUpdateOperationsInput | string
    circle?: StringFieldUpdateOperationsInput | string
    planCode?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    planType?: StringFieldUpdateOperationsInput | string
    validity?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RechargePlanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    operator?: StringFieldUpdateOperationsInput | string
    circle?: StringFieldUpdateOperationsInput | string
    planCode?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    planType?: StringFieldUpdateOperationsInput | string
    validity?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RechargeOrderCreateInput = {
    mobileNumber: string
    operator: string
    circle: string
    amount: number
    status?: string
    providerTxnId?: string | null
    orderId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRechargeOrdersInput
    plan?: RechargePlanCreateNestedOneWithoutRechargeOrdersInput
  }

  export type RechargeOrderUncheckedCreateInput = {
    id?: number
    userId: number
    planId?: number | null
    mobileNumber: string
    operator: string
    circle: string
    amount: number
    status?: string
    providerTxnId?: string | null
    orderId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RechargeOrderUpdateInput = {
    mobileNumber?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    circle?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    providerTxnId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRechargeOrdersNestedInput
    plan?: RechargePlanUpdateOneWithoutRechargeOrdersNestedInput
  }

  export type RechargeOrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    planId?: NullableIntFieldUpdateOperationsInput | number | null
    mobileNumber?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    circle?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    providerTxnId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RechargeOrderCreateManyInput = {
    id?: number
    userId: number
    planId?: number | null
    mobileNumber: string
    operator: string
    circle: string
    amount: number
    status?: string
    providerTxnId?: string | null
    orderId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RechargeOrderUpdateManyMutationInput = {
    mobileNumber?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    circle?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    providerTxnId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RechargeOrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    planId?: NullableIntFieldUpdateOperationsInput | number | null
    mobileNumber?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    circle?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    providerTxnId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardCreateInput = {
    type: $Enums.RewardType
    amount: bigint | number
    status?: $Enums.RewardStatus
    earnedAt?: Date | string
    expiresAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutRewardsInput
    billSplitGroup?: BillSplitGroupCreateNestedOneWithoutRewardsInput
  }

  export type RewardUncheckedCreateInput = {
    id?: number
    userId: number
    type: $Enums.RewardType
    amount: bigint | number
    status?: $Enums.RewardStatus
    earnedAt?: Date | string
    expiresAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    billSplitGroupId?: number | null
  }

  export type RewardUpdateInput = {
    type?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumRewardStatusFieldUpdateOperationsInput | $Enums.RewardStatus
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutRewardsNestedInput
    billSplitGroup?: BillSplitGroupUpdateOneWithoutRewardsNestedInput
  }

  export type RewardUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumRewardStatusFieldUpdateOperationsInput | $Enums.RewardStatus
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    billSplitGroupId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RewardCreateManyInput = {
    id?: number
    userId: number
    type: $Enums.RewardType
    amount: bigint | number
    status?: $Enums.RewardStatus
    earnedAt?: Date | string
    expiresAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    billSplitGroupId?: number | null
  }

  export type RewardUpdateManyMutationInput = {
    type?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumRewardStatusFieldUpdateOperationsInput | $Enums.RewardStatus
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RewardUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumRewardStatusFieldUpdateOperationsInput | $Enums.RewardStatus
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    billSplitGroupId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReferralCreateInput = {
    referralCode: string
    referrer: UserCreateNestedOneWithoutReferralsAsReferrerInput
    referred?: UserCreateNestedOneWithoutReferralsAsReferredInput
  }

  export type ReferralUncheckedCreateInput = {
    id?: number
    referrerId: number
    referredUserId?: number | null
    referralCode: string
  }

  export type ReferralUpdateInput = {
    referralCode?: StringFieldUpdateOperationsInput | string
    referrer?: UserUpdateOneRequiredWithoutReferralsAsReferrerNestedInput
    referred?: UserUpdateOneWithoutReferralsAsReferredNestedInput
  }

  export type ReferralUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    referrerId?: IntFieldUpdateOperationsInput | number
    referredUserId?: NullableIntFieldUpdateOperationsInput | number | null
    referralCode?: StringFieldUpdateOperationsInput | string
  }

  export type ReferralCreateManyInput = {
    id?: number
    referrerId: number
    referredUserId?: number | null
    referralCode: string
  }

  export type ReferralUpdateManyMutationInput = {
    referralCode?: StringFieldUpdateOperationsInput | string
  }

  export type ReferralUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    referrerId?: IntFieldUpdateOperationsInput | number
    referredUserId?: NullableIntFieldUpdateOperationsInput | number | null
    referralCode?: StringFieldUpdateOperationsInput | string
  }

  export type WrongSendRequestCreateInput = {
    receiverNumber: string
    amount: bigint | number
    status?: $Enums.WrongSendStatus
    expiresAt: Date | string
    penaltyPaid?: boolean
    razorpayRefundId?: string | null
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutWrongSendRequestsInput
    transaction: p2pTransferCreateNestedOneWithoutWrongSendRequestInput
  }

  export type WrongSendRequestUncheckedCreateInput = {
    id?: number
    txnId: number
    senderId: number
    receiverNumber: string
    amount: bigint | number
    status?: $Enums.WrongSendStatus
    expiresAt: Date | string
    penaltyPaid?: boolean
    razorpayRefundId?: string | null
    createdAt?: Date | string
  }

  export type WrongSendRequestUpdateInput = {
    receiverNumber?: StringFieldUpdateOperationsInput | string
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumWrongSendStatusFieldUpdateOperationsInput | $Enums.WrongSendStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    penaltyPaid?: BoolFieldUpdateOperationsInput | boolean
    razorpayRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutWrongSendRequestsNestedInput
    transaction?: p2pTransferUpdateOneRequiredWithoutWrongSendRequestNestedInput
  }

  export type WrongSendRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    txnId?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    receiverNumber?: StringFieldUpdateOperationsInput | string
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumWrongSendStatusFieldUpdateOperationsInput | $Enums.WrongSendStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    penaltyPaid?: BoolFieldUpdateOperationsInput | boolean
    razorpayRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WrongSendRequestCreateManyInput = {
    id?: number
    txnId: number
    senderId: number
    receiverNumber: string
    amount: bigint | number
    status?: $Enums.WrongSendStatus
    expiresAt: Date | string
    penaltyPaid?: boolean
    razorpayRefundId?: string | null
    createdAt?: Date | string
  }

  export type WrongSendRequestUpdateManyMutationInput = {
    receiverNumber?: StringFieldUpdateOperationsInput | string
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumWrongSendStatusFieldUpdateOperationsInput | $Enums.WrongSendStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    penaltyPaid?: BoolFieldUpdateOperationsInput | boolean
    razorpayRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WrongSendRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    txnId?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    receiverNumber?: StringFieldUpdateOperationsInput | string
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumWrongSendStatusFieldUpdateOperationsInput | $Enums.WrongSendStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    penaltyPaid?: BoolFieldUpdateOperationsInput | boolean
    razorpayRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillSplitGroupCreateInput = {
    name: string
    description?: string | null
    totalAmount: number
    currency?: string
    createdAt?: Date | string
    settledAt?: Date | string | null
    status?: string
    createdBy: UserCreateNestedOneWithoutCreatedGroupsInput
    members?: BillSplitMemberCreateNestedManyWithoutGroupInput
    payments?: BillSplitPaymentCreateNestedManyWithoutGroupInput
    rewards?: RewardCreateNestedManyWithoutBillSplitGroupInput
  }

  export type BillSplitGroupUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    totalAmount: number
    currency?: string
    createdById: number
    createdAt?: Date | string
    settledAt?: Date | string | null
    status?: string
    members?: BillSplitMemberUncheckedCreateNestedManyWithoutGroupInput
    payments?: BillSplitPaymentUncheckedCreateNestedManyWithoutGroupInput
    rewards?: RewardUncheckedCreateNestedManyWithoutBillSplitGroupInput
  }

  export type BillSplitGroupUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedGroupsNestedInput
    members?: BillSplitMemberUpdateManyWithoutGroupNestedInput
    payments?: BillSplitPaymentUpdateManyWithoutGroupNestedInput
    rewards?: RewardUpdateManyWithoutBillSplitGroupNestedInput
  }

  export type BillSplitGroupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    members?: BillSplitMemberUncheckedUpdateManyWithoutGroupNestedInput
    payments?: BillSplitPaymentUncheckedUpdateManyWithoutGroupNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutBillSplitGroupNestedInput
  }

  export type BillSplitGroupCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    totalAmount: number
    currency?: string
    createdById: number
    createdAt?: Date | string
    settledAt?: Date | string | null
    status?: string
  }

  export type BillSplitGroupUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type BillSplitGroupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type BillSplitMemberCreateInput = {
    phone?: string | null
    name: string
    share: number
    paid?: boolean
    paidAt?: Date | string | null
    paidAmount?: number
    group: BillSplitGroupCreateNestedOneWithoutMembersInput
    user?: UserCreateNestedOneWithoutBillSplitMembersInput
    request?: P2PRequestCreateNestedOneWithoutBillSplitMemberInput
    payments?: BillSplitPaymentCreateNestedManyWithoutMemberInput
  }

  export type BillSplitMemberUncheckedCreateInput = {
    id?: number
    groupId: number
    userId?: number | null
    phone?: string | null
    name: string
    share: number
    paid?: boolean
    paidAt?: Date | string | null
    paidAmount?: number
    request?: P2PRequestUncheckedCreateNestedOneWithoutBillSplitMemberInput
    payments?: BillSplitPaymentUncheckedCreateNestedManyWithoutMemberInput
  }

  export type BillSplitMemberUpdateInput = {
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    share?: IntFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAmount?: IntFieldUpdateOperationsInput | number
    group?: BillSplitGroupUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneWithoutBillSplitMembersNestedInput
    request?: P2PRequestUpdateOneWithoutBillSplitMemberNestedInput
    payments?: BillSplitPaymentUpdateManyWithoutMemberNestedInput
  }

  export type BillSplitMemberUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    share?: IntFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAmount?: IntFieldUpdateOperationsInput | number
    request?: P2PRequestUncheckedUpdateOneWithoutBillSplitMemberNestedInput
    payments?: BillSplitPaymentUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type BillSplitMemberCreateManyInput = {
    id?: number
    groupId: number
    userId?: number | null
    phone?: string | null
    name: string
    share: number
    paid?: boolean
    paidAt?: Date | string | null
    paidAmount?: number
  }

  export type BillSplitMemberUpdateManyMutationInput = {
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    share?: IntFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAmount?: IntFieldUpdateOperationsInput | number
  }

  export type BillSplitMemberUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    share?: IntFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAmount?: IntFieldUpdateOperationsInput | number
  }

  export type BillSplitPaymentCreateInput = {
    amount: number
    paidAt?: Date | string
    group: BillSplitGroupCreateNestedOneWithoutPaymentsInput
    member: BillSplitMemberCreateNestedOneWithoutPaymentsInput
    p2pTransfer?: p2pTransferCreateNestedOneWithoutBillSplitPaymentInput
  }

  export type BillSplitPaymentUncheckedCreateInput = {
    id?: number
    groupId: number
    memberId: number
    p2pTransferId?: number | null
    amount: number
    paidAt?: Date | string
  }

  export type BillSplitPaymentUpdateInput = {
    amount?: IntFieldUpdateOperationsInput | number
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: BillSplitGroupUpdateOneRequiredWithoutPaymentsNestedInput
    member?: BillSplitMemberUpdateOneRequiredWithoutPaymentsNestedInput
    p2pTransfer?: p2pTransferUpdateOneWithoutBillSplitPaymentNestedInput
  }

  export type BillSplitPaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    memberId?: IntFieldUpdateOperationsInput | number
    p2pTransferId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: IntFieldUpdateOperationsInput | number
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillSplitPaymentCreateManyInput = {
    id?: number
    groupId: number
    memberId: number
    p2pTransferId?: number | null
    amount: number
    paidAt?: Date | string
  }

  export type BillSplitPaymentUpdateManyMutationInput = {
    amount?: IntFieldUpdateOperationsInput | number
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillSplitPaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    memberId?: IntFieldUpdateOperationsInput | number
    p2pTransferId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: IntFieldUpdateOperationsInput | number
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalanceCreateInput = {
    amount: number
    locked: number
    user: UserCreateNestedOneWithoutBalanceInput
  }

  export type BalanceUncheckedCreateInput = {
    id?: number
    userId: number
    amount: number
    locked: number
  }

  export type BalanceUpdateInput = {
    amount?: IntFieldUpdateOperationsInput | number
    locked?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutBalanceNestedInput
  }

  export type BalanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    locked?: IntFieldUpdateOperationsInput | number
  }

  export type BalanceCreateManyInput = {
    id?: number
    userId: number
    amount: number
    locked: number
  }

  export type BalanceUpdateManyMutationInput = {
    amount?: IntFieldUpdateOperationsInput | number
    locked?: IntFieldUpdateOperationsInput | number
  }

  export type BalanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    locked?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type OnRampTransactionListRelationFilter = {
    every?: OnRampTransactionWhereInput
    some?: OnRampTransactionWhereInput
    none?: OnRampTransactionWhereInput
  }

  export type BalanceListRelationFilter = {
    every?: BalanceWhereInput
    some?: BalanceWhereInput
    none?: BalanceWhereInput
  }

  export type P2pTransferListRelationFilter = {
    every?: p2pTransferWhereInput
    some?: p2pTransferWhereInput
    none?: p2pTransferWhereInput
  }

  export type P2PRequestListRelationFilter = {
    every?: P2PRequestWhereInput
    some?: P2PRequestWhereInput
    none?: P2PRequestWhereInput
  }

  export type BillScheduleListRelationFilter = {
    every?: BillScheduleWhereInput
    some?: BillScheduleWhereInput
    none?: BillScheduleWhereInput
  }

  export type MerchantPaymentListRelationFilter = {
    every?: MerchantPaymentWhereInput
    some?: MerchantPaymentWhereInput
    none?: MerchantPaymentWhereInput
  }

  export type RechargeOrderListRelationFilter = {
    every?: RechargeOrderWhereInput
    some?: RechargeOrderWhereInput
    none?: RechargeOrderWhereInput
  }

  export type RewardListRelationFilter = {
    every?: RewardWhereInput
    some?: RewardWhereInput
    none?: RewardWhereInput
  }

  export type ReferralListRelationFilter = {
    every?: ReferralWhereInput
    some?: ReferralWhereInput
    none?: ReferralWhereInput
  }

  export type WrongSendRequestListRelationFilter = {
    every?: WrongSendRequestWhereInput
    some?: WrongSendRequestWhereInput
    none?: WrongSendRequestWhereInput
  }

  export type BillSplitGroupListRelationFilter = {
    every?: BillSplitGroupWhereInput
    some?: BillSplitGroupWhereInput
    none?: BillSplitGroupWhereInput
  }

  export type BillSplitMemberListRelationFilter = {
    every?: BillSplitMemberWhereInput
    some?: BillSplitMemberWhereInput
    none?: BillSplitMemberWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type OnRampTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BalanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type p2pTransferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type P2PRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BillScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MerchantPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RechargeOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RewardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReferralOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WrongSendRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BillSplitGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BillSplitMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    number?: SortOrder
    password?: SortOrder
    sessionToken?: SortOrder
    image?: SortOrder
    userpin?: SortOrder
    resetOtp?: SortOrder
    resetExpires?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    number?: SortOrder
    password?: SortOrder
    sessionToken?: SortOrder
    image?: SortOrder
    userpin?: SortOrder
    resetOtp?: SortOrder
    resetExpires?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    number?: SortOrder
    password?: SortOrder
    sessionToken?: SortOrder
    image?: SortOrder
    userpin?: SortOrder
    resetOtp?: SortOrder
    resetExpires?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type WrongSendRequestNullableScalarRelationFilter = {
    is?: WrongSendRequestWhereInput | null
    isNot?: WrongSendRequestWhereInput | null
  }

  export type BillSplitPaymentNullableScalarRelationFilter = {
    is?: BillSplitPaymentWhereInput | null
    isNot?: BillSplitPaymentWhereInput | null
  }

  export type p2pTransferCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    timestamp?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    receiverNumber?: SortOrder
    status?: SortOrder
    razorpayPaymentId?: SortOrder
    paymentMethod?: SortOrder
    deviceInfo?: SortOrder
    ipAddress?: SortOrder
    merchantId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    isFraud?: SortOrder
    fraudScore?: SortOrder
    fraudReason?: SortOrder
    riskLevel?: SortOrder
  }

  export type p2pTransferAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    merchantId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    fraudScore?: SortOrder
  }

  export type p2pTransferMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    timestamp?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    receiverNumber?: SortOrder
    status?: SortOrder
    razorpayPaymentId?: SortOrder
    paymentMethod?: SortOrder
    ipAddress?: SortOrder
    merchantId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    isFraud?: SortOrder
    fraudScore?: SortOrder
    fraudReason?: SortOrder
    riskLevel?: SortOrder
  }

  export type p2pTransferMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    timestamp?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    receiverNumber?: SortOrder
    status?: SortOrder
    razorpayPaymentId?: SortOrder
    paymentMethod?: SortOrder
    ipAddress?: SortOrder
    merchantId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    isFraud?: SortOrder
    fraudScore?: SortOrder
    fraudReason?: SortOrder
    riskLevel?: SortOrder
  }

  export type p2pTransferSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    merchantId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    fraudScore?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type FraudLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionId?: SortOrder
    score?: SortOrder
    reason?: SortOrder
    blocked?: SortOrder
    createdAt?: SortOrder
  }

  export type FraudLogAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionId?: SortOrder
    score?: SortOrder
  }

  export type FraudLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionId?: SortOrder
    score?: SortOrder
    reason?: SortOrder
    blocked?: SortOrder
    createdAt?: SortOrder
  }

  export type FraudLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionId?: SortOrder
    score?: SortOrder
    reason?: SortOrder
    blocked?: SortOrder
    createdAt?: SortOrder
  }

  export type FraudLogSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionId?: SortOrder
    score?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumAuthTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthType | EnumAuthTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuthType[] | ListEnumAuthTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthType[] | ListEnumAuthTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthTypeFilter<$PrismaModel> | $Enums.AuthType
  }

  export type MerchantCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    upiId?: SortOrder
    auth_type?: SortOrder
  }

  export type MerchantAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MerchantMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    upiId?: SortOrder
    auth_type?: SortOrder
  }

  export type MerchantMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    upiId?: SortOrder
    auth_type?: SortOrder
  }

  export type MerchantSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumAuthTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthType | EnumAuthTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuthType[] | ListEnumAuthTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthType[] | ListEnumAuthTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthTypeWithAggregatesFilter<$PrismaModel> | $Enums.AuthType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthTypeFilter<$PrismaModel>
    _max?: NestedEnumAuthTypeFilter<$PrismaModel>
  }

  export type MerchantScalarRelationFilter = {
    is?: MerchantWhereInput
    isNot?: MerchantWhereInput
  }

  export type MerchantPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    merchantId?: SortOrder
    qrId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transactionId?: SortOrder
  }

  export type MerchantPaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    merchantId?: SortOrder
    amount?: SortOrder
    userId?: SortOrder
  }

  export type MerchantPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    merchantId?: SortOrder
    qrId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transactionId?: SortOrder
  }

  export type MerchantPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    merchantId?: SortOrder
    qrId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transactionId?: SortOrder
  }

  export type MerchantPaymentSumOrderByAggregateInput = {
    id?: SortOrder
    merchantId?: SortOrder
    amount?: SortOrder
    userId?: SortOrder
  }

  export type EnumOnRampStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OnRampStatus | EnumOnRampStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OnRampStatus[] | ListEnumOnRampStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OnRampStatus[] | ListEnumOnRampStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOnRampStatusFilter<$PrismaModel> | $Enums.OnRampStatus
  }

  export type OnRampTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    token?: SortOrder
    provider?: SortOrder
    amount?: SortOrder
    startTime?: SortOrder
    transactionId?: SortOrder
    userId?: SortOrder
  }

  export type OnRampTransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    userId?: SortOrder
  }

  export type OnRampTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    token?: SortOrder
    provider?: SortOrder
    amount?: SortOrder
    startTime?: SortOrder
    transactionId?: SortOrder
    userId?: SortOrder
  }

  export type OnRampTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    token?: SortOrder
    provider?: SortOrder
    amount?: SortOrder
    startTime?: SortOrder
    transactionId?: SortOrder
    userId?: SortOrder
  }

  export type OnRampTransactionSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    userId?: SortOrder
  }

  export type EnumOnRampStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OnRampStatus | EnumOnRampStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OnRampStatus[] | ListEnumOnRampStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OnRampStatus[] | ListEnumOnRampStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOnRampStatusWithAggregatesFilter<$PrismaModel> | $Enums.OnRampStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOnRampStatusFilter<$PrismaModel>
    _max?: NestedEnumOnRampStatusFilter<$PrismaModel>
  }

  export type EnumP2PRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.P2PRequestStatus | EnumP2PRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.P2PRequestStatus[] | ListEnumP2PRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.P2PRequestStatus[] | ListEnumP2PRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumP2PRequestStatusFilter<$PrismaModel> | $Enums.P2PRequestStatus
  }

  export type BillSplitMemberNullableScalarRelationFilter = {
    is?: BillSplitMemberWhereInput | null
    isNot?: BillSplitMemberWhereInput | null
  }

  export type P2PRequestCountOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    receiverNumber?: SortOrder
    amount?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    settledAt?: SortOrder
    billSplitMemberId?: SortOrder
  }

  export type P2PRequestAvgOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    amount?: SortOrder
    billSplitMemberId?: SortOrder
  }

  export type P2PRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    receiverNumber?: SortOrder
    amount?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    settledAt?: SortOrder
    billSplitMemberId?: SortOrder
  }

  export type P2PRequestMinOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    receiverNumber?: SortOrder
    amount?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    settledAt?: SortOrder
    billSplitMemberId?: SortOrder
  }

  export type P2PRequestSumOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    amount?: SortOrder
    billSplitMemberId?: SortOrder
  }

  export type EnumP2PRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.P2PRequestStatus | EnumP2PRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.P2PRequestStatus[] | ListEnumP2PRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.P2PRequestStatus[] | ListEnumP2PRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumP2PRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.P2PRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumP2PRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumP2PRequestStatusFilter<$PrismaModel>
  }

  export type MerchantNullableScalarRelationFilter = {
    is?: MerchantWhereInput | null
    isNot?: MerchantWhereInput | null
  }

  export type BillScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    merchantId?: SortOrder
    billType?: SortOrder
    provider?: SortOrder
    accountNo?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    nextPayment?: SortOrder
    createdAt?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    token?: SortOrder
  }

  export type BillScheduleAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    merchantId?: SortOrder
    amount?: SortOrder
  }

  export type BillScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    merchantId?: SortOrder
    billType?: SortOrder
    provider?: SortOrder
    accountNo?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    nextPayment?: SortOrder
    createdAt?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    token?: SortOrder
  }

  export type BillScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    merchantId?: SortOrder
    billType?: SortOrder
    provider?: SortOrder
    accountNo?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    nextPayment?: SortOrder
    createdAt?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    token?: SortOrder
  }

  export type BillScheduleSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    merchantId?: SortOrder
    amount?: SortOrder
  }

  export type RechargePlanCountOrderByAggregateInput = {
    id?: SortOrder
    operator?: SortOrder
    circle?: SortOrder
    planCode?: SortOrder
    amount?: SortOrder
    planType?: SortOrder
    validity?: SortOrder
    data?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RechargePlanAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
  }

  export type RechargePlanMaxOrderByAggregateInput = {
    id?: SortOrder
    operator?: SortOrder
    circle?: SortOrder
    planCode?: SortOrder
    amount?: SortOrder
    planType?: SortOrder
    validity?: SortOrder
    data?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RechargePlanMinOrderByAggregateInput = {
    id?: SortOrder
    operator?: SortOrder
    circle?: SortOrder
    planCode?: SortOrder
    amount?: SortOrder
    planType?: SortOrder
    validity?: SortOrder
    data?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RechargePlanSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
  }

  export type RechargePlanNullableScalarRelationFilter = {
    is?: RechargePlanWhereInput | null
    isNot?: RechargePlanWhereInput | null
  }

  export type RechargeOrderCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    mobileNumber?: SortOrder
    operator?: SortOrder
    circle?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    providerTxnId?: SortOrder
    orderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RechargeOrderAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    amount?: SortOrder
  }

  export type RechargeOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    mobileNumber?: SortOrder
    operator?: SortOrder
    circle?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    providerTxnId?: SortOrder
    orderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RechargeOrderMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    mobileNumber?: SortOrder
    operator?: SortOrder
    circle?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    providerTxnId?: SortOrder
    orderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RechargeOrderSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    amount?: SortOrder
  }

  export type EnumRewardTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RewardType | EnumRewardTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRewardTypeFilter<$PrismaModel> | $Enums.RewardType
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type EnumRewardStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RewardStatus | EnumRewardStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RewardStatus[] | ListEnumRewardStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RewardStatus[] | ListEnumRewardStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRewardStatusFilter<$PrismaModel> | $Enums.RewardStatus
  }

  export type BillSplitGroupNullableScalarRelationFilter = {
    is?: BillSplitGroupWhereInput | null
    isNot?: BillSplitGroupWhereInput | null
  }

  export type RewardCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    earnedAt?: SortOrder
    expiresAt?: SortOrder
    metadata?: SortOrder
    billSplitGroupId?: SortOrder
  }

  export type RewardAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    billSplitGroupId?: SortOrder
  }

  export type RewardMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    earnedAt?: SortOrder
    expiresAt?: SortOrder
    billSplitGroupId?: SortOrder
  }

  export type RewardMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    earnedAt?: SortOrder
    expiresAt?: SortOrder
    billSplitGroupId?: SortOrder
  }

  export type RewardSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    billSplitGroupId?: SortOrder
  }

  export type EnumRewardTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RewardType | EnumRewardTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRewardTypeWithAggregatesFilter<$PrismaModel> | $Enums.RewardType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRewardTypeFilter<$PrismaModel>
    _max?: NestedEnumRewardTypeFilter<$PrismaModel>
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type EnumRewardStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RewardStatus | EnumRewardStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RewardStatus[] | ListEnumRewardStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RewardStatus[] | ListEnumRewardStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRewardStatusWithAggregatesFilter<$PrismaModel> | $Enums.RewardStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRewardStatusFilter<$PrismaModel>
    _max?: NestedEnumRewardStatusFilter<$PrismaModel>
  }

  export type ReferralCountOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    referredUserId?: SortOrder
    referralCode?: SortOrder
  }

  export type ReferralAvgOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    referredUserId?: SortOrder
  }

  export type ReferralMaxOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    referredUserId?: SortOrder
    referralCode?: SortOrder
  }

  export type ReferralMinOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    referredUserId?: SortOrder
    referralCode?: SortOrder
  }

  export type ReferralSumOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    referredUserId?: SortOrder
  }

  export type EnumWrongSendStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WrongSendStatus | EnumWrongSendStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WrongSendStatus[] | ListEnumWrongSendStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WrongSendStatus[] | ListEnumWrongSendStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWrongSendStatusFilter<$PrismaModel> | $Enums.WrongSendStatus
  }

  export type P2pTransferScalarRelationFilter = {
    is?: p2pTransferWhereInput
    isNot?: p2pTransferWhereInput
  }

  export type WrongSendRequestCountOrderByAggregateInput = {
    id?: SortOrder
    txnId?: SortOrder
    senderId?: SortOrder
    receiverNumber?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    penaltyPaid?: SortOrder
    razorpayRefundId?: SortOrder
    createdAt?: SortOrder
  }

  export type WrongSendRequestAvgOrderByAggregateInput = {
    id?: SortOrder
    txnId?: SortOrder
    senderId?: SortOrder
    amount?: SortOrder
  }

  export type WrongSendRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    txnId?: SortOrder
    senderId?: SortOrder
    receiverNumber?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    penaltyPaid?: SortOrder
    razorpayRefundId?: SortOrder
    createdAt?: SortOrder
  }

  export type WrongSendRequestMinOrderByAggregateInput = {
    id?: SortOrder
    txnId?: SortOrder
    senderId?: SortOrder
    receiverNumber?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    penaltyPaid?: SortOrder
    razorpayRefundId?: SortOrder
    createdAt?: SortOrder
  }

  export type WrongSendRequestSumOrderByAggregateInput = {
    id?: SortOrder
    txnId?: SortOrder
    senderId?: SortOrder
    amount?: SortOrder
  }

  export type EnumWrongSendStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WrongSendStatus | EnumWrongSendStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WrongSendStatus[] | ListEnumWrongSendStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WrongSendStatus[] | ListEnumWrongSendStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWrongSendStatusWithAggregatesFilter<$PrismaModel> | $Enums.WrongSendStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWrongSendStatusFilter<$PrismaModel>
    _max?: NestedEnumWrongSendStatusFilter<$PrismaModel>
  }

  export type BillSplitPaymentListRelationFilter = {
    every?: BillSplitPaymentWhereInput
    some?: BillSplitPaymentWhereInput
    none?: BillSplitPaymentWhereInput
  }

  export type BillSplitPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BillSplitGroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    settledAt?: SortOrder
    status?: SortOrder
  }

  export type BillSplitGroupAvgOrderByAggregateInput = {
    id?: SortOrder
    totalAmount?: SortOrder
    createdById?: SortOrder
  }

  export type BillSplitGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    settledAt?: SortOrder
    status?: SortOrder
  }

  export type BillSplitGroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    settledAt?: SortOrder
    status?: SortOrder
  }

  export type BillSplitGroupSumOrderByAggregateInput = {
    id?: SortOrder
    totalAmount?: SortOrder
    createdById?: SortOrder
  }

  export type BillSplitGroupScalarRelationFilter = {
    is?: BillSplitGroupWhereInput
    isNot?: BillSplitGroupWhereInput
  }

  export type P2PRequestNullableScalarRelationFilter = {
    is?: P2PRequestWhereInput | null
    isNot?: P2PRequestWhereInput | null
  }

  export type BillSplitMemberCountOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    phone?: SortOrder
    name?: SortOrder
    share?: SortOrder
    paid?: SortOrder
    paidAt?: SortOrder
    paidAmount?: SortOrder
  }

  export type BillSplitMemberAvgOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    share?: SortOrder
    paidAmount?: SortOrder
  }

  export type BillSplitMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    phone?: SortOrder
    name?: SortOrder
    share?: SortOrder
    paid?: SortOrder
    paidAt?: SortOrder
    paidAmount?: SortOrder
  }

  export type BillSplitMemberMinOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    phone?: SortOrder
    name?: SortOrder
    share?: SortOrder
    paid?: SortOrder
    paidAt?: SortOrder
    paidAmount?: SortOrder
  }

  export type BillSplitMemberSumOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    share?: SortOrder
    paidAmount?: SortOrder
  }

  export type BillSplitMemberScalarRelationFilter = {
    is?: BillSplitMemberWhereInput
    isNot?: BillSplitMemberWhereInput
  }

  export type P2pTransferNullableScalarRelationFilter = {
    is?: p2pTransferWhereInput | null
    isNot?: p2pTransferWhereInput | null
  }

  export type BillSplitPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    memberId?: SortOrder
    p2pTransferId?: SortOrder
    amount?: SortOrder
    paidAt?: SortOrder
  }

  export type BillSplitPaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    memberId?: SortOrder
    p2pTransferId?: SortOrder
    amount?: SortOrder
  }

  export type BillSplitPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    memberId?: SortOrder
    p2pTransferId?: SortOrder
    amount?: SortOrder
    paidAt?: SortOrder
  }

  export type BillSplitPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    memberId?: SortOrder
    p2pTransferId?: SortOrder
    amount?: SortOrder
    paidAt?: SortOrder
  }

  export type BillSplitPaymentSumOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    memberId?: SortOrder
    p2pTransferId?: SortOrder
    amount?: SortOrder
  }

  export type BalanceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    locked?: SortOrder
  }

  export type BalanceAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    locked?: SortOrder
  }

  export type BalanceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    locked?: SortOrder
  }

  export type BalanceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    locked?: SortOrder
  }

  export type BalanceSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    locked?: SortOrder
  }

  export type OnRampTransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<OnRampTransactionCreateWithoutUserInput, OnRampTransactionUncheckedCreateWithoutUserInput> | OnRampTransactionCreateWithoutUserInput[] | OnRampTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OnRampTransactionCreateOrConnectWithoutUserInput | OnRampTransactionCreateOrConnectWithoutUserInput[]
    createMany?: OnRampTransactionCreateManyUserInputEnvelope
    connect?: OnRampTransactionWhereUniqueInput | OnRampTransactionWhereUniqueInput[]
  }

  export type BalanceCreateNestedManyWithoutUserInput = {
    create?: XOR<BalanceCreateWithoutUserInput, BalanceUncheckedCreateWithoutUserInput> | BalanceCreateWithoutUserInput[] | BalanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BalanceCreateOrConnectWithoutUserInput | BalanceCreateOrConnectWithoutUserInput[]
    createMany?: BalanceCreateManyUserInputEnvelope
    connect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
  }

  export type p2pTransferCreateNestedManyWithoutFromUserInput = {
    create?: XOR<p2pTransferCreateWithoutFromUserInput, p2pTransferUncheckedCreateWithoutFromUserInput> | p2pTransferCreateWithoutFromUserInput[] | p2pTransferUncheckedCreateWithoutFromUserInput[]
    connectOrCreate?: p2pTransferCreateOrConnectWithoutFromUserInput | p2pTransferCreateOrConnectWithoutFromUserInput[]
    createMany?: p2pTransferCreateManyFromUserInputEnvelope
    connect?: p2pTransferWhereUniqueInput | p2pTransferWhereUniqueInput[]
  }

  export type p2pTransferCreateNestedManyWithoutToUserInput = {
    create?: XOR<p2pTransferCreateWithoutToUserInput, p2pTransferUncheckedCreateWithoutToUserInput> | p2pTransferCreateWithoutToUserInput[] | p2pTransferUncheckedCreateWithoutToUserInput[]
    connectOrCreate?: p2pTransferCreateOrConnectWithoutToUserInput | p2pTransferCreateOrConnectWithoutToUserInput[]
    createMany?: p2pTransferCreateManyToUserInputEnvelope
    connect?: p2pTransferWhereUniqueInput | p2pTransferWhereUniqueInput[]
  }

  export type P2PRequestCreateNestedManyWithoutSenderInput = {
    create?: XOR<P2PRequestCreateWithoutSenderInput, P2PRequestUncheckedCreateWithoutSenderInput> | P2PRequestCreateWithoutSenderInput[] | P2PRequestUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: P2PRequestCreateOrConnectWithoutSenderInput | P2PRequestCreateOrConnectWithoutSenderInput[]
    createMany?: P2PRequestCreateManySenderInputEnvelope
    connect?: P2PRequestWhereUniqueInput | P2PRequestWhereUniqueInput[]
  }

  export type P2PRequestCreateNestedManyWithoutReceiverInput = {
    create?: XOR<P2PRequestCreateWithoutReceiverInput, P2PRequestUncheckedCreateWithoutReceiverInput> | P2PRequestCreateWithoutReceiverInput[] | P2PRequestUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: P2PRequestCreateOrConnectWithoutReceiverInput | P2PRequestCreateOrConnectWithoutReceiverInput[]
    createMany?: P2PRequestCreateManyReceiverInputEnvelope
    connect?: P2PRequestWhereUniqueInput | P2PRequestWhereUniqueInput[]
  }

  export type BillScheduleCreateNestedManyWithoutUserInput = {
    create?: XOR<BillScheduleCreateWithoutUserInput, BillScheduleUncheckedCreateWithoutUserInput> | BillScheduleCreateWithoutUserInput[] | BillScheduleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BillScheduleCreateOrConnectWithoutUserInput | BillScheduleCreateOrConnectWithoutUserInput[]
    createMany?: BillScheduleCreateManyUserInputEnvelope
    connect?: BillScheduleWhereUniqueInput | BillScheduleWhereUniqueInput[]
  }

  export type MerchantPaymentCreateNestedManyWithoutUserInput = {
    create?: XOR<MerchantPaymentCreateWithoutUserInput, MerchantPaymentUncheckedCreateWithoutUserInput> | MerchantPaymentCreateWithoutUserInput[] | MerchantPaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MerchantPaymentCreateOrConnectWithoutUserInput | MerchantPaymentCreateOrConnectWithoutUserInput[]
    createMany?: MerchantPaymentCreateManyUserInputEnvelope
    connect?: MerchantPaymentWhereUniqueInput | MerchantPaymentWhereUniqueInput[]
  }

  export type RechargeOrderCreateNestedManyWithoutUserInput = {
    create?: XOR<RechargeOrderCreateWithoutUserInput, RechargeOrderUncheckedCreateWithoutUserInput> | RechargeOrderCreateWithoutUserInput[] | RechargeOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RechargeOrderCreateOrConnectWithoutUserInput | RechargeOrderCreateOrConnectWithoutUserInput[]
    createMany?: RechargeOrderCreateManyUserInputEnvelope
    connect?: RechargeOrderWhereUniqueInput | RechargeOrderWhereUniqueInput[]
  }

  export type RewardCreateNestedManyWithoutUserInput = {
    create?: XOR<RewardCreateWithoutUserInput, RewardUncheckedCreateWithoutUserInput> | RewardCreateWithoutUserInput[] | RewardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RewardCreateOrConnectWithoutUserInput | RewardCreateOrConnectWithoutUserInput[]
    createMany?: RewardCreateManyUserInputEnvelope
    connect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
  }

  export type ReferralCreateNestedManyWithoutReferrerInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type ReferralCreateNestedManyWithoutReferredInput = {
    create?: XOR<ReferralCreateWithoutReferredInput, ReferralUncheckedCreateWithoutReferredInput> | ReferralCreateWithoutReferredInput[] | ReferralUncheckedCreateWithoutReferredInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferredInput | ReferralCreateOrConnectWithoutReferredInput[]
    createMany?: ReferralCreateManyReferredInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type WrongSendRequestCreateNestedManyWithoutSenderInput = {
    create?: XOR<WrongSendRequestCreateWithoutSenderInput, WrongSendRequestUncheckedCreateWithoutSenderInput> | WrongSendRequestCreateWithoutSenderInput[] | WrongSendRequestUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: WrongSendRequestCreateOrConnectWithoutSenderInput | WrongSendRequestCreateOrConnectWithoutSenderInput[]
    createMany?: WrongSendRequestCreateManySenderInputEnvelope
    connect?: WrongSendRequestWhereUniqueInput | WrongSendRequestWhereUniqueInput[]
  }

  export type BillSplitGroupCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<BillSplitGroupCreateWithoutCreatedByInput, BillSplitGroupUncheckedCreateWithoutCreatedByInput> | BillSplitGroupCreateWithoutCreatedByInput[] | BillSplitGroupUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BillSplitGroupCreateOrConnectWithoutCreatedByInput | BillSplitGroupCreateOrConnectWithoutCreatedByInput[]
    createMany?: BillSplitGroupCreateManyCreatedByInputEnvelope
    connect?: BillSplitGroupWhereUniqueInput | BillSplitGroupWhereUniqueInput[]
  }

  export type BillSplitMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<BillSplitMemberCreateWithoutUserInput, BillSplitMemberUncheckedCreateWithoutUserInput> | BillSplitMemberCreateWithoutUserInput[] | BillSplitMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BillSplitMemberCreateOrConnectWithoutUserInput | BillSplitMemberCreateOrConnectWithoutUserInput[]
    createMany?: BillSplitMemberCreateManyUserInputEnvelope
    connect?: BillSplitMemberWhereUniqueInput | BillSplitMemberWhereUniqueInput[]
  }

  export type OnRampTransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OnRampTransactionCreateWithoutUserInput, OnRampTransactionUncheckedCreateWithoutUserInput> | OnRampTransactionCreateWithoutUserInput[] | OnRampTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OnRampTransactionCreateOrConnectWithoutUserInput | OnRampTransactionCreateOrConnectWithoutUserInput[]
    createMany?: OnRampTransactionCreateManyUserInputEnvelope
    connect?: OnRampTransactionWhereUniqueInput | OnRampTransactionWhereUniqueInput[]
  }

  export type BalanceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BalanceCreateWithoutUserInput, BalanceUncheckedCreateWithoutUserInput> | BalanceCreateWithoutUserInput[] | BalanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BalanceCreateOrConnectWithoutUserInput | BalanceCreateOrConnectWithoutUserInput[]
    createMany?: BalanceCreateManyUserInputEnvelope
    connect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
  }

  export type p2pTransferUncheckedCreateNestedManyWithoutFromUserInput = {
    create?: XOR<p2pTransferCreateWithoutFromUserInput, p2pTransferUncheckedCreateWithoutFromUserInput> | p2pTransferCreateWithoutFromUserInput[] | p2pTransferUncheckedCreateWithoutFromUserInput[]
    connectOrCreate?: p2pTransferCreateOrConnectWithoutFromUserInput | p2pTransferCreateOrConnectWithoutFromUserInput[]
    createMany?: p2pTransferCreateManyFromUserInputEnvelope
    connect?: p2pTransferWhereUniqueInput | p2pTransferWhereUniqueInput[]
  }

  export type p2pTransferUncheckedCreateNestedManyWithoutToUserInput = {
    create?: XOR<p2pTransferCreateWithoutToUserInput, p2pTransferUncheckedCreateWithoutToUserInput> | p2pTransferCreateWithoutToUserInput[] | p2pTransferUncheckedCreateWithoutToUserInput[]
    connectOrCreate?: p2pTransferCreateOrConnectWithoutToUserInput | p2pTransferCreateOrConnectWithoutToUserInput[]
    createMany?: p2pTransferCreateManyToUserInputEnvelope
    connect?: p2pTransferWhereUniqueInput | p2pTransferWhereUniqueInput[]
  }

  export type P2PRequestUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<P2PRequestCreateWithoutSenderInput, P2PRequestUncheckedCreateWithoutSenderInput> | P2PRequestCreateWithoutSenderInput[] | P2PRequestUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: P2PRequestCreateOrConnectWithoutSenderInput | P2PRequestCreateOrConnectWithoutSenderInput[]
    createMany?: P2PRequestCreateManySenderInputEnvelope
    connect?: P2PRequestWhereUniqueInput | P2PRequestWhereUniqueInput[]
  }

  export type P2PRequestUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<P2PRequestCreateWithoutReceiverInput, P2PRequestUncheckedCreateWithoutReceiverInput> | P2PRequestCreateWithoutReceiverInput[] | P2PRequestUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: P2PRequestCreateOrConnectWithoutReceiverInput | P2PRequestCreateOrConnectWithoutReceiverInput[]
    createMany?: P2PRequestCreateManyReceiverInputEnvelope
    connect?: P2PRequestWhereUniqueInput | P2PRequestWhereUniqueInput[]
  }

  export type BillScheduleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BillScheduleCreateWithoutUserInput, BillScheduleUncheckedCreateWithoutUserInput> | BillScheduleCreateWithoutUserInput[] | BillScheduleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BillScheduleCreateOrConnectWithoutUserInput | BillScheduleCreateOrConnectWithoutUserInput[]
    createMany?: BillScheduleCreateManyUserInputEnvelope
    connect?: BillScheduleWhereUniqueInput | BillScheduleWhereUniqueInput[]
  }

  export type MerchantPaymentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MerchantPaymentCreateWithoutUserInput, MerchantPaymentUncheckedCreateWithoutUserInput> | MerchantPaymentCreateWithoutUserInput[] | MerchantPaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MerchantPaymentCreateOrConnectWithoutUserInput | MerchantPaymentCreateOrConnectWithoutUserInput[]
    createMany?: MerchantPaymentCreateManyUserInputEnvelope
    connect?: MerchantPaymentWhereUniqueInput | MerchantPaymentWhereUniqueInput[]
  }

  export type RechargeOrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RechargeOrderCreateWithoutUserInput, RechargeOrderUncheckedCreateWithoutUserInput> | RechargeOrderCreateWithoutUserInput[] | RechargeOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RechargeOrderCreateOrConnectWithoutUserInput | RechargeOrderCreateOrConnectWithoutUserInput[]
    createMany?: RechargeOrderCreateManyUserInputEnvelope
    connect?: RechargeOrderWhereUniqueInput | RechargeOrderWhereUniqueInput[]
  }

  export type RewardUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RewardCreateWithoutUserInput, RewardUncheckedCreateWithoutUserInput> | RewardCreateWithoutUserInput[] | RewardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RewardCreateOrConnectWithoutUserInput | RewardCreateOrConnectWithoutUserInput[]
    createMany?: RewardCreateManyUserInputEnvelope
    connect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
  }

  export type ReferralUncheckedCreateNestedManyWithoutReferrerInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type ReferralUncheckedCreateNestedManyWithoutReferredInput = {
    create?: XOR<ReferralCreateWithoutReferredInput, ReferralUncheckedCreateWithoutReferredInput> | ReferralCreateWithoutReferredInput[] | ReferralUncheckedCreateWithoutReferredInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferredInput | ReferralCreateOrConnectWithoutReferredInput[]
    createMany?: ReferralCreateManyReferredInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type WrongSendRequestUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<WrongSendRequestCreateWithoutSenderInput, WrongSendRequestUncheckedCreateWithoutSenderInput> | WrongSendRequestCreateWithoutSenderInput[] | WrongSendRequestUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: WrongSendRequestCreateOrConnectWithoutSenderInput | WrongSendRequestCreateOrConnectWithoutSenderInput[]
    createMany?: WrongSendRequestCreateManySenderInputEnvelope
    connect?: WrongSendRequestWhereUniqueInput | WrongSendRequestWhereUniqueInput[]
  }

  export type BillSplitGroupUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<BillSplitGroupCreateWithoutCreatedByInput, BillSplitGroupUncheckedCreateWithoutCreatedByInput> | BillSplitGroupCreateWithoutCreatedByInput[] | BillSplitGroupUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BillSplitGroupCreateOrConnectWithoutCreatedByInput | BillSplitGroupCreateOrConnectWithoutCreatedByInput[]
    createMany?: BillSplitGroupCreateManyCreatedByInputEnvelope
    connect?: BillSplitGroupWhereUniqueInput | BillSplitGroupWhereUniqueInput[]
  }

  export type BillSplitMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BillSplitMemberCreateWithoutUserInput, BillSplitMemberUncheckedCreateWithoutUserInput> | BillSplitMemberCreateWithoutUserInput[] | BillSplitMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BillSplitMemberCreateOrConnectWithoutUserInput | BillSplitMemberCreateOrConnectWithoutUserInput[]
    createMany?: BillSplitMemberCreateManyUserInputEnvelope
    connect?: BillSplitMemberWhereUniqueInput | BillSplitMemberWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type OnRampTransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<OnRampTransactionCreateWithoutUserInput, OnRampTransactionUncheckedCreateWithoutUserInput> | OnRampTransactionCreateWithoutUserInput[] | OnRampTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OnRampTransactionCreateOrConnectWithoutUserInput | OnRampTransactionCreateOrConnectWithoutUserInput[]
    upsert?: OnRampTransactionUpsertWithWhereUniqueWithoutUserInput | OnRampTransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OnRampTransactionCreateManyUserInputEnvelope
    set?: OnRampTransactionWhereUniqueInput | OnRampTransactionWhereUniqueInput[]
    disconnect?: OnRampTransactionWhereUniqueInput | OnRampTransactionWhereUniqueInput[]
    delete?: OnRampTransactionWhereUniqueInput | OnRampTransactionWhereUniqueInput[]
    connect?: OnRampTransactionWhereUniqueInput | OnRampTransactionWhereUniqueInput[]
    update?: OnRampTransactionUpdateWithWhereUniqueWithoutUserInput | OnRampTransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OnRampTransactionUpdateManyWithWhereWithoutUserInput | OnRampTransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OnRampTransactionScalarWhereInput | OnRampTransactionScalarWhereInput[]
  }

  export type BalanceUpdateManyWithoutUserNestedInput = {
    create?: XOR<BalanceCreateWithoutUserInput, BalanceUncheckedCreateWithoutUserInput> | BalanceCreateWithoutUserInput[] | BalanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BalanceCreateOrConnectWithoutUserInput | BalanceCreateOrConnectWithoutUserInput[]
    upsert?: BalanceUpsertWithWhereUniqueWithoutUserInput | BalanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BalanceCreateManyUserInputEnvelope
    set?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    disconnect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    delete?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    connect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    update?: BalanceUpdateWithWhereUniqueWithoutUserInput | BalanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BalanceUpdateManyWithWhereWithoutUserInput | BalanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BalanceScalarWhereInput | BalanceScalarWhereInput[]
  }

  export type p2pTransferUpdateManyWithoutFromUserNestedInput = {
    create?: XOR<p2pTransferCreateWithoutFromUserInput, p2pTransferUncheckedCreateWithoutFromUserInput> | p2pTransferCreateWithoutFromUserInput[] | p2pTransferUncheckedCreateWithoutFromUserInput[]
    connectOrCreate?: p2pTransferCreateOrConnectWithoutFromUserInput | p2pTransferCreateOrConnectWithoutFromUserInput[]
    upsert?: p2pTransferUpsertWithWhereUniqueWithoutFromUserInput | p2pTransferUpsertWithWhereUniqueWithoutFromUserInput[]
    createMany?: p2pTransferCreateManyFromUserInputEnvelope
    set?: p2pTransferWhereUniqueInput | p2pTransferWhereUniqueInput[]
    disconnect?: p2pTransferWhereUniqueInput | p2pTransferWhereUniqueInput[]
    delete?: p2pTransferWhereUniqueInput | p2pTransferWhereUniqueInput[]
    connect?: p2pTransferWhereUniqueInput | p2pTransferWhereUniqueInput[]
    update?: p2pTransferUpdateWithWhereUniqueWithoutFromUserInput | p2pTransferUpdateWithWhereUniqueWithoutFromUserInput[]
    updateMany?: p2pTransferUpdateManyWithWhereWithoutFromUserInput | p2pTransferUpdateManyWithWhereWithoutFromUserInput[]
    deleteMany?: p2pTransferScalarWhereInput | p2pTransferScalarWhereInput[]
  }

  export type p2pTransferUpdateManyWithoutToUserNestedInput = {
    create?: XOR<p2pTransferCreateWithoutToUserInput, p2pTransferUncheckedCreateWithoutToUserInput> | p2pTransferCreateWithoutToUserInput[] | p2pTransferUncheckedCreateWithoutToUserInput[]
    connectOrCreate?: p2pTransferCreateOrConnectWithoutToUserInput | p2pTransferCreateOrConnectWithoutToUserInput[]
    upsert?: p2pTransferUpsertWithWhereUniqueWithoutToUserInput | p2pTransferUpsertWithWhereUniqueWithoutToUserInput[]
    createMany?: p2pTransferCreateManyToUserInputEnvelope
    set?: p2pTransferWhereUniqueInput | p2pTransferWhereUniqueInput[]
    disconnect?: p2pTransferWhereUniqueInput | p2pTransferWhereUniqueInput[]
    delete?: p2pTransferWhereUniqueInput | p2pTransferWhereUniqueInput[]
    connect?: p2pTransferWhereUniqueInput | p2pTransferWhereUniqueInput[]
    update?: p2pTransferUpdateWithWhereUniqueWithoutToUserInput | p2pTransferUpdateWithWhereUniqueWithoutToUserInput[]
    updateMany?: p2pTransferUpdateManyWithWhereWithoutToUserInput | p2pTransferUpdateManyWithWhereWithoutToUserInput[]
    deleteMany?: p2pTransferScalarWhereInput | p2pTransferScalarWhereInput[]
  }

  export type P2PRequestUpdateManyWithoutSenderNestedInput = {
    create?: XOR<P2PRequestCreateWithoutSenderInput, P2PRequestUncheckedCreateWithoutSenderInput> | P2PRequestCreateWithoutSenderInput[] | P2PRequestUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: P2PRequestCreateOrConnectWithoutSenderInput | P2PRequestCreateOrConnectWithoutSenderInput[]
    upsert?: P2PRequestUpsertWithWhereUniqueWithoutSenderInput | P2PRequestUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: P2PRequestCreateManySenderInputEnvelope
    set?: P2PRequestWhereUniqueInput | P2PRequestWhereUniqueInput[]
    disconnect?: P2PRequestWhereUniqueInput | P2PRequestWhereUniqueInput[]
    delete?: P2PRequestWhereUniqueInput | P2PRequestWhereUniqueInput[]
    connect?: P2PRequestWhereUniqueInput | P2PRequestWhereUniqueInput[]
    update?: P2PRequestUpdateWithWhereUniqueWithoutSenderInput | P2PRequestUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: P2PRequestUpdateManyWithWhereWithoutSenderInput | P2PRequestUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: P2PRequestScalarWhereInput | P2PRequestScalarWhereInput[]
  }

  export type P2PRequestUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<P2PRequestCreateWithoutReceiverInput, P2PRequestUncheckedCreateWithoutReceiverInput> | P2PRequestCreateWithoutReceiverInput[] | P2PRequestUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: P2PRequestCreateOrConnectWithoutReceiverInput | P2PRequestCreateOrConnectWithoutReceiverInput[]
    upsert?: P2PRequestUpsertWithWhereUniqueWithoutReceiverInput | P2PRequestUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: P2PRequestCreateManyReceiverInputEnvelope
    set?: P2PRequestWhereUniqueInput | P2PRequestWhereUniqueInput[]
    disconnect?: P2PRequestWhereUniqueInput | P2PRequestWhereUniqueInput[]
    delete?: P2PRequestWhereUniqueInput | P2PRequestWhereUniqueInput[]
    connect?: P2PRequestWhereUniqueInput | P2PRequestWhereUniqueInput[]
    update?: P2PRequestUpdateWithWhereUniqueWithoutReceiverInput | P2PRequestUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: P2PRequestUpdateManyWithWhereWithoutReceiverInput | P2PRequestUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: P2PRequestScalarWhereInput | P2PRequestScalarWhereInput[]
  }

  export type BillScheduleUpdateManyWithoutUserNestedInput = {
    create?: XOR<BillScheduleCreateWithoutUserInput, BillScheduleUncheckedCreateWithoutUserInput> | BillScheduleCreateWithoutUserInput[] | BillScheduleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BillScheduleCreateOrConnectWithoutUserInput | BillScheduleCreateOrConnectWithoutUserInput[]
    upsert?: BillScheduleUpsertWithWhereUniqueWithoutUserInput | BillScheduleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BillScheduleCreateManyUserInputEnvelope
    set?: BillScheduleWhereUniqueInput | BillScheduleWhereUniqueInput[]
    disconnect?: BillScheduleWhereUniqueInput | BillScheduleWhereUniqueInput[]
    delete?: BillScheduleWhereUniqueInput | BillScheduleWhereUniqueInput[]
    connect?: BillScheduleWhereUniqueInput | BillScheduleWhereUniqueInput[]
    update?: BillScheduleUpdateWithWhereUniqueWithoutUserInput | BillScheduleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BillScheduleUpdateManyWithWhereWithoutUserInput | BillScheduleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BillScheduleScalarWhereInput | BillScheduleScalarWhereInput[]
  }

  export type MerchantPaymentUpdateManyWithoutUserNestedInput = {
    create?: XOR<MerchantPaymentCreateWithoutUserInput, MerchantPaymentUncheckedCreateWithoutUserInput> | MerchantPaymentCreateWithoutUserInput[] | MerchantPaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MerchantPaymentCreateOrConnectWithoutUserInput | MerchantPaymentCreateOrConnectWithoutUserInput[]
    upsert?: MerchantPaymentUpsertWithWhereUniqueWithoutUserInput | MerchantPaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MerchantPaymentCreateManyUserInputEnvelope
    set?: MerchantPaymentWhereUniqueInput | MerchantPaymentWhereUniqueInput[]
    disconnect?: MerchantPaymentWhereUniqueInput | MerchantPaymentWhereUniqueInput[]
    delete?: MerchantPaymentWhereUniqueInput | MerchantPaymentWhereUniqueInput[]
    connect?: MerchantPaymentWhereUniqueInput | MerchantPaymentWhereUniqueInput[]
    update?: MerchantPaymentUpdateWithWhereUniqueWithoutUserInput | MerchantPaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MerchantPaymentUpdateManyWithWhereWithoutUserInput | MerchantPaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MerchantPaymentScalarWhereInput | MerchantPaymentScalarWhereInput[]
  }

  export type RechargeOrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<RechargeOrderCreateWithoutUserInput, RechargeOrderUncheckedCreateWithoutUserInput> | RechargeOrderCreateWithoutUserInput[] | RechargeOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RechargeOrderCreateOrConnectWithoutUserInput | RechargeOrderCreateOrConnectWithoutUserInput[]
    upsert?: RechargeOrderUpsertWithWhereUniqueWithoutUserInput | RechargeOrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RechargeOrderCreateManyUserInputEnvelope
    set?: RechargeOrderWhereUniqueInput | RechargeOrderWhereUniqueInput[]
    disconnect?: RechargeOrderWhereUniqueInput | RechargeOrderWhereUniqueInput[]
    delete?: RechargeOrderWhereUniqueInput | RechargeOrderWhereUniqueInput[]
    connect?: RechargeOrderWhereUniqueInput | RechargeOrderWhereUniqueInput[]
    update?: RechargeOrderUpdateWithWhereUniqueWithoutUserInput | RechargeOrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RechargeOrderUpdateManyWithWhereWithoutUserInput | RechargeOrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RechargeOrderScalarWhereInput | RechargeOrderScalarWhereInput[]
  }

  export type RewardUpdateManyWithoutUserNestedInput = {
    create?: XOR<RewardCreateWithoutUserInput, RewardUncheckedCreateWithoutUserInput> | RewardCreateWithoutUserInput[] | RewardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RewardCreateOrConnectWithoutUserInput | RewardCreateOrConnectWithoutUserInput[]
    upsert?: RewardUpsertWithWhereUniqueWithoutUserInput | RewardUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RewardCreateManyUserInputEnvelope
    set?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    disconnect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    delete?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    connect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    update?: RewardUpdateWithWhereUniqueWithoutUserInput | RewardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RewardUpdateManyWithWhereWithoutUserInput | RewardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RewardScalarWhereInput | RewardScalarWhereInput[]
  }

  export type ReferralUpdateManyWithoutReferrerNestedInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutReferrerInput | ReferralUpsertWithWhereUniqueWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutReferrerInput | ReferralUpdateWithWhereUniqueWithoutReferrerInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutReferrerInput | ReferralUpdateManyWithWhereWithoutReferrerInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type ReferralUpdateManyWithoutReferredNestedInput = {
    create?: XOR<ReferralCreateWithoutReferredInput, ReferralUncheckedCreateWithoutReferredInput> | ReferralCreateWithoutReferredInput[] | ReferralUncheckedCreateWithoutReferredInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferredInput | ReferralCreateOrConnectWithoutReferredInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutReferredInput | ReferralUpsertWithWhereUniqueWithoutReferredInput[]
    createMany?: ReferralCreateManyReferredInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutReferredInput | ReferralUpdateWithWhereUniqueWithoutReferredInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutReferredInput | ReferralUpdateManyWithWhereWithoutReferredInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type WrongSendRequestUpdateManyWithoutSenderNestedInput = {
    create?: XOR<WrongSendRequestCreateWithoutSenderInput, WrongSendRequestUncheckedCreateWithoutSenderInput> | WrongSendRequestCreateWithoutSenderInput[] | WrongSendRequestUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: WrongSendRequestCreateOrConnectWithoutSenderInput | WrongSendRequestCreateOrConnectWithoutSenderInput[]
    upsert?: WrongSendRequestUpsertWithWhereUniqueWithoutSenderInput | WrongSendRequestUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: WrongSendRequestCreateManySenderInputEnvelope
    set?: WrongSendRequestWhereUniqueInput | WrongSendRequestWhereUniqueInput[]
    disconnect?: WrongSendRequestWhereUniqueInput | WrongSendRequestWhereUniqueInput[]
    delete?: WrongSendRequestWhereUniqueInput | WrongSendRequestWhereUniqueInput[]
    connect?: WrongSendRequestWhereUniqueInput | WrongSendRequestWhereUniqueInput[]
    update?: WrongSendRequestUpdateWithWhereUniqueWithoutSenderInput | WrongSendRequestUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: WrongSendRequestUpdateManyWithWhereWithoutSenderInput | WrongSendRequestUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: WrongSendRequestScalarWhereInput | WrongSendRequestScalarWhereInput[]
  }

  export type BillSplitGroupUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<BillSplitGroupCreateWithoutCreatedByInput, BillSplitGroupUncheckedCreateWithoutCreatedByInput> | BillSplitGroupCreateWithoutCreatedByInput[] | BillSplitGroupUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BillSplitGroupCreateOrConnectWithoutCreatedByInput | BillSplitGroupCreateOrConnectWithoutCreatedByInput[]
    upsert?: BillSplitGroupUpsertWithWhereUniqueWithoutCreatedByInput | BillSplitGroupUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: BillSplitGroupCreateManyCreatedByInputEnvelope
    set?: BillSplitGroupWhereUniqueInput | BillSplitGroupWhereUniqueInput[]
    disconnect?: BillSplitGroupWhereUniqueInput | BillSplitGroupWhereUniqueInput[]
    delete?: BillSplitGroupWhereUniqueInput | BillSplitGroupWhereUniqueInput[]
    connect?: BillSplitGroupWhereUniqueInput | BillSplitGroupWhereUniqueInput[]
    update?: BillSplitGroupUpdateWithWhereUniqueWithoutCreatedByInput | BillSplitGroupUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: BillSplitGroupUpdateManyWithWhereWithoutCreatedByInput | BillSplitGroupUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: BillSplitGroupScalarWhereInput | BillSplitGroupScalarWhereInput[]
  }

  export type BillSplitMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<BillSplitMemberCreateWithoutUserInput, BillSplitMemberUncheckedCreateWithoutUserInput> | BillSplitMemberCreateWithoutUserInput[] | BillSplitMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BillSplitMemberCreateOrConnectWithoutUserInput | BillSplitMemberCreateOrConnectWithoutUserInput[]
    upsert?: BillSplitMemberUpsertWithWhereUniqueWithoutUserInput | BillSplitMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BillSplitMemberCreateManyUserInputEnvelope
    set?: BillSplitMemberWhereUniqueInput | BillSplitMemberWhereUniqueInput[]
    disconnect?: BillSplitMemberWhereUniqueInput | BillSplitMemberWhereUniqueInput[]
    delete?: BillSplitMemberWhereUniqueInput | BillSplitMemberWhereUniqueInput[]
    connect?: BillSplitMemberWhereUniqueInput | BillSplitMemberWhereUniqueInput[]
    update?: BillSplitMemberUpdateWithWhereUniqueWithoutUserInput | BillSplitMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BillSplitMemberUpdateManyWithWhereWithoutUserInput | BillSplitMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BillSplitMemberScalarWhereInput | BillSplitMemberScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OnRampTransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OnRampTransactionCreateWithoutUserInput, OnRampTransactionUncheckedCreateWithoutUserInput> | OnRampTransactionCreateWithoutUserInput[] | OnRampTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OnRampTransactionCreateOrConnectWithoutUserInput | OnRampTransactionCreateOrConnectWithoutUserInput[]
    upsert?: OnRampTransactionUpsertWithWhereUniqueWithoutUserInput | OnRampTransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OnRampTransactionCreateManyUserInputEnvelope
    set?: OnRampTransactionWhereUniqueInput | OnRampTransactionWhereUniqueInput[]
    disconnect?: OnRampTransactionWhereUniqueInput | OnRampTransactionWhereUniqueInput[]
    delete?: OnRampTransactionWhereUniqueInput | OnRampTransactionWhereUniqueInput[]
    connect?: OnRampTransactionWhereUniqueInput | OnRampTransactionWhereUniqueInput[]
    update?: OnRampTransactionUpdateWithWhereUniqueWithoutUserInput | OnRampTransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OnRampTransactionUpdateManyWithWhereWithoutUserInput | OnRampTransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OnRampTransactionScalarWhereInput | OnRampTransactionScalarWhereInput[]
  }

  export type BalanceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BalanceCreateWithoutUserInput, BalanceUncheckedCreateWithoutUserInput> | BalanceCreateWithoutUserInput[] | BalanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BalanceCreateOrConnectWithoutUserInput | BalanceCreateOrConnectWithoutUserInput[]
    upsert?: BalanceUpsertWithWhereUniqueWithoutUserInput | BalanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BalanceCreateManyUserInputEnvelope
    set?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    disconnect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    delete?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    connect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    update?: BalanceUpdateWithWhereUniqueWithoutUserInput | BalanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BalanceUpdateManyWithWhereWithoutUserInput | BalanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BalanceScalarWhereInput | BalanceScalarWhereInput[]
  }

  export type p2pTransferUncheckedUpdateManyWithoutFromUserNestedInput = {
    create?: XOR<p2pTransferCreateWithoutFromUserInput, p2pTransferUncheckedCreateWithoutFromUserInput> | p2pTransferCreateWithoutFromUserInput[] | p2pTransferUncheckedCreateWithoutFromUserInput[]
    connectOrCreate?: p2pTransferCreateOrConnectWithoutFromUserInput | p2pTransferCreateOrConnectWithoutFromUserInput[]
    upsert?: p2pTransferUpsertWithWhereUniqueWithoutFromUserInput | p2pTransferUpsertWithWhereUniqueWithoutFromUserInput[]
    createMany?: p2pTransferCreateManyFromUserInputEnvelope
    set?: p2pTransferWhereUniqueInput | p2pTransferWhereUniqueInput[]
    disconnect?: p2pTransferWhereUniqueInput | p2pTransferWhereUniqueInput[]
    delete?: p2pTransferWhereUniqueInput | p2pTransferWhereUniqueInput[]
    connect?: p2pTransferWhereUniqueInput | p2pTransferWhereUniqueInput[]
    update?: p2pTransferUpdateWithWhereUniqueWithoutFromUserInput | p2pTransferUpdateWithWhereUniqueWithoutFromUserInput[]
    updateMany?: p2pTransferUpdateManyWithWhereWithoutFromUserInput | p2pTransferUpdateManyWithWhereWithoutFromUserInput[]
    deleteMany?: p2pTransferScalarWhereInput | p2pTransferScalarWhereInput[]
  }

  export type p2pTransferUncheckedUpdateManyWithoutToUserNestedInput = {
    create?: XOR<p2pTransferCreateWithoutToUserInput, p2pTransferUncheckedCreateWithoutToUserInput> | p2pTransferCreateWithoutToUserInput[] | p2pTransferUncheckedCreateWithoutToUserInput[]
    connectOrCreate?: p2pTransferCreateOrConnectWithoutToUserInput | p2pTransferCreateOrConnectWithoutToUserInput[]
    upsert?: p2pTransferUpsertWithWhereUniqueWithoutToUserInput | p2pTransferUpsertWithWhereUniqueWithoutToUserInput[]
    createMany?: p2pTransferCreateManyToUserInputEnvelope
    set?: p2pTransferWhereUniqueInput | p2pTransferWhereUniqueInput[]
    disconnect?: p2pTransferWhereUniqueInput | p2pTransferWhereUniqueInput[]
    delete?: p2pTransferWhereUniqueInput | p2pTransferWhereUniqueInput[]
    connect?: p2pTransferWhereUniqueInput | p2pTransferWhereUniqueInput[]
    update?: p2pTransferUpdateWithWhereUniqueWithoutToUserInput | p2pTransferUpdateWithWhereUniqueWithoutToUserInput[]
    updateMany?: p2pTransferUpdateManyWithWhereWithoutToUserInput | p2pTransferUpdateManyWithWhereWithoutToUserInput[]
    deleteMany?: p2pTransferScalarWhereInput | p2pTransferScalarWhereInput[]
  }

  export type P2PRequestUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<P2PRequestCreateWithoutSenderInput, P2PRequestUncheckedCreateWithoutSenderInput> | P2PRequestCreateWithoutSenderInput[] | P2PRequestUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: P2PRequestCreateOrConnectWithoutSenderInput | P2PRequestCreateOrConnectWithoutSenderInput[]
    upsert?: P2PRequestUpsertWithWhereUniqueWithoutSenderInput | P2PRequestUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: P2PRequestCreateManySenderInputEnvelope
    set?: P2PRequestWhereUniqueInput | P2PRequestWhereUniqueInput[]
    disconnect?: P2PRequestWhereUniqueInput | P2PRequestWhereUniqueInput[]
    delete?: P2PRequestWhereUniqueInput | P2PRequestWhereUniqueInput[]
    connect?: P2PRequestWhereUniqueInput | P2PRequestWhereUniqueInput[]
    update?: P2PRequestUpdateWithWhereUniqueWithoutSenderInput | P2PRequestUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: P2PRequestUpdateManyWithWhereWithoutSenderInput | P2PRequestUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: P2PRequestScalarWhereInput | P2PRequestScalarWhereInput[]
  }

  export type P2PRequestUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<P2PRequestCreateWithoutReceiverInput, P2PRequestUncheckedCreateWithoutReceiverInput> | P2PRequestCreateWithoutReceiverInput[] | P2PRequestUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: P2PRequestCreateOrConnectWithoutReceiverInput | P2PRequestCreateOrConnectWithoutReceiverInput[]
    upsert?: P2PRequestUpsertWithWhereUniqueWithoutReceiverInput | P2PRequestUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: P2PRequestCreateManyReceiverInputEnvelope
    set?: P2PRequestWhereUniqueInput | P2PRequestWhereUniqueInput[]
    disconnect?: P2PRequestWhereUniqueInput | P2PRequestWhereUniqueInput[]
    delete?: P2PRequestWhereUniqueInput | P2PRequestWhereUniqueInput[]
    connect?: P2PRequestWhereUniqueInput | P2PRequestWhereUniqueInput[]
    update?: P2PRequestUpdateWithWhereUniqueWithoutReceiverInput | P2PRequestUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: P2PRequestUpdateManyWithWhereWithoutReceiverInput | P2PRequestUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: P2PRequestScalarWhereInput | P2PRequestScalarWhereInput[]
  }

  export type BillScheduleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BillScheduleCreateWithoutUserInput, BillScheduleUncheckedCreateWithoutUserInput> | BillScheduleCreateWithoutUserInput[] | BillScheduleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BillScheduleCreateOrConnectWithoutUserInput | BillScheduleCreateOrConnectWithoutUserInput[]
    upsert?: BillScheduleUpsertWithWhereUniqueWithoutUserInput | BillScheduleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BillScheduleCreateManyUserInputEnvelope
    set?: BillScheduleWhereUniqueInput | BillScheduleWhereUniqueInput[]
    disconnect?: BillScheduleWhereUniqueInput | BillScheduleWhereUniqueInput[]
    delete?: BillScheduleWhereUniqueInput | BillScheduleWhereUniqueInput[]
    connect?: BillScheduleWhereUniqueInput | BillScheduleWhereUniqueInput[]
    update?: BillScheduleUpdateWithWhereUniqueWithoutUserInput | BillScheduleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BillScheduleUpdateManyWithWhereWithoutUserInput | BillScheduleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BillScheduleScalarWhereInput | BillScheduleScalarWhereInput[]
  }

  export type MerchantPaymentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MerchantPaymentCreateWithoutUserInput, MerchantPaymentUncheckedCreateWithoutUserInput> | MerchantPaymentCreateWithoutUserInput[] | MerchantPaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MerchantPaymentCreateOrConnectWithoutUserInput | MerchantPaymentCreateOrConnectWithoutUserInput[]
    upsert?: MerchantPaymentUpsertWithWhereUniqueWithoutUserInput | MerchantPaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MerchantPaymentCreateManyUserInputEnvelope
    set?: MerchantPaymentWhereUniqueInput | MerchantPaymentWhereUniqueInput[]
    disconnect?: MerchantPaymentWhereUniqueInput | MerchantPaymentWhereUniqueInput[]
    delete?: MerchantPaymentWhereUniqueInput | MerchantPaymentWhereUniqueInput[]
    connect?: MerchantPaymentWhereUniqueInput | MerchantPaymentWhereUniqueInput[]
    update?: MerchantPaymentUpdateWithWhereUniqueWithoutUserInput | MerchantPaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MerchantPaymentUpdateManyWithWhereWithoutUserInput | MerchantPaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MerchantPaymentScalarWhereInput | MerchantPaymentScalarWhereInput[]
  }

  export type RechargeOrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RechargeOrderCreateWithoutUserInput, RechargeOrderUncheckedCreateWithoutUserInput> | RechargeOrderCreateWithoutUserInput[] | RechargeOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RechargeOrderCreateOrConnectWithoutUserInput | RechargeOrderCreateOrConnectWithoutUserInput[]
    upsert?: RechargeOrderUpsertWithWhereUniqueWithoutUserInput | RechargeOrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RechargeOrderCreateManyUserInputEnvelope
    set?: RechargeOrderWhereUniqueInput | RechargeOrderWhereUniqueInput[]
    disconnect?: RechargeOrderWhereUniqueInput | RechargeOrderWhereUniqueInput[]
    delete?: RechargeOrderWhereUniqueInput | RechargeOrderWhereUniqueInput[]
    connect?: RechargeOrderWhereUniqueInput | RechargeOrderWhereUniqueInput[]
    update?: RechargeOrderUpdateWithWhereUniqueWithoutUserInput | RechargeOrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RechargeOrderUpdateManyWithWhereWithoutUserInput | RechargeOrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RechargeOrderScalarWhereInput | RechargeOrderScalarWhereInput[]
  }

  export type RewardUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RewardCreateWithoutUserInput, RewardUncheckedCreateWithoutUserInput> | RewardCreateWithoutUserInput[] | RewardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RewardCreateOrConnectWithoutUserInput | RewardCreateOrConnectWithoutUserInput[]
    upsert?: RewardUpsertWithWhereUniqueWithoutUserInput | RewardUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RewardCreateManyUserInputEnvelope
    set?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    disconnect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    delete?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    connect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    update?: RewardUpdateWithWhereUniqueWithoutUserInput | RewardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RewardUpdateManyWithWhereWithoutUserInput | RewardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RewardScalarWhereInput | RewardScalarWhereInput[]
  }

  export type ReferralUncheckedUpdateManyWithoutReferrerNestedInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutReferrerInput | ReferralUpsertWithWhereUniqueWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutReferrerInput | ReferralUpdateWithWhereUniqueWithoutReferrerInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutReferrerInput | ReferralUpdateManyWithWhereWithoutReferrerInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type ReferralUncheckedUpdateManyWithoutReferredNestedInput = {
    create?: XOR<ReferralCreateWithoutReferredInput, ReferralUncheckedCreateWithoutReferredInput> | ReferralCreateWithoutReferredInput[] | ReferralUncheckedCreateWithoutReferredInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferredInput | ReferralCreateOrConnectWithoutReferredInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutReferredInput | ReferralUpsertWithWhereUniqueWithoutReferredInput[]
    createMany?: ReferralCreateManyReferredInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutReferredInput | ReferralUpdateWithWhereUniqueWithoutReferredInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutReferredInput | ReferralUpdateManyWithWhereWithoutReferredInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type WrongSendRequestUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<WrongSendRequestCreateWithoutSenderInput, WrongSendRequestUncheckedCreateWithoutSenderInput> | WrongSendRequestCreateWithoutSenderInput[] | WrongSendRequestUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: WrongSendRequestCreateOrConnectWithoutSenderInput | WrongSendRequestCreateOrConnectWithoutSenderInput[]
    upsert?: WrongSendRequestUpsertWithWhereUniqueWithoutSenderInput | WrongSendRequestUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: WrongSendRequestCreateManySenderInputEnvelope
    set?: WrongSendRequestWhereUniqueInput | WrongSendRequestWhereUniqueInput[]
    disconnect?: WrongSendRequestWhereUniqueInput | WrongSendRequestWhereUniqueInput[]
    delete?: WrongSendRequestWhereUniqueInput | WrongSendRequestWhereUniqueInput[]
    connect?: WrongSendRequestWhereUniqueInput | WrongSendRequestWhereUniqueInput[]
    update?: WrongSendRequestUpdateWithWhereUniqueWithoutSenderInput | WrongSendRequestUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: WrongSendRequestUpdateManyWithWhereWithoutSenderInput | WrongSendRequestUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: WrongSendRequestScalarWhereInput | WrongSendRequestScalarWhereInput[]
  }

  export type BillSplitGroupUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<BillSplitGroupCreateWithoutCreatedByInput, BillSplitGroupUncheckedCreateWithoutCreatedByInput> | BillSplitGroupCreateWithoutCreatedByInput[] | BillSplitGroupUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BillSplitGroupCreateOrConnectWithoutCreatedByInput | BillSplitGroupCreateOrConnectWithoutCreatedByInput[]
    upsert?: BillSplitGroupUpsertWithWhereUniqueWithoutCreatedByInput | BillSplitGroupUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: BillSplitGroupCreateManyCreatedByInputEnvelope
    set?: BillSplitGroupWhereUniqueInput | BillSplitGroupWhereUniqueInput[]
    disconnect?: BillSplitGroupWhereUniqueInput | BillSplitGroupWhereUniqueInput[]
    delete?: BillSplitGroupWhereUniqueInput | BillSplitGroupWhereUniqueInput[]
    connect?: BillSplitGroupWhereUniqueInput | BillSplitGroupWhereUniqueInput[]
    update?: BillSplitGroupUpdateWithWhereUniqueWithoutCreatedByInput | BillSplitGroupUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: BillSplitGroupUpdateManyWithWhereWithoutCreatedByInput | BillSplitGroupUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: BillSplitGroupScalarWhereInput | BillSplitGroupScalarWhereInput[]
  }

  export type BillSplitMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BillSplitMemberCreateWithoutUserInput, BillSplitMemberUncheckedCreateWithoutUserInput> | BillSplitMemberCreateWithoutUserInput[] | BillSplitMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BillSplitMemberCreateOrConnectWithoutUserInput | BillSplitMemberCreateOrConnectWithoutUserInput[]
    upsert?: BillSplitMemberUpsertWithWhereUniqueWithoutUserInput | BillSplitMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BillSplitMemberCreateManyUserInputEnvelope
    set?: BillSplitMemberWhereUniqueInput | BillSplitMemberWhereUniqueInput[]
    disconnect?: BillSplitMemberWhereUniqueInput | BillSplitMemberWhereUniqueInput[]
    delete?: BillSplitMemberWhereUniqueInput | BillSplitMemberWhereUniqueInput[]
    connect?: BillSplitMemberWhereUniqueInput | BillSplitMemberWhereUniqueInput[]
    update?: BillSplitMemberUpdateWithWhereUniqueWithoutUserInput | BillSplitMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BillSplitMemberUpdateManyWithWhereWithoutUserInput | BillSplitMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BillSplitMemberScalarWhereInput | BillSplitMemberScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSentTransfersInput = {
    create?: XOR<UserCreateWithoutSentTransfersInput, UserUncheckedCreateWithoutSentTransfersInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentTransfersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedTransfersInput = {
    create?: XOR<UserCreateWithoutReceivedTransfersInput, UserUncheckedCreateWithoutReceivedTransfersInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedTransfersInput
    connect?: UserWhereUniqueInput
  }

  export type WrongSendRequestCreateNestedOneWithoutTransactionInput = {
    create?: XOR<WrongSendRequestCreateWithoutTransactionInput, WrongSendRequestUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: WrongSendRequestCreateOrConnectWithoutTransactionInput
    connect?: WrongSendRequestWhereUniqueInput
  }

  export type BillSplitPaymentCreateNestedOneWithoutP2pTransferInput = {
    create?: XOR<BillSplitPaymentCreateWithoutP2pTransferInput, BillSplitPaymentUncheckedCreateWithoutP2pTransferInput>
    connectOrCreate?: BillSplitPaymentCreateOrConnectWithoutP2pTransferInput
    connect?: BillSplitPaymentWhereUniqueInput
  }

  export type WrongSendRequestUncheckedCreateNestedOneWithoutTransactionInput = {
    create?: XOR<WrongSendRequestCreateWithoutTransactionInput, WrongSendRequestUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: WrongSendRequestCreateOrConnectWithoutTransactionInput
    connect?: WrongSendRequestWhereUniqueInput
  }

  export type BillSplitPaymentUncheckedCreateNestedOneWithoutP2pTransferInput = {
    create?: XOR<BillSplitPaymentCreateWithoutP2pTransferInput, BillSplitPaymentUncheckedCreateWithoutP2pTransferInput>
    connectOrCreate?: BillSplitPaymentCreateOrConnectWithoutP2pTransferInput
    connect?: BillSplitPaymentWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type UserUpdateOneRequiredWithoutSentTransfersNestedInput = {
    create?: XOR<UserCreateWithoutSentTransfersInput, UserUncheckedCreateWithoutSentTransfersInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentTransfersInput
    upsert?: UserUpsertWithoutSentTransfersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentTransfersInput, UserUpdateWithoutSentTransfersInput>, UserUncheckedUpdateWithoutSentTransfersInput>
  }

  export type UserUpdateOneWithoutReceivedTransfersNestedInput = {
    create?: XOR<UserCreateWithoutReceivedTransfersInput, UserUncheckedCreateWithoutReceivedTransfersInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedTransfersInput
    upsert?: UserUpsertWithoutReceivedTransfersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedTransfersInput, UserUpdateWithoutReceivedTransfersInput>, UserUncheckedUpdateWithoutReceivedTransfersInput>
  }

  export type WrongSendRequestUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<WrongSendRequestCreateWithoutTransactionInput, WrongSendRequestUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: WrongSendRequestCreateOrConnectWithoutTransactionInput
    upsert?: WrongSendRequestUpsertWithoutTransactionInput
    disconnect?: WrongSendRequestWhereInput | boolean
    delete?: WrongSendRequestWhereInput | boolean
    connect?: WrongSendRequestWhereUniqueInput
    update?: XOR<XOR<WrongSendRequestUpdateToOneWithWhereWithoutTransactionInput, WrongSendRequestUpdateWithoutTransactionInput>, WrongSendRequestUncheckedUpdateWithoutTransactionInput>
  }

  export type BillSplitPaymentUpdateOneWithoutP2pTransferNestedInput = {
    create?: XOR<BillSplitPaymentCreateWithoutP2pTransferInput, BillSplitPaymentUncheckedCreateWithoutP2pTransferInput>
    connectOrCreate?: BillSplitPaymentCreateOrConnectWithoutP2pTransferInput
    upsert?: BillSplitPaymentUpsertWithoutP2pTransferInput
    disconnect?: BillSplitPaymentWhereInput | boolean
    delete?: BillSplitPaymentWhereInput | boolean
    connect?: BillSplitPaymentWhereUniqueInput
    update?: XOR<XOR<BillSplitPaymentUpdateToOneWithWhereWithoutP2pTransferInput, BillSplitPaymentUpdateWithoutP2pTransferInput>, BillSplitPaymentUncheckedUpdateWithoutP2pTransferInput>
  }

  export type WrongSendRequestUncheckedUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<WrongSendRequestCreateWithoutTransactionInput, WrongSendRequestUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: WrongSendRequestCreateOrConnectWithoutTransactionInput
    upsert?: WrongSendRequestUpsertWithoutTransactionInput
    disconnect?: WrongSendRequestWhereInput | boolean
    delete?: WrongSendRequestWhereInput | boolean
    connect?: WrongSendRequestWhereUniqueInput
    update?: XOR<XOR<WrongSendRequestUpdateToOneWithWhereWithoutTransactionInput, WrongSendRequestUpdateWithoutTransactionInput>, WrongSendRequestUncheckedUpdateWithoutTransactionInput>
  }

  export type BillSplitPaymentUncheckedUpdateOneWithoutP2pTransferNestedInput = {
    create?: XOR<BillSplitPaymentCreateWithoutP2pTransferInput, BillSplitPaymentUncheckedCreateWithoutP2pTransferInput>
    connectOrCreate?: BillSplitPaymentCreateOrConnectWithoutP2pTransferInput
    upsert?: BillSplitPaymentUpsertWithoutP2pTransferInput
    disconnect?: BillSplitPaymentWhereInput | boolean
    delete?: BillSplitPaymentWhereInput | boolean
    connect?: BillSplitPaymentWhereUniqueInput
    update?: XOR<XOR<BillSplitPaymentUpdateToOneWithWhereWithoutP2pTransferInput, BillSplitPaymentUpdateWithoutP2pTransferInput>, BillSplitPaymentUncheckedUpdateWithoutP2pTransferInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type BillScheduleCreateNestedManyWithoutMerchantInput = {
    create?: XOR<BillScheduleCreateWithoutMerchantInput, BillScheduleUncheckedCreateWithoutMerchantInput> | BillScheduleCreateWithoutMerchantInput[] | BillScheduleUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: BillScheduleCreateOrConnectWithoutMerchantInput | BillScheduleCreateOrConnectWithoutMerchantInput[]
    createMany?: BillScheduleCreateManyMerchantInputEnvelope
    connect?: BillScheduleWhereUniqueInput | BillScheduleWhereUniqueInput[]
  }

  export type MerchantPaymentCreateNestedManyWithoutMerchantInput = {
    create?: XOR<MerchantPaymentCreateWithoutMerchantInput, MerchantPaymentUncheckedCreateWithoutMerchantInput> | MerchantPaymentCreateWithoutMerchantInput[] | MerchantPaymentUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: MerchantPaymentCreateOrConnectWithoutMerchantInput | MerchantPaymentCreateOrConnectWithoutMerchantInput[]
    createMany?: MerchantPaymentCreateManyMerchantInputEnvelope
    connect?: MerchantPaymentWhereUniqueInput | MerchantPaymentWhereUniqueInput[]
  }

  export type BillScheduleUncheckedCreateNestedManyWithoutMerchantInput = {
    create?: XOR<BillScheduleCreateWithoutMerchantInput, BillScheduleUncheckedCreateWithoutMerchantInput> | BillScheduleCreateWithoutMerchantInput[] | BillScheduleUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: BillScheduleCreateOrConnectWithoutMerchantInput | BillScheduleCreateOrConnectWithoutMerchantInput[]
    createMany?: BillScheduleCreateManyMerchantInputEnvelope
    connect?: BillScheduleWhereUniqueInput | BillScheduleWhereUniqueInput[]
  }

  export type MerchantPaymentUncheckedCreateNestedManyWithoutMerchantInput = {
    create?: XOR<MerchantPaymentCreateWithoutMerchantInput, MerchantPaymentUncheckedCreateWithoutMerchantInput> | MerchantPaymentCreateWithoutMerchantInput[] | MerchantPaymentUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: MerchantPaymentCreateOrConnectWithoutMerchantInput | MerchantPaymentCreateOrConnectWithoutMerchantInput[]
    createMany?: MerchantPaymentCreateManyMerchantInputEnvelope
    connect?: MerchantPaymentWhereUniqueInput | MerchantPaymentWhereUniqueInput[]
  }

  export type EnumAuthTypeFieldUpdateOperationsInput = {
    set?: $Enums.AuthType
  }

  export type BillScheduleUpdateManyWithoutMerchantNestedInput = {
    create?: XOR<BillScheduleCreateWithoutMerchantInput, BillScheduleUncheckedCreateWithoutMerchantInput> | BillScheduleCreateWithoutMerchantInput[] | BillScheduleUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: BillScheduleCreateOrConnectWithoutMerchantInput | BillScheduleCreateOrConnectWithoutMerchantInput[]
    upsert?: BillScheduleUpsertWithWhereUniqueWithoutMerchantInput | BillScheduleUpsertWithWhereUniqueWithoutMerchantInput[]
    createMany?: BillScheduleCreateManyMerchantInputEnvelope
    set?: BillScheduleWhereUniqueInput | BillScheduleWhereUniqueInput[]
    disconnect?: BillScheduleWhereUniqueInput | BillScheduleWhereUniqueInput[]
    delete?: BillScheduleWhereUniqueInput | BillScheduleWhereUniqueInput[]
    connect?: BillScheduleWhereUniqueInput | BillScheduleWhereUniqueInput[]
    update?: BillScheduleUpdateWithWhereUniqueWithoutMerchantInput | BillScheduleUpdateWithWhereUniqueWithoutMerchantInput[]
    updateMany?: BillScheduleUpdateManyWithWhereWithoutMerchantInput | BillScheduleUpdateManyWithWhereWithoutMerchantInput[]
    deleteMany?: BillScheduleScalarWhereInput | BillScheduleScalarWhereInput[]
  }

  export type MerchantPaymentUpdateManyWithoutMerchantNestedInput = {
    create?: XOR<MerchantPaymentCreateWithoutMerchantInput, MerchantPaymentUncheckedCreateWithoutMerchantInput> | MerchantPaymentCreateWithoutMerchantInput[] | MerchantPaymentUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: MerchantPaymentCreateOrConnectWithoutMerchantInput | MerchantPaymentCreateOrConnectWithoutMerchantInput[]
    upsert?: MerchantPaymentUpsertWithWhereUniqueWithoutMerchantInput | MerchantPaymentUpsertWithWhereUniqueWithoutMerchantInput[]
    createMany?: MerchantPaymentCreateManyMerchantInputEnvelope
    set?: MerchantPaymentWhereUniqueInput | MerchantPaymentWhereUniqueInput[]
    disconnect?: MerchantPaymentWhereUniqueInput | MerchantPaymentWhereUniqueInput[]
    delete?: MerchantPaymentWhereUniqueInput | MerchantPaymentWhereUniqueInput[]
    connect?: MerchantPaymentWhereUniqueInput | MerchantPaymentWhereUniqueInput[]
    update?: MerchantPaymentUpdateWithWhereUniqueWithoutMerchantInput | MerchantPaymentUpdateWithWhereUniqueWithoutMerchantInput[]
    updateMany?: MerchantPaymentUpdateManyWithWhereWithoutMerchantInput | MerchantPaymentUpdateManyWithWhereWithoutMerchantInput[]
    deleteMany?: MerchantPaymentScalarWhereInput | MerchantPaymentScalarWhereInput[]
  }

  export type BillScheduleUncheckedUpdateManyWithoutMerchantNestedInput = {
    create?: XOR<BillScheduleCreateWithoutMerchantInput, BillScheduleUncheckedCreateWithoutMerchantInput> | BillScheduleCreateWithoutMerchantInput[] | BillScheduleUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: BillScheduleCreateOrConnectWithoutMerchantInput | BillScheduleCreateOrConnectWithoutMerchantInput[]
    upsert?: BillScheduleUpsertWithWhereUniqueWithoutMerchantInput | BillScheduleUpsertWithWhereUniqueWithoutMerchantInput[]
    createMany?: BillScheduleCreateManyMerchantInputEnvelope
    set?: BillScheduleWhereUniqueInput | BillScheduleWhereUniqueInput[]
    disconnect?: BillScheduleWhereUniqueInput | BillScheduleWhereUniqueInput[]
    delete?: BillScheduleWhereUniqueInput | BillScheduleWhereUniqueInput[]
    connect?: BillScheduleWhereUniqueInput | BillScheduleWhereUniqueInput[]
    update?: BillScheduleUpdateWithWhereUniqueWithoutMerchantInput | BillScheduleUpdateWithWhereUniqueWithoutMerchantInput[]
    updateMany?: BillScheduleUpdateManyWithWhereWithoutMerchantInput | BillScheduleUpdateManyWithWhereWithoutMerchantInput[]
    deleteMany?: BillScheduleScalarWhereInput | BillScheduleScalarWhereInput[]
  }

  export type MerchantPaymentUncheckedUpdateManyWithoutMerchantNestedInput = {
    create?: XOR<MerchantPaymentCreateWithoutMerchantInput, MerchantPaymentUncheckedCreateWithoutMerchantInput> | MerchantPaymentCreateWithoutMerchantInput[] | MerchantPaymentUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: MerchantPaymentCreateOrConnectWithoutMerchantInput | MerchantPaymentCreateOrConnectWithoutMerchantInput[]
    upsert?: MerchantPaymentUpsertWithWhereUniqueWithoutMerchantInput | MerchantPaymentUpsertWithWhereUniqueWithoutMerchantInput[]
    createMany?: MerchantPaymentCreateManyMerchantInputEnvelope
    set?: MerchantPaymentWhereUniqueInput | MerchantPaymentWhereUniqueInput[]
    disconnect?: MerchantPaymentWhereUniqueInput | MerchantPaymentWhereUniqueInput[]
    delete?: MerchantPaymentWhereUniqueInput | MerchantPaymentWhereUniqueInput[]
    connect?: MerchantPaymentWhereUniqueInput | MerchantPaymentWhereUniqueInput[]
    update?: MerchantPaymentUpdateWithWhereUniqueWithoutMerchantInput | MerchantPaymentUpdateWithWhereUniqueWithoutMerchantInput[]
    updateMany?: MerchantPaymentUpdateManyWithWhereWithoutMerchantInput | MerchantPaymentUpdateManyWithWhereWithoutMerchantInput[]
    deleteMany?: MerchantPaymentScalarWhereInput | MerchantPaymentScalarWhereInput[]
  }

  export type MerchantCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<MerchantCreateWithoutPaymentsInput, MerchantUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutPaymentsInput
    connect?: MerchantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMerchantPaymentsInput = {
    create?: XOR<UserCreateWithoutMerchantPaymentsInput, UserUncheckedCreateWithoutMerchantPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMerchantPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type MerchantUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<MerchantCreateWithoutPaymentsInput, MerchantUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutPaymentsInput
    upsert?: MerchantUpsertWithoutPaymentsInput
    connect?: MerchantWhereUniqueInput
    update?: XOR<XOR<MerchantUpdateToOneWithWhereWithoutPaymentsInput, MerchantUpdateWithoutPaymentsInput>, MerchantUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateOneWithoutMerchantPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutMerchantPaymentsInput, UserUncheckedCreateWithoutMerchantPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMerchantPaymentsInput
    upsert?: UserUpsertWithoutMerchantPaymentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMerchantPaymentsInput, UserUpdateWithoutMerchantPaymentsInput>, UserUncheckedUpdateWithoutMerchantPaymentsInput>
  }

  export type UserCreateNestedOneWithoutOnRampTransactionInput = {
    create?: XOR<UserCreateWithoutOnRampTransactionInput, UserUncheckedCreateWithoutOnRampTransactionInput>
    connectOrCreate?: UserCreateOrConnectWithoutOnRampTransactionInput
    connect?: UserWhereUniqueInput
  }

  export type EnumOnRampStatusFieldUpdateOperationsInput = {
    set?: $Enums.OnRampStatus
  }

  export type UserUpdateOneRequiredWithoutOnRampTransactionNestedInput = {
    create?: XOR<UserCreateWithoutOnRampTransactionInput, UserUncheckedCreateWithoutOnRampTransactionInput>
    connectOrCreate?: UserCreateOrConnectWithoutOnRampTransactionInput
    upsert?: UserUpsertWithoutOnRampTransactionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOnRampTransactionInput, UserUpdateWithoutOnRampTransactionInput>, UserUncheckedUpdateWithoutOnRampTransactionInput>
  }

  export type UserCreateNestedOneWithoutSentRequestsInput = {
    create?: XOR<UserCreateWithoutSentRequestsInput, UserUncheckedCreateWithoutSentRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedRequestsInput = {
    create?: XOR<UserCreateWithoutReceivedRequestsInput, UserUncheckedCreateWithoutReceivedRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type BillSplitMemberCreateNestedOneWithoutRequestInput = {
    create?: XOR<BillSplitMemberCreateWithoutRequestInput, BillSplitMemberUncheckedCreateWithoutRequestInput>
    connectOrCreate?: BillSplitMemberCreateOrConnectWithoutRequestInput
    connect?: BillSplitMemberWhereUniqueInput
  }

  export type EnumP2PRequestStatusFieldUpdateOperationsInput = {
    set?: $Enums.P2PRequestStatus
  }

  export type UserUpdateOneRequiredWithoutSentRequestsNestedInput = {
    create?: XOR<UserCreateWithoutSentRequestsInput, UserUncheckedCreateWithoutSentRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentRequestsInput
    upsert?: UserUpsertWithoutSentRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentRequestsInput, UserUpdateWithoutSentRequestsInput>, UserUncheckedUpdateWithoutSentRequestsInput>
  }

  export type UserUpdateOneWithoutReceivedRequestsNestedInput = {
    create?: XOR<UserCreateWithoutReceivedRequestsInput, UserUncheckedCreateWithoutReceivedRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedRequestsInput
    upsert?: UserUpsertWithoutReceivedRequestsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedRequestsInput, UserUpdateWithoutReceivedRequestsInput>, UserUncheckedUpdateWithoutReceivedRequestsInput>
  }

  export type BillSplitMemberUpdateOneWithoutRequestNestedInput = {
    create?: XOR<BillSplitMemberCreateWithoutRequestInput, BillSplitMemberUncheckedCreateWithoutRequestInput>
    connectOrCreate?: BillSplitMemberCreateOrConnectWithoutRequestInput
    upsert?: BillSplitMemberUpsertWithoutRequestInput
    disconnect?: BillSplitMemberWhereInput | boolean
    delete?: BillSplitMemberWhereInput | boolean
    connect?: BillSplitMemberWhereUniqueInput
    update?: XOR<XOR<BillSplitMemberUpdateToOneWithWhereWithoutRequestInput, BillSplitMemberUpdateWithoutRequestInput>, BillSplitMemberUncheckedUpdateWithoutRequestInput>
  }

  export type UserCreateNestedOneWithoutBillSchedulesInput = {
    create?: XOR<UserCreateWithoutBillSchedulesInput, UserUncheckedCreateWithoutBillSchedulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBillSchedulesInput
    connect?: UserWhereUniqueInput
  }

  export type MerchantCreateNestedOneWithoutBillSchedulesInput = {
    create?: XOR<MerchantCreateWithoutBillSchedulesInput, MerchantUncheckedCreateWithoutBillSchedulesInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutBillSchedulesInput
    connect?: MerchantWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBillSchedulesNestedInput = {
    create?: XOR<UserCreateWithoutBillSchedulesInput, UserUncheckedCreateWithoutBillSchedulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBillSchedulesInput
    upsert?: UserUpsertWithoutBillSchedulesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBillSchedulesInput, UserUpdateWithoutBillSchedulesInput>, UserUncheckedUpdateWithoutBillSchedulesInput>
  }

  export type MerchantUpdateOneWithoutBillSchedulesNestedInput = {
    create?: XOR<MerchantCreateWithoutBillSchedulesInput, MerchantUncheckedCreateWithoutBillSchedulesInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutBillSchedulesInput
    upsert?: MerchantUpsertWithoutBillSchedulesInput
    disconnect?: MerchantWhereInput | boolean
    delete?: MerchantWhereInput | boolean
    connect?: MerchantWhereUniqueInput
    update?: XOR<XOR<MerchantUpdateToOneWithWhereWithoutBillSchedulesInput, MerchantUpdateWithoutBillSchedulesInput>, MerchantUncheckedUpdateWithoutBillSchedulesInput>
  }

  export type RechargeOrderCreateNestedManyWithoutPlanInput = {
    create?: XOR<RechargeOrderCreateWithoutPlanInput, RechargeOrderUncheckedCreateWithoutPlanInput> | RechargeOrderCreateWithoutPlanInput[] | RechargeOrderUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: RechargeOrderCreateOrConnectWithoutPlanInput | RechargeOrderCreateOrConnectWithoutPlanInput[]
    createMany?: RechargeOrderCreateManyPlanInputEnvelope
    connect?: RechargeOrderWhereUniqueInput | RechargeOrderWhereUniqueInput[]
  }

  export type RechargeOrderUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<RechargeOrderCreateWithoutPlanInput, RechargeOrderUncheckedCreateWithoutPlanInput> | RechargeOrderCreateWithoutPlanInput[] | RechargeOrderUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: RechargeOrderCreateOrConnectWithoutPlanInput | RechargeOrderCreateOrConnectWithoutPlanInput[]
    createMany?: RechargeOrderCreateManyPlanInputEnvelope
    connect?: RechargeOrderWhereUniqueInput | RechargeOrderWhereUniqueInput[]
  }

  export type RechargeOrderUpdateManyWithoutPlanNestedInput = {
    create?: XOR<RechargeOrderCreateWithoutPlanInput, RechargeOrderUncheckedCreateWithoutPlanInput> | RechargeOrderCreateWithoutPlanInput[] | RechargeOrderUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: RechargeOrderCreateOrConnectWithoutPlanInput | RechargeOrderCreateOrConnectWithoutPlanInput[]
    upsert?: RechargeOrderUpsertWithWhereUniqueWithoutPlanInput | RechargeOrderUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: RechargeOrderCreateManyPlanInputEnvelope
    set?: RechargeOrderWhereUniqueInput | RechargeOrderWhereUniqueInput[]
    disconnect?: RechargeOrderWhereUniqueInput | RechargeOrderWhereUniqueInput[]
    delete?: RechargeOrderWhereUniqueInput | RechargeOrderWhereUniqueInput[]
    connect?: RechargeOrderWhereUniqueInput | RechargeOrderWhereUniqueInput[]
    update?: RechargeOrderUpdateWithWhereUniqueWithoutPlanInput | RechargeOrderUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: RechargeOrderUpdateManyWithWhereWithoutPlanInput | RechargeOrderUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: RechargeOrderScalarWhereInput | RechargeOrderScalarWhereInput[]
  }

  export type RechargeOrderUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<RechargeOrderCreateWithoutPlanInput, RechargeOrderUncheckedCreateWithoutPlanInput> | RechargeOrderCreateWithoutPlanInput[] | RechargeOrderUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: RechargeOrderCreateOrConnectWithoutPlanInput | RechargeOrderCreateOrConnectWithoutPlanInput[]
    upsert?: RechargeOrderUpsertWithWhereUniqueWithoutPlanInput | RechargeOrderUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: RechargeOrderCreateManyPlanInputEnvelope
    set?: RechargeOrderWhereUniqueInput | RechargeOrderWhereUniqueInput[]
    disconnect?: RechargeOrderWhereUniqueInput | RechargeOrderWhereUniqueInput[]
    delete?: RechargeOrderWhereUniqueInput | RechargeOrderWhereUniqueInput[]
    connect?: RechargeOrderWhereUniqueInput | RechargeOrderWhereUniqueInput[]
    update?: RechargeOrderUpdateWithWhereUniqueWithoutPlanInput | RechargeOrderUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: RechargeOrderUpdateManyWithWhereWithoutPlanInput | RechargeOrderUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: RechargeOrderScalarWhereInput | RechargeOrderScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRechargeOrdersInput = {
    create?: XOR<UserCreateWithoutRechargeOrdersInput, UserUncheckedCreateWithoutRechargeOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutRechargeOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type RechargePlanCreateNestedOneWithoutRechargeOrdersInput = {
    create?: XOR<RechargePlanCreateWithoutRechargeOrdersInput, RechargePlanUncheckedCreateWithoutRechargeOrdersInput>
    connectOrCreate?: RechargePlanCreateOrConnectWithoutRechargeOrdersInput
    connect?: RechargePlanWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRechargeOrdersNestedInput = {
    create?: XOR<UserCreateWithoutRechargeOrdersInput, UserUncheckedCreateWithoutRechargeOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutRechargeOrdersInput
    upsert?: UserUpsertWithoutRechargeOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRechargeOrdersInput, UserUpdateWithoutRechargeOrdersInput>, UserUncheckedUpdateWithoutRechargeOrdersInput>
  }

  export type RechargePlanUpdateOneWithoutRechargeOrdersNestedInput = {
    create?: XOR<RechargePlanCreateWithoutRechargeOrdersInput, RechargePlanUncheckedCreateWithoutRechargeOrdersInput>
    connectOrCreate?: RechargePlanCreateOrConnectWithoutRechargeOrdersInput
    upsert?: RechargePlanUpsertWithoutRechargeOrdersInput
    disconnect?: RechargePlanWhereInput | boolean
    delete?: RechargePlanWhereInput | boolean
    connect?: RechargePlanWhereUniqueInput
    update?: XOR<XOR<RechargePlanUpdateToOneWithWhereWithoutRechargeOrdersInput, RechargePlanUpdateWithoutRechargeOrdersInput>, RechargePlanUncheckedUpdateWithoutRechargeOrdersInput>
  }

  export type UserCreateNestedOneWithoutRewardsInput = {
    create?: XOR<UserCreateWithoutRewardsInput, UserUncheckedCreateWithoutRewardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRewardsInput
    connect?: UserWhereUniqueInput
  }

  export type BillSplitGroupCreateNestedOneWithoutRewardsInput = {
    create?: XOR<BillSplitGroupCreateWithoutRewardsInput, BillSplitGroupUncheckedCreateWithoutRewardsInput>
    connectOrCreate?: BillSplitGroupCreateOrConnectWithoutRewardsInput
    connect?: BillSplitGroupWhereUniqueInput
  }

  export type EnumRewardTypeFieldUpdateOperationsInput = {
    set?: $Enums.RewardType
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type EnumRewardStatusFieldUpdateOperationsInput = {
    set?: $Enums.RewardStatus
  }

  export type UserUpdateOneRequiredWithoutRewardsNestedInput = {
    create?: XOR<UserCreateWithoutRewardsInput, UserUncheckedCreateWithoutRewardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRewardsInput
    upsert?: UserUpsertWithoutRewardsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRewardsInput, UserUpdateWithoutRewardsInput>, UserUncheckedUpdateWithoutRewardsInput>
  }

  export type BillSplitGroupUpdateOneWithoutRewardsNestedInput = {
    create?: XOR<BillSplitGroupCreateWithoutRewardsInput, BillSplitGroupUncheckedCreateWithoutRewardsInput>
    connectOrCreate?: BillSplitGroupCreateOrConnectWithoutRewardsInput
    upsert?: BillSplitGroupUpsertWithoutRewardsInput
    disconnect?: BillSplitGroupWhereInput | boolean
    delete?: BillSplitGroupWhereInput | boolean
    connect?: BillSplitGroupWhereUniqueInput
    update?: XOR<XOR<BillSplitGroupUpdateToOneWithWhereWithoutRewardsInput, BillSplitGroupUpdateWithoutRewardsInput>, BillSplitGroupUncheckedUpdateWithoutRewardsInput>
  }

  export type UserCreateNestedOneWithoutReferralsAsReferrerInput = {
    create?: XOR<UserCreateWithoutReferralsAsReferrerInput, UserUncheckedCreateWithoutReferralsAsReferrerInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsAsReferrerInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReferralsAsReferredInput = {
    create?: XOR<UserCreateWithoutReferralsAsReferredInput, UserUncheckedCreateWithoutReferralsAsReferredInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsAsReferredInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReferralsAsReferrerNestedInput = {
    create?: XOR<UserCreateWithoutReferralsAsReferrerInput, UserUncheckedCreateWithoutReferralsAsReferrerInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsAsReferrerInput
    upsert?: UserUpsertWithoutReferralsAsReferrerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferralsAsReferrerInput, UserUpdateWithoutReferralsAsReferrerInput>, UserUncheckedUpdateWithoutReferralsAsReferrerInput>
  }

  export type UserUpdateOneWithoutReferralsAsReferredNestedInput = {
    create?: XOR<UserCreateWithoutReferralsAsReferredInput, UserUncheckedCreateWithoutReferralsAsReferredInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsAsReferredInput
    upsert?: UserUpsertWithoutReferralsAsReferredInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferralsAsReferredInput, UserUpdateWithoutReferralsAsReferredInput>, UserUncheckedUpdateWithoutReferralsAsReferredInput>
  }

  export type UserCreateNestedOneWithoutWrongSendRequestsInput = {
    create?: XOR<UserCreateWithoutWrongSendRequestsInput, UserUncheckedCreateWithoutWrongSendRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWrongSendRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type p2pTransferCreateNestedOneWithoutWrongSendRequestInput = {
    create?: XOR<p2pTransferCreateWithoutWrongSendRequestInput, p2pTransferUncheckedCreateWithoutWrongSendRequestInput>
    connectOrCreate?: p2pTransferCreateOrConnectWithoutWrongSendRequestInput
    connect?: p2pTransferWhereUniqueInput
  }

  export type EnumWrongSendStatusFieldUpdateOperationsInput = {
    set?: $Enums.WrongSendStatus
  }

  export type UserUpdateOneRequiredWithoutWrongSendRequestsNestedInput = {
    create?: XOR<UserCreateWithoutWrongSendRequestsInput, UserUncheckedCreateWithoutWrongSendRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWrongSendRequestsInput
    upsert?: UserUpsertWithoutWrongSendRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWrongSendRequestsInput, UserUpdateWithoutWrongSendRequestsInput>, UserUncheckedUpdateWithoutWrongSendRequestsInput>
  }

  export type p2pTransferUpdateOneRequiredWithoutWrongSendRequestNestedInput = {
    create?: XOR<p2pTransferCreateWithoutWrongSendRequestInput, p2pTransferUncheckedCreateWithoutWrongSendRequestInput>
    connectOrCreate?: p2pTransferCreateOrConnectWithoutWrongSendRequestInput
    upsert?: p2pTransferUpsertWithoutWrongSendRequestInput
    connect?: p2pTransferWhereUniqueInput
    update?: XOR<XOR<p2pTransferUpdateToOneWithWhereWithoutWrongSendRequestInput, p2pTransferUpdateWithoutWrongSendRequestInput>, p2pTransferUncheckedUpdateWithoutWrongSendRequestInput>
  }

  export type UserCreateNestedOneWithoutCreatedGroupsInput = {
    create?: XOR<UserCreateWithoutCreatedGroupsInput, UserUncheckedCreateWithoutCreatedGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedGroupsInput
    connect?: UserWhereUniqueInput
  }

  export type BillSplitMemberCreateNestedManyWithoutGroupInput = {
    create?: XOR<BillSplitMemberCreateWithoutGroupInput, BillSplitMemberUncheckedCreateWithoutGroupInput> | BillSplitMemberCreateWithoutGroupInput[] | BillSplitMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: BillSplitMemberCreateOrConnectWithoutGroupInput | BillSplitMemberCreateOrConnectWithoutGroupInput[]
    createMany?: BillSplitMemberCreateManyGroupInputEnvelope
    connect?: BillSplitMemberWhereUniqueInput | BillSplitMemberWhereUniqueInput[]
  }

  export type BillSplitPaymentCreateNestedManyWithoutGroupInput = {
    create?: XOR<BillSplitPaymentCreateWithoutGroupInput, BillSplitPaymentUncheckedCreateWithoutGroupInput> | BillSplitPaymentCreateWithoutGroupInput[] | BillSplitPaymentUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: BillSplitPaymentCreateOrConnectWithoutGroupInput | BillSplitPaymentCreateOrConnectWithoutGroupInput[]
    createMany?: BillSplitPaymentCreateManyGroupInputEnvelope
    connect?: BillSplitPaymentWhereUniqueInput | BillSplitPaymentWhereUniqueInput[]
  }

  export type RewardCreateNestedManyWithoutBillSplitGroupInput = {
    create?: XOR<RewardCreateWithoutBillSplitGroupInput, RewardUncheckedCreateWithoutBillSplitGroupInput> | RewardCreateWithoutBillSplitGroupInput[] | RewardUncheckedCreateWithoutBillSplitGroupInput[]
    connectOrCreate?: RewardCreateOrConnectWithoutBillSplitGroupInput | RewardCreateOrConnectWithoutBillSplitGroupInput[]
    createMany?: RewardCreateManyBillSplitGroupInputEnvelope
    connect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
  }

  export type BillSplitMemberUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<BillSplitMemberCreateWithoutGroupInput, BillSplitMemberUncheckedCreateWithoutGroupInput> | BillSplitMemberCreateWithoutGroupInput[] | BillSplitMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: BillSplitMemberCreateOrConnectWithoutGroupInput | BillSplitMemberCreateOrConnectWithoutGroupInput[]
    createMany?: BillSplitMemberCreateManyGroupInputEnvelope
    connect?: BillSplitMemberWhereUniqueInput | BillSplitMemberWhereUniqueInput[]
  }

  export type BillSplitPaymentUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<BillSplitPaymentCreateWithoutGroupInput, BillSplitPaymentUncheckedCreateWithoutGroupInput> | BillSplitPaymentCreateWithoutGroupInput[] | BillSplitPaymentUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: BillSplitPaymentCreateOrConnectWithoutGroupInput | BillSplitPaymentCreateOrConnectWithoutGroupInput[]
    createMany?: BillSplitPaymentCreateManyGroupInputEnvelope
    connect?: BillSplitPaymentWhereUniqueInput | BillSplitPaymentWhereUniqueInput[]
  }

  export type RewardUncheckedCreateNestedManyWithoutBillSplitGroupInput = {
    create?: XOR<RewardCreateWithoutBillSplitGroupInput, RewardUncheckedCreateWithoutBillSplitGroupInput> | RewardCreateWithoutBillSplitGroupInput[] | RewardUncheckedCreateWithoutBillSplitGroupInput[]
    connectOrCreate?: RewardCreateOrConnectWithoutBillSplitGroupInput | RewardCreateOrConnectWithoutBillSplitGroupInput[]
    createMany?: RewardCreateManyBillSplitGroupInputEnvelope
    connect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutCreatedGroupsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedGroupsInput, UserUncheckedCreateWithoutCreatedGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedGroupsInput
    upsert?: UserUpsertWithoutCreatedGroupsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedGroupsInput, UserUpdateWithoutCreatedGroupsInput>, UserUncheckedUpdateWithoutCreatedGroupsInput>
  }

  export type BillSplitMemberUpdateManyWithoutGroupNestedInput = {
    create?: XOR<BillSplitMemberCreateWithoutGroupInput, BillSplitMemberUncheckedCreateWithoutGroupInput> | BillSplitMemberCreateWithoutGroupInput[] | BillSplitMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: BillSplitMemberCreateOrConnectWithoutGroupInput | BillSplitMemberCreateOrConnectWithoutGroupInput[]
    upsert?: BillSplitMemberUpsertWithWhereUniqueWithoutGroupInput | BillSplitMemberUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: BillSplitMemberCreateManyGroupInputEnvelope
    set?: BillSplitMemberWhereUniqueInput | BillSplitMemberWhereUniqueInput[]
    disconnect?: BillSplitMemberWhereUniqueInput | BillSplitMemberWhereUniqueInput[]
    delete?: BillSplitMemberWhereUniqueInput | BillSplitMemberWhereUniqueInput[]
    connect?: BillSplitMemberWhereUniqueInput | BillSplitMemberWhereUniqueInput[]
    update?: BillSplitMemberUpdateWithWhereUniqueWithoutGroupInput | BillSplitMemberUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: BillSplitMemberUpdateManyWithWhereWithoutGroupInput | BillSplitMemberUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: BillSplitMemberScalarWhereInput | BillSplitMemberScalarWhereInput[]
  }

  export type BillSplitPaymentUpdateManyWithoutGroupNestedInput = {
    create?: XOR<BillSplitPaymentCreateWithoutGroupInput, BillSplitPaymentUncheckedCreateWithoutGroupInput> | BillSplitPaymentCreateWithoutGroupInput[] | BillSplitPaymentUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: BillSplitPaymentCreateOrConnectWithoutGroupInput | BillSplitPaymentCreateOrConnectWithoutGroupInput[]
    upsert?: BillSplitPaymentUpsertWithWhereUniqueWithoutGroupInput | BillSplitPaymentUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: BillSplitPaymentCreateManyGroupInputEnvelope
    set?: BillSplitPaymentWhereUniqueInput | BillSplitPaymentWhereUniqueInput[]
    disconnect?: BillSplitPaymentWhereUniqueInput | BillSplitPaymentWhereUniqueInput[]
    delete?: BillSplitPaymentWhereUniqueInput | BillSplitPaymentWhereUniqueInput[]
    connect?: BillSplitPaymentWhereUniqueInput | BillSplitPaymentWhereUniqueInput[]
    update?: BillSplitPaymentUpdateWithWhereUniqueWithoutGroupInput | BillSplitPaymentUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: BillSplitPaymentUpdateManyWithWhereWithoutGroupInput | BillSplitPaymentUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: BillSplitPaymentScalarWhereInput | BillSplitPaymentScalarWhereInput[]
  }

  export type RewardUpdateManyWithoutBillSplitGroupNestedInput = {
    create?: XOR<RewardCreateWithoutBillSplitGroupInput, RewardUncheckedCreateWithoutBillSplitGroupInput> | RewardCreateWithoutBillSplitGroupInput[] | RewardUncheckedCreateWithoutBillSplitGroupInput[]
    connectOrCreate?: RewardCreateOrConnectWithoutBillSplitGroupInput | RewardCreateOrConnectWithoutBillSplitGroupInput[]
    upsert?: RewardUpsertWithWhereUniqueWithoutBillSplitGroupInput | RewardUpsertWithWhereUniqueWithoutBillSplitGroupInput[]
    createMany?: RewardCreateManyBillSplitGroupInputEnvelope
    set?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    disconnect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    delete?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    connect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    update?: RewardUpdateWithWhereUniqueWithoutBillSplitGroupInput | RewardUpdateWithWhereUniqueWithoutBillSplitGroupInput[]
    updateMany?: RewardUpdateManyWithWhereWithoutBillSplitGroupInput | RewardUpdateManyWithWhereWithoutBillSplitGroupInput[]
    deleteMany?: RewardScalarWhereInput | RewardScalarWhereInput[]
  }

  export type BillSplitMemberUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<BillSplitMemberCreateWithoutGroupInput, BillSplitMemberUncheckedCreateWithoutGroupInput> | BillSplitMemberCreateWithoutGroupInput[] | BillSplitMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: BillSplitMemberCreateOrConnectWithoutGroupInput | BillSplitMemberCreateOrConnectWithoutGroupInput[]
    upsert?: BillSplitMemberUpsertWithWhereUniqueWithoutGroupInput | BillSplitMemberUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: BillSplitMemberCreateManyGroupInputEnvelope
    set?: BillSplitMemberWhereUniqueInput | BillSplitMemberWhereUniqueInput[]
    disconnect?: BillSplitMemberWhereUniqueInput | BillSplitMemberWhereUniqueInput[]
    delete?: BillSplitMemberWhereUniqueInput | BillSplitMemberWhereUniqueInput[]
    connect?: BillSplitMemberWhereUniqueInput | BillSplitMemberWhereUniqueInput[]
    update?: BillSplitMemberUpdateWithWhereUniqueWithoutGroupInput | BillSplitMemberUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: BillSplitMemberUpdateManyWithWhereWithoutGroupInput | BillSplitMemberUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: BillSplitMemberScalarWhereInput | BillSplitMemberScalarWhereInput[]
  }

  export type BillSplitPaymentUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<BillSplitPaymentCreateWithoutGroupInput, BillSplitPaymentUncheckedCreateWithoutGroupInput> | BillSplitPaymentCreateWithoutGroupInput[] | BillSplitPaymentUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: BillSplitPaymentCreateOrConnectWithoutGroupInput | BillSplitPaymentCreateOrConnectWithoutGroupInput[]
    upsert?: BillSplitPaymentUpsertWithWhereUniqueWithoutGroupInput | BillSplitPaymentUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: BillSplitPaymentCreateManyGroupInputEnvelope
    set?: BillSplitPaymentWhereUniqueInput | BillSplitPaymentWhereUniqueInput[]
    disconnect?: BillSplitPaymentWhereUniqueInput | BillSplitPaymentWhereUniqueInput[]
    delete?: BillSplitPaymentWhereUniqueInput | BillSplitPaymentWhereUniqueInput[]
    connect?: BillSplitPaymentWhereUniqueInput | BillSplitPaymentWhereUniqueInput[]
    update?: BillSplitPaymentUpdateWithWhereUniqueWithoutGroupInput | BillSplitPaymentUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: BillSplitPaymentUpdateManyWithWhereWithoutGroupInput | BillSplitPaymentUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: BillSplitPaymentScalarWhereInput | BillSplitPaymentScalarWhereInput[]
  }

  export type RewardUncheckedUpdateManyWithoutBillSplitGroupNestedInput = {
    create?: XOR<RewardCreateWithoutBillSplitGroupInput, RewardUncheckedCreateWithoutBillSplitGroupInput> | RewardCreateWithoutBillSplitGroupInput[] | RewardUncheckedCreateWithoutBillSplitGroupInput[]
    connectOrCreate?: RewardCreateOrConnectWithoutBillSplitGroupInput | RewardCreateOrConnectWithoutBillSplitGroupInput[]
    upsert?: RewardUpsertWithWhereUniqueWithoutBillSplitGroupInput | RewardUpsertWithWhereUniqueWithoutBillSplitGroupInput[]
    createMany?: RewardCreateManyBillSplitGroupInputEnvelope
    set?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    disconnect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    delete?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    connect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    update?: RewardUpdateWithWhereUniqueWithoutBillSplitGroupInput | RewardUpdateWithWhereUniqueWithoutBillSplitGroupInput[]
    updateMany?: RewardUpdateManyWithWhereWithoutBillSplitGroupInput | RewardUpdateManyWithWhereWithoutBillSplitGroupInput[]
    deleteMany?: RewardScalarWhereInput | RewardScalarWhereInput[]
  }

  export type BillSplitGroupCreateNestedOneWithoutMembersInput = {
    create?: XOR<BillSplitGroupCreateWithoutMembersInput, BillSplitGroupUncheckedCreateWithoutMembersInput>
    connectOrCreate?: BillSplitGroupCreateOrConnectWithoutMembersInput
    connect?: BillSplitGroupWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBillSplitMembersInput = {
    create?: XOR<UserCreateWithoutBillSplitMembersInput, UserUncheckedCreateWithoutBillSplitMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutBillSplitMembersInput
    connect?: UserWhereUniqueInput
  }

  export type P2PRequestCreateNestedOneWithoutBillSplitMemberInput = {
    create?: XOR<P2PRequestCreateWithoutBillSplitMemberInput, P2PRequestUncheckedCreateWithoutBillSplitMemberInput>
    connectOrCreate?: P2PRequestCreateOrConnectWithoutBillSplitMemberInput
    connect?: P2PRequestWhereUniqueInput
  }

  export type BillSplitPaymentCreateNestedManyWithoutMemberInput = {
    create?: XOR<BillSplitPaymentCreateWithoutMemberInput, BillSplitPaymentUncheckedCreateWithoutMemberInput> | BillSplitPaymentCreateWithoutMemberInput[] | BillSplitPaymentUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: BillSplitPaymentCreateOrConnectWithoutMemberInput | BillSplitPaymentCreateOrConnectWithoutMemberInput[]
    createMany?: BillSplitPaymentCreateManyMemberInputEnvelope
    connect?: BillSplitPaymentWhereUniqueInput | BillSplitPaymentWhereUniqueInput[]
  }

  export type P2PRequestUncheckedCreateNestedOneWithoutBillSplitMemberInput = {
    create?: XOR<P2PRequestCreateWithoutBillSplitMemberInput, P2PRequestUncheckedCreateWithoutBillSplitMemberInput>
    connectOrCreate?: P2PRequestCreateOrConnectWithoutBillSplitMemberInput
    connect?: P2PRequestWhereUniqueInput
  }

  export type BillSplitPaymentUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<BillSplitPaymentCreateWithoutMemberInput, BillSplitPaymentUncheckedCreateWithoutMemberInput> | BillSplitPaymentCreateWithoutMemberInput[] | BillSplitPaymentUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: BillSplitPaymentCreateOrConnectWithoutMemberInput | BillSplitPaymentCreateOrConnectWithoutMemberInput[]
    createMany?: BillSplitPaymentCreateManyMemberInputEnvelope
    connect?: BillSplitPaymentWhereUniqueInput | BillSplitPaymentWhereUniqueInput[]
  }

  export type BillSplitGroupUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<BillSplitGroupCreateWithoutMembersInput, BillSplitGroupUncheckedCreateWithoutMembersInput>
    connectOrCreate?: BillSplitGroupCreateOrConnectWithoutMembersInput
    upsert?: BillSplitGroupUpsertWithoutMembersInput
    connect?: BillSplitGroupWhereUniqueInput
    update?: XOR<XOR<BillSplitGroupUpdateToOneWithWhereWithoutMembersInput, BillSplitGroupUpdateWithoutMembersInput>, BillSplitGroupUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneWithoutBillSplitMembersNestedInput = {
    create?: XOR<UserCreateWithoutBillSplitMembersInput, UserUncheckedCreateWithoutBillSplitMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutBillSplitMembersInput
    upsert?: UserUpsertWithoutBillSplitMembersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBillSplitMembersInput, UserUpdateWithoutBillSplitMembersInput>, UserUncheckedUpdateWithoutBillSplitMembersInput>
  }

  export type P2PRequestUpdateOneWithoutBillSplitMemberNestedInput = {
    create?: XOR<P2PRequestCreateWithoutBillSplitMemberInput, P2PRequestUncheckedCreateWithoutBillSplitMemberInput>
    connectOrCreate?: P2PRequestCreateOrConnectWithoutBillSplitMemberInput
    upsert?: P2PRequestUpsertWithoutBillSplitMemberInput
    disconnect?: P2PRequestWhereInput | boolean
    delete?: P2PRequestWhereInput | boolean
    connect?: P2PRequestWhereUniqueInput
    update?: XOR<XOR<P2PRequestUpdateToOneWithWhereWithoutBillSplitMemberInput, P2PRequestUpdateWithoutBillSplitMemberInput>, P2PRequestUncheckedUpdateWithoutBillSplitMemberInput>
  }

  export type BillSplitPaymentUpdateManyWithoutMemberNestedInput = {
    create?: XOR<BillSplitPaymentCreateWithoutMemberInput, BillSplitPaymentUncheckedCreateWithoutMemberInput> | BillSplitPaymentCreateWithoutMemberInput[] | BillSplitPaymentUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: BillSplitPaymentCreateOrConnectWithoutMemberInput | BillSplitPaymentCreateOrConnectWithoutMemberInput[]
    upsert?: BillSplitPaymentUpsertWithWhereUniqueWithoutMemberInput | BillSplitPaymentUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: BillSplitPaymentCreateManyMemberInputEnvelope
    set?: BillSplitPaymentWhereUniqueInput | BillSplitPaymentWhereUniqueInput[]
    disconnect?: BillSplitPaymentWhereUniqueInput | BillSplitPaymentWhereUniqueInput[]
    delete?: BillSplitPaymentWhereUniqueInput | BillSplitPaymentWhereUniqueInput[]
    connect?: BillSplitPaymentWhereUniqueInput | BillSplitPaymentWhereUniqueInput[]
    update?: BillSplitPaymentUpdateWithWhereUniqueWithoutMemberInput | BillSplitPaymentUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: BillSplitPaymentUpdateManyWithWhereWithoutMemberInput | BillSplitPaymentUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: BillSplitPaymentScalarWhereInput | BillSplitPaymentScalarWhereInput[]
  }

  export type P2PRequestUncheckedUpdateOneWithoutBillSplitMemberNestedInput = {
    create?: XOR<P2PRequestCreateWithoutBillSplitMemberInput, P2PRequestUncheckedCreateWithoutBillSplitMemberInput>
    connectOrCreate?: P2PRequestCreateOrConnectWithoutBillSplitMemberInput
    upsert?: P2PRequestUpsertWithoutBillSplitMemberInput
    disconnect?: P2PRequestWhereInput | boolean
    delete?: P2PRequestWhereInput | boolean
    connect?: P2PRequestWhereUniqueInput
    update?: XOR<XOR<P2PRequestUpdateToOneWithWhereWithoutBillSplitMemberInput, P2PRequestUpdateWithoutBillSplitMemberInput>, P2PRequestUncheckedUpdateWithoutBillSplitMemberInput>
  }

  export type BillSplitPaymentUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<BillSplitPaymentCreateWithoutMemberInput, BillSplitPaymentUncheckedCreateWithoutMemberInput> | BillSplitPaymentCreateWithoutMemberInput[] | BillSplitPaymentUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: BillSplitPaymentCreateOrConnectWithoutMemberInput | BillSplitPaymentCreateOrConnectWithoutMemberInput[]
    upsert?: BillSplitPaymentUpsertWithWhereUniqueWithoutMemberInput | BillSplitPaymentUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: BillSplitPaymentCreateManyMemberInputEnvelope
    set?: BillSplitPaymentWhereUniqueInput | BillSplitPaymentWhereUniqueInput[]
    disconnect?: BillSplitPaymentWhereUniqueInput | BillSplitPaymentWhereUniqueInput[]
    delete?: BillSplitPaymentWhereUniqueInput | BillSplitPaymentWhereUniqueInput[]
    connect?: BillSplitPaymentWhereUniqueInput | BillSplitPaymentWhereUniqueInput[]
    update?: BillSplitPaymentUpdateWithWhereUniqueWithoutMemberInput | BillSplitPaymentUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: BillSplitPaymentUpdateManyWithWhereWithoutMemberInput | BillSplitPaymentUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: BillSplitPaymentScalarWhereInput | BillSplitPaymentScalarWhereInput[]
  }

  export type BillSplitGroupCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<BillSplitGroupCreateWithoutPaymentsInput, BillSplitGroupUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: BillSplitGroupCreateOrConnectWithoutPaymentsInput
    connect?: BillSplitGroupWhereUniqueInput
  }

  export type BillSplitMemberCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<BillSplitMemberCreateWithoutPaymentsInput, BillSplitMemberUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: BillSplitMemberCreateOrConnectWithoutPaymentsInput
    connect?: BillSplitMemberWhereUniqueInput
  }

  export type p2pTransferCreateNestedOneWithoutBillSplitPaymentInput = {
    create?: XOR<p2pTransferCreateWithoutBillSplitPaymentInput, p2pTransferUncheckedCreateWithoutBillSplitPaymentInput>
    connectOrCreate?: p2pTransferCreateOrConnectWithoutBillSplitPaymentInput
    connect?: p2pTransferWhereUniqueInput
  }

  export type BillSplitGroupUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<BillSplitGroupCreateWithoutPaymentsInput, BillSplitGroupUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: BillSplitGroupCreateOrConnectWithoutPaymentsInput
    upsert?: BillSplitGroupUpsertWithoutPaymentsInput
    connect?: BillSplitGroupWhereUniqueInput
    update?: XOR<XOR<BillSplitGroupUpdateToOneWithWhereWithoutPaymentsInput, BillSplitGroupUpdateWithoutPaymentsInput>, BillSplitGroupUncheckedUpdateWithoutPaymentsInput>
  }

  export type BillSplitMemberUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<BillSplitMemberCreateWithoutPaymentsInput, BillSplitMemberUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: BillSplitMemberCreateOrConnectWithoutPaymentsInput
    upsert?: BillSplitMemberUpsertWithoutPaymentsInput
    connect?: BillSplitMemberWhereUniqueInput
    update?: XOR<XOR<BillSplitMemberUpdateToOneWithWhereWithoutPaymentsInput, BillSplitMemberUpdateWithoutPaymentsInput>, BillSplitMemberUncheckedUpdateWithoutPaymentsInput>
  }

  export type p2pTransferUpdateOneWithoutBillSplitPaymentNestedInput = {
    create?: XOR<p2pTransferCreateWithoutBillSplitPaymentInput, p2pTransferUncheckedCreateWithoutBillSplitPaymentInput>
    connectOrCreate?: p2pTransferCreateOrConnectWithoutBillSplitPaymentInput
    upsert?: p2pTransferUpsertWithoutBillSplitPaymentInput
    disconnect?: p2pTransferWhereInput | boolean
    delete?: p2pTransferWhereInput | boolean
    connect?: p2pTransferWhereUniqueInput
    update?: XOR<XOR<p2pTransferUpdateToOneWithWhereWithoutBillSplitPaymentInput, p2pTransferUpdateWithoutBillSplitPaymentInput>, p2pTransferUncheckedUpdateWithoutBillSplitPaymentInput>
  }

  export type UserCreateNestedOneWithoutBalanceInput = {
    create?: XOR<UserCreateWithoutBalanceInput, UserUncheckedCreateWithoutBalanceInput>
    connectOrCreate?: UserCreateOrConnectWithoutBalanceInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBalanceNestedInput = {
    create?: XOR<UserCreateWithoutBalanceInput, UserUncheckedCreateWithoutBalanceInput>
    connectOrCreate?: UserCreateOrConnectWithoutBalanceInput
    upsert?: UserUpsertWithoutBalanceInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBalanceInput, UserUpdateWithoutBalanceInput>, UserUncheckedUpdateWithoutBalanceInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumAuthTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthType | EnumAuthTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuthType[] | ListEnumAuthTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthType[] | ListEnumAuthTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthTypeFilter<$PrismaModel> | $Enums.AuthType
  }

  export type NestedEnumAuthTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthType | EnumAuthTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuthType[] | ListEnumAuthTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthType[] | ListEnumAuthTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthTypeWithAggregatesFilter<$PrismaModel> | $Enums.AuthType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthTypeFilter<$PrismaModel>
    _max?: NestedEnumAuthTypeFilter<$PrismaModel>
  }

  export type NestedEnumOnRampStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OnRampStatus | EnumOnRampStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OnRampStatus[] | ListEnumOnRampStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OnRampStatus[] | ListEnumOnRampStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOnRampStatusFilter<$PrismaModel> | $Enums.OnRampStatus
  }

  export type NestedEnumOnRampStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OnRampStatus | EnumOnRampStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OnRampStatus[] | ListEnumOnRampStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OnRampStatus[] | ListEnumOnRampStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOnRampStatusWithAggregatesFilter<$PrismaModel> | $Enums.OnRampStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOnRampStatusFilter<$PrismaModel>
    _max?: NestedEnumOnRampStatusFilter<$PrismaModel>
  }

  export type NestedEnumP2PRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.P2PRequestStatus | EnumP2PRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.P2PRequestStatus[] | ListEnumP2PRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.P2PRequestStatus[] | ListEnumP2PRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumP2PRequestStatusFilter<$PrismaModel> | $Enums.P2PRequestStatus
  }

  export type NestedEnumP2PRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.P2PRequestStatus | EnumP2PRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.P2PRequestStatus[] | ListEnumP2PRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.P2PRequestStatus[] | ListEnumP2PRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumP2PRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.P2PRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumP2PRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumP2PRequestStatusFilter<$PrismaModel>
  }

  export type NestedEnumRewardTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RewardType | EnumRewardTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRewardTypeFilter<$PrismaModel> | $Enums.RewardType
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedEnumRewardStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RewardStatus | EnumRewardStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RewardStatus[] | ListEnumRewardStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RewardStatus[] | ListEnumRewardStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRewardStatusFilter<$PrismaModel> | $Enums.RewardStatus
  }

  export type NestedEnumRewardTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RewardType | EnumRewardTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRewardTypeWithAggregatesFilter<$PrismaModel> | $Enums.RewardType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRewardTypeFilter<$PrismaModel>
    _max?: NestedEnumRewardTypeFilter<$PrismaModel>
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedEnumRewardStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RewardStatus | EnumRewardStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RewardStatus[] | ListEnumRewardStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RewardStatus[] | ListEnumRewardStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRewardStatusWithAggregatesFilter<$PrismaModel> | $Enums.RewardStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRewardStatusFilter<$PrismaModel>
    _max?: NestedEnumRewardStatusFilter<$PrismaModel>
  }

  export type NestedEnumWrongSendStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WrongSendStatus | EnumWrongSendStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WrongSendStatus[] | ListEnumWrongSendStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WrongSendStatus[] | ListEnumWrongSendStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWrongSendStatusFilter<$PrismaModel> | $Enums.WrongSendStatus
  }

  export type NestedEnumWrongSendStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WrongSendStatus | EnumWrongSendStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WrongSendStatus[] | ListEnumWrongSendStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WrongSendStatus[] | ListEnumWrongSendStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWrongSendStatusWithAggregatesFilter<$PrismaModel> | $Enums.WrongSendStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWrongSendStatusFilter<$PrismaModel>
    _max?: NestedEnumWrongSendStatusFilter<$PrismaModel>
  }

  export type OnRampTransactionCreateWithoutUserInput = {
    status: $Enums.OnRampStatus
    token: string
    provider: string
    amount: number
    startTime?: Date | string
    transactionId?: string | null
  }

  export type OnRampTransactionUncheckedCreateWithoutUserInput = {
    id?: number
    status: $Enums.OnRampStatus
    token: string
    provider: string
    amount: number
    startTime?: Date | string
    transactionId?: string | null
  }

  export type OnRampTransactionCreateOrConnectWithoutUserInput = {
    where: OnRampTransactionWhereUniqueInput
    create: XOR<OnRampTransactionCreateWithoutUserInput, OnRampTransactionUncheckedCreateWithoutUserInput>
  }

  export type OnRampTransactionCreateManyUserInputEnvelope = {
    data: OnRampTransactionCreateManyUserInput | OnRampTransactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BalanceCreateWithoutUserInput = {
    amount: number
    locked: number
  }

  export type BalanceUncheckedCreateWithoutUserInput = {
    id?: number
    amount: number
    locked: number
  }

  export type BalanceCreateOrConnectWithoutUserInput = {
    where: BalanceWhereUniqueInput
    create: XOR<BalanceCreateWithoutUserInput, BalanceUncheckedCreateWithoutUserInput>
  }

  export type BalanceCreateManyUserInputEnvelope = {
    data: BalanceCreateManyUserInput | BalanceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type p2pTransferCreateWithoutFromUserInput = {
    amount: number
    timestamp: Date | string
    receiverNumber?: string | null
    status?: string
    razorpayPaymentId?: string | null
    paymentMethod?: string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    merchantId?: number | null
    latitude?: number | null
    longitude?: number | null
    isFraud?: boolean | null
    fraudScore?: number | null
    fraudReason?: string | null
    riskLevel?: string | null
    toUser?: UserCreateNestedOneWithoutReceivedTransfersInput
    wrongSendRequest?: WrongSendRequestCreateNestedOneWithoutTransactionInput
    billSplitPayment?: BillSplitPaymentCreateNestedOneWithoutP2pTransferInput
  }

  export type p2pTransferUncheckedCreateWithoutFromUserInput = {
    id?: number
    amount: number
    timestamp: Date | string
    toUserId?: number | null
    receiverNumber?: string | null
    status?: string
    razorpayPaymentId?: string | null
    paymentMethod?: string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    merchantId?: number | null
    latitude?: number | null
    longitude?: number | null
    isFraud?: boolean | null
    fraudScore?: number | null
    fraudReason?: string | null
    riskLevel?: string | null
    wrongSendRequest?: WrongSendRequestUncheckedCreateNestedOneWithoutTransactionInput
    billSplitPayment?: BillSplitPaymentUncheckedCreateNestedOneWithoutP2pTransferInput
  }

  export type p2pTransferCreateOrConnectWithoutFromUserInput = {
    where: p2pTransferWhereUniqueInput
    create: XOR<p2pTransferCreateWithoutFromUserInput, p2pTransferUncheckedCreateWithoutFromUserInput>
  }

  export type p2pTransferCreateManyFromUserInputEnvelope = {
    data: p2pTransferCreateManyFromUserInput | p2pTransferCreateManyFromUserInput[]
    skipDuplicates?: boolean
  }

  export type p2pTransferCreateWithoutToUserInput = {
    amount: number
    timestamp: Date | string
    receiverNumber?: string | null
    status?: string
    razorpayPaymentId?: string | null
    paymentMethod?: string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    merchantId?: number | null
    latitude?: number | null
    longitude?: number | null
    isFraud?: boolean | null
    fraudScore?: number | null
    fraudReason?: string | null
    riskLevel?: string | null
    fromUser: UserCreateNestedOneWithoutSentTransfersInput
    wrongSendRequest?: WrongSendRequestCreateNestedOneWithoutTransactionInput
    billSplitPayment?: BillSplitPaymentCreateNestedOneWithoutP2pTransferInput
  }

  export type p2pTransferUncheckedCreateWithoutToUserInput = {
    id?: number
    amount: number
    timestamp: Date | string
    fromUserId: number
    receiverNumber?: string | null
    status?: string
    razorpayPaymentId?: string | null
    paymentMethod?: string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    merchantId?: number | null
    latitude?: number | null
    longitude?: number | null
    isFraud?: boolean | null
    fraudScore?: number | null
    fraudReason?: string | null
    riskLevel?: string | null
    wrongSendRequest?: WrongSendRequestUncheckedCreateNestedOneWithoutTransactionInput
    billSplitPayment?: BillSplitPaymentUncheckedCreateNestedOneWithoutP2pTransferInput
  }

  export type p2pTransferCreateOrConnectWithoutToUserInput = {
    where: p2pTransferWhereUniqueInput
    create: XOR<p2pTransferCreateWithoutToUserInput, p2pTransferUncheckedCreateWithoutToUserInput>
  }

  export type p2pTransferCreateManyToUserInputEnvelope = {
    data: p2pTransferCreateManyToUserInput | p2pTransferCreateManyToUserInput[]
    skipDuplicates?: boolean
  }

  export type P2PRequestCreateWithoutSenderInput = {
    receiverNumber: string
    amount: number
    message?: string | null
    status?: $Enums.P2PRequestStatus
    createdAt?: Date | string
    settledAt?: Date | string | null
    receiver?: UserCreateNestedOneWithoutReceivedRequestsInput
    billSplitMember?: BillSplitMemberCreateNestedOneWithoutRequestInput
  }

  export type P2PRequestUncheckedCreateWithoutSenderInput = {
    id?: number
    receiverId?: number | null
    receiverNumber: string
    amount: number
    message?: string | null
    status?: $Enums.P2PRequestStatus
    createdAt?: Date | string
    settledAt?: Date | string | null
    billSplitMemberId?: number | null
  }

  export type P2PRequestCreateOrConnectWithoutSenderInput = {
    where: P2PRequestWhereUniqueInput
    create: XOR<P2PRequestCreateWithoutSenderInput, P2PRequestUncheckedCreateWithoutSenderInput>
  }

  export type P2PRequestCreateManySenderInputEnvelope = {
    data: P2PRequestCreateManySenderInput | P2PRequestCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type P2PRequestCreateWithoutReceiverInput = {
    receiverNumber: string
    amount: number
    message?: string | null
    status?: $Enums.P2PRequestStatus
    createdAt?: Date | string
    settledAt?: Date | string | null
    sender: UserCreateNestedOneWithoutSentRequestsInput
    billSplitMember?: BillSplitMemberCreateNestedOneWithoutRequestInput
  }

  export type P2PRequestUncheckedCreateWithoutReceiverInput = {
    id?: number
    senderId: number
    receiverNumber: string
    amount: number
    message?: string | null
    status?: $Enums.P2PRequestStatus
    createdAt?: Date | string
    settledAt?: Date | string | null
    billSplitMemberId?: number | null
  }

  export type P2PRequestCreateOrConnectWithoutReceiverInput = {
    where: P2PRequestWhereUniqueInput
    create: XOR<P2PRequestCreateWithoutReceiverInput, P2PRequestUncheckedCreateWithoutReceiverInput>
  }

  export type P2PRequestCreateManyReceiverInputEnvelope = {
    data: P2PRequestCreateManyReceiverInput | P2PRequestCreateManyReceiverInput[]
    skipDuplicates?: boolean
  }

  export type BillScheduleCreateWithoutUserInput = {
    billType: string
    provider: string
    accountNo: string
    amount: number
    dueDate: Date | string
    nextPayment?: Date | string | null
    createdAt?: Date | string
    paymentMethod?: string
    status?: string
    token?: string | null
    merchant?: MerchantCreateNestedOneWithoutBillSchedulesInput
  }

  export type BillScheduleUncheckedCreateWithoutUserInput = {
    id?: number
    merchantId?: number | null
    billType: string
    provider: string
    accountNo: string
    amount: number
    dueDate: Date | string
    nextPayment?: Date | string | null
    createdAt?: Date | string
    paymentMethod?: string
    status?: string
    token?: string | null
  }

  export type BillScheduleCreateOrConnectWithoutUserInput = {
    where: BillScheduleWhereUniqueInput
    create: XOR<BillScheduleCreateWithoutUserInput, BillScheduleUncheckedCreateWithoutUserInput>
  }

  export type BillScheduleCreateManyUserInputEnvelope = {
    data: BillScheduleCreateManyUserInput | BillScheduleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MerchantPaymentCreateWithoutUserInput = {
    qrId: string
    amount: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionId?: string | null
    merchant: MerchantCreateNestedOneWithoutPaymentsInput
  }

  export type MerchantPaymentUncheckedCreateWithoutUserInput = {
    id?: number
    merchantId: number
    qrId: string
    amount: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionId?: string | null
  }

  export type MerchantPaymentCreateOrConnectWithoutUserInput = {
    where: MerchantPaymentWhereUniqueInput
    create: XOR<MerchantPaymentCreateWithoutUserInput, MerchantPaymentUncheckedCreateWithoutUserInput>
  }

  export type MerchantPaymentCreateManyUserInputEnvelope = {
    data: MerchantPaymentCreateManyUserInput | MerchantPaymentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RechargeOrderCreateWithoutUserInput = {
    mobileNumber: string
    operator: string
    circle: string
    amount: number
    status?: string
    providerTxnId?: string | null
    orderId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: RechargePlanCreateNestedOneWithoutRechargeOrdersInput
  }

  export type RechargeOrderUncheckedCreateWithoutUserInput = {
    id?: number
    planId?: number | null
    mobileNumber: string
    operator: string
    circle: string
    amount: number
    status?: string
    providerTxnId?: string | null
    orderId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RechargeOrderCreateOrConnectWithoutUserInput = {
    where: RechargeOrderWhereUniqueInput
    create: XOR<RechargeOrderCreateWithoutUserInput, RechargeOrderUncheckedCreateWithoutUserInput>
  }

  export type RechargeOrderCreateManyUserInputEnvelope = {
    data: RechargeOrderCreateManyUserInput | RechargeOrderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RewardCreateWithoutUserInput = {
    type: $Enums.RewardType
    amount: bigint | number
    status?: $Enums.RewardStatus
    earnedAt?: Date | string
    expiresAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    billSplitGroup?: BillSplitGroupCreateNestedOneWithoutRewardsInput
  }

  export type RewardUncheckedCreateWithoutUserInput = {
    id?: number
    type: $Enums.RewardType
    amount: bigint | number
    status?: $Enums.RewardStatus
    earnedAt?: Date | string
    expiresAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    billSplitGroupId?: number | null
  }

  export type RewardCreateOrConnectWithoutUserInput = {
    where: RewardWhereUniqueInput
    create: XOR<RewardCreateWithoutUserInput, RewardUncheckedCreateWithoutUserInput>
  }

  export type RewardCreateManyUserInputEnvelope = {
    data: RewardCreateManyUserInput | RewardCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReferralCreateWithoutReferrerInput = {
    referralCode: string
    referred?: UserCreateNestedOneWithoutReferralsAsReferredInput
  }

  export type ReferralUncheckedCreateWithoutReferrerInput = {
    id?: number
    referredUserId?: number | null
    referralCode: string
  }

  export type ReferralCreateOrConnectWithoutReferrerInput = {
    where: ReferralWhereUniqueInput
    create: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput>
  }

  export type ReferralCreateManyReferrerInputEnvelope = {
    data: ReferralCreateManyReferrerInput | ReferralCreateManyReferrerInput[]
    skipDuplicates?: boolean
  }

  export type ReferralCreateWithoutReferredInput = {
    referralCode: string
    referrer: UserCreateNestedOneWithoutReferralsAsReferrerInput
  }

  export type ReferralUncheckedCreateWithoutReferredInput = {
    id?: number
    referrerId: number
    referralCode: string
  }

  export type ReferralCreateOrConnectWithoutReferredInput = {
    where: ReferralWhereUniqueInput
    create: XOR<ReferralCreateWithoutReferredInput, ReferralUncheckedCreateWithoutReferredInput>
  }

  export type ReferralCreateManyReferredInputEnvelope = {
    data: ReferralCreateManyReferredInput | ReferralCreateManyReferredInput[]
    skipDuplicates?: boolean
  }

  export type WrongSendRequestCreateWithoutSenderInput = {
    receiverNumber: string
    amount: bigint | number
    status?: $Enums.WrongSendStatus
    expiresAt: Date | string
    penaltyPaid?: boolean
    razorpayRefundId?: string | null
    createdAt?: Date | string
    transaction: p2pTransferCreateNestedOneWithoutWrongSendRequestInput
  }

  export type WrongSendRequestUncheckedCreateWithoutSenderInput = {
    id?: number
    txnId: number
    receiverNumber: string
    amount: bigint | number
    status?: $Enums.WrongSendStatus
    expiresAt: Date | string
    penaltyPaid?: boolean
    razorpayRefundId?: string | null
    createdAt?: Date | string
  }

  export type WrongSendRequestCreateOrConnectWithoutSenderInput = {
    where: WrongSendRequestWhereUniqueInput
    create: XOR<WrongSendRequestCreateWithoutSenderInput, WrongSendRequestUncheckedCreateWithoutSenderInput>
  }

  export type WrongSendRequestCreateManySenderInputEnvelope = {
    data: WrongSendRequestCreateManySenderInput | WrongSendRequestCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type BillSplitGroupCreateWithoutCreatedByInput = {
    name: string
    description?: string | null
    totalAmount: number
    currency?: string
    createdAt?: Date | string
    settledAt?: Date | string | null
    status?: string
    members?: BillSplitMemberCreateNestedManyWithoutGroupInput
    payments?: BillSplitPaymentCreateNestedManyWithoutGroupInput
    rewards?: RewardCreateNestedManyWithoutBillSplitGroupInput
  }

  export type BillSplitGroupUncheckedCreateWithoutCreatedByInput = {
    id?: number
    name: string
    description?: string | null
    totalAmount: number
    currency?: string
    createdAt?: Date | string
    settledAt?: Date | string | null
    status?: string
    members?: BillSplitMemberUncheckedCreateNestedManyWithoutGroupInput
    payments?: BillSplitPaymentUncheckedCreateNestedManyWithoutGroupInput
    rewards?: RewardUncheckedCreateNestedManyWithoutBillSplitGroupInput
  }

  export type BillSplitGroupCreateOrConnectWithoutCreatedByInput = {
    where: BillSplitGroupWhereUniqueInput
    create: XOR<BillSplitGroupCreateWithoutCreatedByInput, BillSplitGroupUncheckedCreateWithoutCreatedByInput>
  }

  export type BillSplitGroupCreateManyCreatedByInputEnvelope = {
    data: BillSplitGroupCreateManyCreatedByInput | BillSplitGroupCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type BillSplitMemberCreateWithoutUserInput = {
    phone?: string | null
    name: string
    share: number
    paid?: boolean
    paidAt?: Date | string | null
    paidAmount?: number
    group: BillSplitGroupCreateNestedOneWithoutMembersInput
    request?: P2PRequestCreateNestedOneWithoutBillSplitMemberInput
    payments?: BillSplitPaymentCreateNestedManyWithoutMemberInput
  }

  export type BillSplitMemberUncheckedCreateWithoutUserInput = {
    id?: number
    groupId: number
    phone?: string | null
    name: string
    share: number
    paid?: boolean
    paidAt?: Date | string | null
    paidAmount?: number
    request?: P2PRequestUncheckedCreateNestedOneWithoutBillSplitMemberInput
    payments?: BillSplitPaymentUncheckedCreateNestedManyWithoutMemberInput
  }

  export type BillSplitMemberCreateOrConnectWithoutUserInput = {
    where: BillSplitMemberWhereUniqueInput
    create: XOR<BillSplitMemberCreateWithoutUserInput, BillSplitMemberUncheckedCreateWithoutUserInput>
  }

  export type BillSplitMemberCreateManyUserInputEnvelope = {
    data: BillSplitMemberCreateManyUserInput | BillSplitMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OnRampTransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: OnRampTransactionWhereUniqueInput
    update: XOR<OnRampTransactionUpdateWithoutUserInput, OnRampTransactionUncheckedUpdateWithoutUserInput>
    create: XOR<OnRampTransactionCreateWithoutUserInput, OnRampTransactionUncheckedCreateWithoutUserInput>
  }

  export type OnRampTransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: OnRampTransactionWhereUniqueInput
    data: XOR<OnRampTransactionUpdateWithoutUserInput, OnRampTransactionUncheckedUpdateWithoutUserInput>
  }

  export type OnRampTransactionUpdateManyWithWhereWithoutUserInput = {
    where: OnRampTransactionScalarWhereInput
    data: XOR<OnRampTransactionUpdateManyMutationInput, OnRampTransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type OnRampTransactionScalarWhereInput = {
    AND?: OnRampTransactionScalarWhereInput | OnRampTransactionScalarWhereInput[]
    OR?: OnRampTransactionScalarWhereInput[]
    NOT?: OnRampTransactionScalarWhereInput | OnRampTransactionScalarWhereInput[]
    id?: IntFilter<"OnRampTransaction"> | number
    status?: EnumOnRampStatusFilter<"OnRampTransaction"> | $Enums.OnRampStatus
    token?: StringFilter<"OnRampTransaction"> | string
    provider?: StringFilter<"OnRampTransaction"> | string
    amount?: IntFilter<"OnRampTransaction"> | number
    startTime?: DateTimeFilter<"OnRampTransaction"> | Date | string
    transactionId?: StringNullableFilter<"OnRampTransaction"> | string | null
    userId?: IntFilter<"OnRampTransaction"> | number
  }

  export type BalanceUpsertWithWhereUniqueWithoutUserInput = {
    where: BalanceWhereUniqueInput
    update: XOR<BalanceUpdateWithoutUserInput, BalanceUncheckedUpdateWithoutUserInput>
    create: XOR<BalanceCreateWithoutUserInput, BalanceUncheckedCreateWithoutUserInput>
  }

  export type BalanceUpdateWithWhereUniqueWithoutUserInput = {
    where: BalanceWhereUniqueInput
    data: XOR<BalanceUpdateWithoutUserInput, BalanceUncheckedUpdateWithoutUserInput>
  }

  export type BalanceUpdateManyWithWhereWithoutUserInput = {
    where: BalanceScalarWhereInput
    data: XOR<BalanceUpdateManyMutationInput, BalanceUncheckedUpdateManyWithoutUserInput>
  }

  export type BalanceScalarWhereInput = {
    AND?: BalanceScalarWhereInput | BalanceScalarWhereInput[]
    OR?: BalanceScalarWhereInput[]
    NOT?: BalanceScalarWhereInput | BalanceScalarWhereInput[]
    id?: IntFilter<"Balance"> | number
    userId?: IntFilter<"Balance"> | number
    amount?: IntFilter<"Balance"> | number
    locked?: IntFilter<"Balance"> | number
  }

  export type p2pTransferUpsertWithWhereUniqueWithoutFromUserInput = {
    where: p2pTransferWhereUniqueInput
    update: XOR<p2pTransferUpdateWithoutFromUserInput, p2pTransferUncheckedUpdateWithoutFromUserInput>
    create: XOR<p2pTransferCreateWithoutFromUserInput, p2pTransferUncheckedCreateWithoutFromUserInput>
  }

  export type p2pTransferUpdateWithWhereUniqueWithoutFromUserInput = {
    where: p2pTransferWhereUniqueInput
    data: XOR<p2pTransferUpdateWithoutFromUserInput, p2pTransferUncheckedUpdateWithoutFromUserInput>
  }

  export type p2pTransferUpdateManyWithWhereWithoutFromUserInput = {
    where: p2pTransferScalarWhereInput
    data: XOR<p2pTransferUpdateManyMutationInput, p2pTransferUncheckedUpdateManyWithoutFromUserInput>
  }

  export type p2pTransferScalarWhereInput = {
    AND?: p2pTransferScalarWhereInput | p2pTransferScalarWhereInput[]
    OR?: p2pTransferScalarWhereInput[]
    NOT?: p2pTransferScalarWhereInput | p2pTransferScalarWhereInput[]
    id?: IntFilter<"p2pTransfer"> | number
    amount?: IntFilter<"p2pTransfer"> | number
    timestamp?: DateTimeFilter<"p2pTransfer"> | Date | string
    fromUserId?: IntFilter<"p2pTransfer"> | number
    toUserId?: IntNullableFilter<"p2pTransfer"> | number | null
    receiverNumber?: StringNullableFilter<"p2pTransfer"> | string | null
    status?: StringFilter<"p2pTransfer"> | string
    razorpayPaymentId?: StringNullableFilter<"p2pTransfer"> | string | null
    paymentMethod?: StringFilter<"p2pTransfer"> | string
    deviceInfo?: JsonNullableFilter<"p2pTransfer">
    ipAddress?: StringNullableFilter<"p2pTransfer"> | string | null
    merchantId?: IntNullableFilter<"p2pTransfer"> | number | null
    latitude?: FloatNullableFilter<"p2pTransfer"> | number | null
    longitude?: FloatNullableFilter<"p2pTransfer"> | number | null
    isFraud?: BoolNullableFilter<"p2pTransfer"> | boolean | null
    fraudScore?: FloatNullableFilter<"p2pTransfer"> | number | null
    fraudReason?: StringNullableFilter<"p2pTransfer"> | string | null
    riskLevel?: StringNullableFilter<"p2pTransfer"> | string | null
  }

  export type p2pTransferUpsertWithWhereUniqueWithoutToUserInput = {
    where: p2pTransferWhereUniqueInput
    update: XOR<p2pTransferUpdateWithoutToUserInput, p2pTransferUncheckedUpdateWithoutToUserInput>
    create: XOR<p2pTransferCreateWithoutToUserInput, p2pTransferUncheckedCreateWithoutToUserInput>
  }

  export type p2pTransferUpdateWithWhereUniqueWithoutToUserInput = {
    where: p2pTransferWhereUniqueInput
    data: XOR<p2pTransferUpdateWithoutToUserInput, p2pTransferUncheckedUpdateWithoutToUserInput>
  }

  export type p2pTransferUpdateManyWithWhereWithoutToUserInput = {
    where: p2pTransferScalarWhereInput
    data: XOR<p2pTransferUpdateManyMutationInput, p2pTransferUncheckedUpdateManyWithoutToUserInput>
  }

  export type P2PRequestUpsertWithWhereUniqueWithoutSenderInput = {
    where: P2PRequestWhereUniqueInput
    update: XOR<P2PRequestUpdateWithoutSenderInput, P2PRequestUncheckedUpdateWithoutSenderInput>
    create: XOR<P2PRequestCreateWithoutSenderInput, P2PRequestUncheckedCreateWithoutSenderInput>
  }

  export type P2PRequestUpdateWithWhereUniqueWithoutSenderInput = {
    where: P2PRequestWhereUniqueInput
    data: XOR<P2PRequestUpdateWithoutSenderInput, P2PRequestUncheckedUpdateWithoutSenderInput>
  }

  export type P2PRequestUpdateManyWithWhereWithoutSenderInput = {
    where: P2PRequestScalarWhereInput
    data: XOR<P2PRequestUpdateManyMutationInput, P2PRequestUncheckedUpdateManyWithoutSenderInput>
  }

  export type P2PRequestScalarWhereInput = {
    AND?: P2PRequestScalarWhereInput | P2PRequestScalarWhereInput[]
    OR?: P2PRequestScalarWhereInput[]
    NOT?: P2PRequestScalarWhereInput | P2PRequestScalarWhereInput[]
    id?: IntFilter<"P2PRequest"> | number
    senderId?: IntFilter<"P2PRequest"> | number
    receiverId?: IntNullableFilter<"P2PRequest"> | number | null
    receiverNumber?: StringFilter<"P2PRequest"> | string
    amount?: IntFilter<"P2PRequest"> | number
    message?: StringNullableFilter<"P2PRequest"> | string | null
    status?: EnumP2PRequestStatusFilter<"P2PRequest"> | $Enums.P2PRequestStatus
    createdAt?: DateTimeFilter<"P2PRequest"> | Date | string
    settledAt?: DateTimeNullableFilter<"P2PRequest"> | Date | string | null
    billSplitMemberId?: IntNullableFilter<"P2PRequest"> | number | null
  }

  export type P2PRequestUpsertWithWhereUniqueWithoutReceiverInput = {
    where: P2PRequestWhereUniqueInput
    update: XOR<P2PRequestUpdateWithoutReceiverInput, P2PRequestUncheckedUpdateWithoutReceiverInput>
    create: XOR<P2PRequestCreateWithoutReceiverInput, P2PRequestUncheckedCreateWithoutReceiverInput>
  }

  export type P2PRequestUpdateWithWhereUniqueWithoutReceiverInput = {
    where: P2PRequestWhereUniqueInput
    data: XOR<P2PRequestUpdateWithoutReceiverInput, P2PRequestUncheckedUpdateWithoutReceiverInput>
  }

  export type P2PRequestUpdateManyWithWhereWithoutReceiverInput = {
    where: P2PRequestScalarWhereInput
    data: XOR<P2PRequestUpdateManyMutationInput, P2PRequestUncheckedUpdateManyWithoutReceiverInput>
  }

  export type BillScheduleUpsertWithWhereUniqueWithoutUserInput = {
    where: BillScheduleWhereUniqueInput
    update: XOR<BillScheduleUpdateWithoutUserInput, BillScheduleUncheckedUpdateWithoutUserInput>
    create: XOR<BillScheduleCreateWithoutUserInput, BillScheduleUncheckedCreateWithoutUserInput>
  }

  export type BillScheduleUpdateWithWhereUniqueWithoutUserInput = {
    where: BillScheduleWhereUniqueInput
    data: XOR<BillScheduleUpdateWithoutUserInput, BillScheduleUncheckedUpdateWithoutUserInput>
  }

  export type BillScheduleUpdateManyWithWhereWithoutUserInput = {
    where: BillScheduleScalarWhereInput
    data: XOR<BillScheduleUpdateManyMutationInput, BillScheduleUncheckedUpdateManyWithoutUserInput>
  }

  export type BillScheduleScalarWhereInput = {
    AND?: BillScheduleScalarWhereInput | BillScheduleScalarWhereInput[]
    OR?: BillScheduleScalarWhereInput[]
    NOT?: BillScheduleScalarWhereInput | BillScheduleScalarWhereInput[]
    id?: IntFilter<"BillSchedule"> | number
    userId?: IntFilter<"BillSchedule"> | number
    merchantId?: IntNullableFilter<"BillSchedule"> | number | null
    billType?: StringFilter<"BillSchedule"> | string
    provider?: StringFilter<"BillSchedule"> | string
    accountNo?: StringFilter<"BillSchedule"> | string
    amount?: IntFilter<"BillSchedule"> | number
    dueDate?: DateTimeFilter<"BillSchedule"> | Date | string
    nextPayment?: DateTimeNullableFilter<"BillSchedule"> | Date | string | null
    createdAt?: DateTimeFilter<"BillSchedule"> | Date | string
    paymentMethod?: StringFilter<"BillSchedule"> | string
    status?: StringFilter<"BillSchedule"> | string
    token?: StringNullableFilter<"BillSchedule"> | string | null
  }

  export type MerchantPaymentUpsertWithWhereUniqueWithoutUserInput = {
    where: MerchantPaymentWhereUniqueInput
    update: XOR<MerchantPaymentUpdateWithoutUserInput, MerchantPaymentUncheckedUpdateWithoutUserInput>
    create: XOR<MerchantPaymentCreateWithoutUserInput, MerchantPaymentUncheckedCreateWithoutUserInput>
  }

  export type MerchantPaymentUpdateWithWhereUniqueWithoutUserInput = {
    where: MerchantPaymentWhereUniqueInput
    data: XOR<MerchantPaymentUpdateWithoutUserInput, MerchantPaymentUncheckedUpdateWithoutUserInput>
  }

  export type MerchantPaymentUpdateManyWithWhereWithoutUserInput = {
    where: MerchantPaymentScalarWhereInput
    data: XOR<MerchantPaymentUpdateManyMutationInput, MerchantPaymentUncheckedUpdateManyWithoutUserInput>
  }

  export type MerchantPaymentScalarWhereInput = {
    AND?: MerchantPaymentScalarWhereInput | MerchantPaymentScalarWhereInput[]
    OR?: MerchantPaymentScalarWhereInput[]
    NOT?: MerchantPaymentScalarWhereInput | MerchantPaymentScalarWhereInput[]
    id?: IntFilter<"MerchantPayment"> | number
    merchantId?: IntFilter<"MerchantPayment"> | number
    qrId?: StringFilter<"MerchantPayment"> | string
    amount?: IntFilter<"MerchantPayment"> | number
    status?: StringFilter<"MerchantPayment"> | string
    userId?: IntNullableFilter<"MerchantPayment"> | number | null
    createdAt?: DateTimeFilter<"MerchantPayment"> | Date | string
    updatedAt?: DateTimeFilter<"MerchantPayment"> | Date | string
    transactionId?: StringNullableFilter<"MerchantPayment"> | string | null
  }

  export type RechargeOrderUpsertWithWhereUniqueWithoutUserInput = {
    where: RechargeOrderWhereUniqueInput
    update: XOR<RechargeOrderUpdateWithoutUserInput, RechargeOrderUncheckedUpdateWithoutUserInput>
    create: XOR<RechargeOrderCreateWithoutUserInput, RechargeOrderUncheckedCreateWithoutUserInput>
  }

  export type RechargeOrderUpdateWithWhereUniqueWithoutUserInput = {
    where: RechargeOrderWhereUniqueInput
    data: XOR<RechargeOrderUpdateWithoutUserInput, RechargeOrderUncheckedUpdateWithoutUserInput>
  }

  export type RechargeOrderUpdateManyWithWhereWithoutUserInput = {
    where: RechargeOrderScalarWhereInput
    data: XOR<RechargeOrderUpdateManyMutationInput, RechargeOrderUncheckedUpdateManyWithoutUserInput>
  }

  export type RechargeOrderScalarWhereInput = {
    AND?: RechargeOrderScalarWhereInput | RechargeOrderScalarWhereInput[]
    OR?: RechargeOrderScalarWhereInput[]
    NOT?: RechargeOrderScalarWhereInput | RechargeOrderScalarWhereInput[]
    id?: IntFilter<"RechargeOrder"> | number
    userId?: IntFilter<"RechargeOrder"> | number
    planId?: IntNullableFilter<"RechargeOrder"> | number | null
    mobileNumber?: StringFilter<"RechargeOrder"> | string
    operator?: StringFilter<"RechargeOrder"> | string
    circle?: StringFilter<"RechargeOrder"> | string
    amount?: IntFilter<"RechargeOrder"> | number
    status?: StringFilter<"RechargeOrder"> | string
    providerTxnId?: StringNullableFilter<"RechargeOrder"> | string | null
    orderId?: StringFilter<"RechargeOrder"> | string
    createdAt?: DateTimeFilter<"RechargeOrder"> | Date | string
    updatedAt?: DateTimeFilter<"RechargeOrder"> | Date | string
  }

  export type RewardUpsertWithWhereUniqueWithoutUserInput = {
    where: RewardWhereUniqueInput
    update: XOR<RewardUpdateWithoutUserInput, RewardUncheckedUpdateWithoutUserInput>
    create: XOR<RewardCreateWithoutUserInput, RewardUncheckedCreateWithoutUserInput>
  }

  export type RewardUpdateWithWhereUniqueWithoutUserInput = {
    where: RewardWhereUniqueInput
    data: XOR<RewardUpdateWithoutUserInput, RewardUncheckedUpdateWithoutUserInput>
  }

  export type RewardUpdateManyWithWhereWithoutUserInput = {
    where: RewardScalarWhereInput
    data: XOR<RewardUpdateManyMutationInput, RewardUncheckedUpdateManyWithoutUserInput>
  }

  export type RewardScalarWhereInput = {
    AND?: RewardScalarWhereInput | RewardScalarWhereInput[]
    OR?: RewardScalarWhereInput[]
    NOT?: RewardScalarWhereInput | RewardScalarWhereInput[]
    id?: IntFilter<"Reward"> | number
    userId?: IntFilter<"Reward"> | number
    type?: EnumRewardTypeFilter<"Reward"> | $Enums.RewardType
    amount?: BigIntFilter<"Reward"> | bigint | number
    status?: EnumRewardStatusFilter<"Reward"> | $Enums.RewardStatus
    earnedAt?: DateTimeFilter<"Reward"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Reward"> | Date | string | null
    metadata?: JsonNullableFilter<"Reward">
    billSplitGroupId?: IntNullableFilter<"Reward"> | number | null
  }

  export type ReferralUpsertWithWhereUniqueWithoutReferrerInput = {
    where: ReferralWhereUniqueInput
    update: XOR<ReferralUpdateWithoutReferrerInput, ReferralUncheckedUpdateWithoutReferrerInput>
    create: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput>
  }

  export type ReferralUpdateWithWhereUniqueWithoutReferrerInput = {
    where: ReferralWhereUniqueInput
    data: XOR<ReferralUpdateWithoutReferrerInput, ReferralUncheckedUpdateWithoutReferrerInput>
  }

  export type ReferralUpdateManyWithWhereWithoutReferrerInput = {
    where: ReferralScalarWhereInput
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyWithoutReferrerInput>
  }

  export type ReferralScalarWhereInput = {
    AND?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
    OR?: ReferralScalarWhereInput[]
    NOT?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
    id?: IntFilter<"Referral"> | number
    referrerId?: IntFilter<"Referral"> | number
    referredUserId?: IntNullableFilter<"Referral"> | number | null
    referralCode?: StringFilter<"Referral"> | string
  }

  export type ReferralUpsertWithWhereUniqueWithoutReferredInput = {
    where: ReferralWhereUniqueInput
    update: XOR<ReferralUpdateWithoutReferredInput, ReferralUncheckedUpdateWithoutReferredInput>
    create: XOR<ReferralCreateWithoutReferredInput, ReferralUncheckedCreateWithoutReferredInput>
  }

  export type ReferralUpdateWithWhereUniqueWithoutReferredInput = {
    where: ReferralWhereUniqueInput
    data: XOR<ReferralUpdateWithoutReferredInput, ReferralUncheckedUpdateWithoutReferredInput>
  }

  export type ReferralUpdateManyWithWhereWithoutReferredInput = {
    where: ReferralScalarWhereInput
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyWithoutReferredInput>
  }

  export type WrongSendRequestUpsertWithWhereUniqueWithoutSenderInput = {
    where: WrongSendRequestWhereUniqueInput
    update: XOR<WrongSendRequestUpdateWithoutSenderInput, WrongSendRequestUncheckedUpdateWithoutSenderInput>
    create: XOR<WrongSendRequestCreateWithoutSenderInput, WrongSendRequestUncheckedCreateWithoutSenderInput>
  }

  export type WrongSendRequestUpdateWithWhereUniqueWithoutSenderInput = {
    where: WrongSendRequestWhereUniqueInput
    data: XOR<WrongSendRequestUpdateWithoutSenderInput, WrongSendRequestUncheckedUpdateWithoutSenderInput>
  }

  export type WrongSendRequestUpdateManyWithWhereWithoutSenderInput = {
    where: WrongSendRequestScalarWhereInput
    data: XOR<WrongSendRequestUpdateManyMutationInput, WrongSendRequestUncheckedUpdateManyWithoutSenderInput>
  }

  export type WrongSendRequestScalarWhereInput = {
    AND?: WrongSendRequestScalarWhereInput | WrongSendRequestScalarWhereInput[]
    OR?: WrongSendRequestScalarWhereInput[]
    NOT?: WrongSendRequestScalarWhereInput | WrongSendRequestScalarWhereInput[]
    id?: IntFilter<"WrongSendRequest"> | number
    txnId?: IntFilter<"WrongSendRequest"> | number
    senderId?: IntFilter<"WrongSendRequest"> | number
    receiverNumber?: StringFilter<"WrongSendRequest"> | string
    amount?: BigIntFilter<"WrongSendRequest"> | bigint | number
    status?: EnumWrongSendStatusFilter<"WrongSendRequest"> | $Enums.WrongSendStatus
    expiresAt?: DateTimeFilter<"WrongSendRequest"> | Date | string
    penaltyPaid?: BoolFilter<"WrongSendRequest"> | boolean
    razorpayRefundId?: StringNullableFilter<"WrongSendRequest"> | string | null
    createdAt?: DateTimeFilter<"WrongSendRequest"> | Date | string
  }

  export type BillSplitGroupUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: BillSplitGroupWhereUniqueInput
    update: XOR<BillSplitGroupUpdateWithoutCreatedByInput, BillSplitGroupUncheckedUpdateWithoutCreatedByInput>
    create: XOR<BillSplitGroupCreateWithoutCreatedByInput, BillSplitGroupUncheckedCreateWithoutCreatedByInput>
  }

  export type BillSplitGroupUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: BillSplitGroupWhereUniqueInput
    data: XOR<BillSplitGroupUpdateWithoutCreatedByInput, BillSplitGroupUncheckedUpdateWithoutCreatedByInput>
  }

  export type BillSplitGroupUpdateManyWithWhereWithoutCreatedByInput = {
    where: BillSplitGroupScalarWhereInput
    data: XOR<BillSplitGroupUpdateManyMutationInput, BillSplitGroupUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type BillSplitGroupScalarWhereInput = {
    AND?: BillSplitGroupScalarWhereInput | BillSplitGroupScalarWhereInput[]
    OR?: BillSplitGroupScalarWhereInput[]
    NOT?: BillSplitGroupScalarWhereInput | BillSplitGroupScalarWhereInput[]
    id?: IntFilter<"BillSplitGroup"> | number
    name?: StringFilter<"BillSplitGroup"> | string
    description?: StringNullableFilter<"BillSplitGroup"> | string | null
    totalAmount?: IntFilter<"BillSplitGroup"> | number
    currency?: StringFilter<"BillSplitGroup"> | string
    createdById?: IntFilter<"BillSplitGroup"> | number
    createdAt?: DateTimeFilter<"BillSplitGroup"> | Date | string
    settledAt?: DateTimeNullableFilter<"BillSplitGroup"> | Date | string | null
    status?: StringFilter<"BillSplitGroup"> | string
  }

  export type BillSplitMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: BillSplitMemberWhereUniqueInput
    update: XOR<BillSplitMemberUpdateWithoutUserInput, BillSplitMemberUncheckedUpdateWithoutUserInput>
    create: XOR<BillSplitMemberCreateWithoutUserInput, BillSplitMemberUncheckedCreateWithoutUserInput>
  }

  export type BillSplitMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: BillSplitMemberWhereUniqueInput
    data: XOR<BillSplitMemberUpdateWithoutUserInput, BillSplitMemberUncheckedUpdateWithoutUserInput>
  }

  export type BillSplitMemberUpdateManyWithWhereWithoutUserInput = {
    where: BillSplitMemberScalarWhereInput
    data: XOR<BillSplitMemberUpdateManyMutationInput, BillSplitMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type BillSplitMemberScalarWhereInput = {
    AND?: BillSplitMemberScalarWhereInput | BillSplitMemberScalarWhereInput[]
    OR?: BillSplitMemberScalarWhereInput[]
    NOT?: BillSplitMemberScalarWhereInput | BillSplitMemberScalarWhereInput[]
    id?: IntFilter<"BillSplitMember"> | number
    groupId?: IntFilter<"BillSplitMember"> | number
    userId?: IntNullableFilter<"BillSplitMember"> | number | null
    phone?: StringNullableFilter<"BillSplitMember"> | string | null
    name?: StringFilter<"BillSplitMember"> | string
    share?: IntFilter<"BillSplitMember"> | number
    paid?: BoolFilter<"BillSplitMember"> | boolean
    paidAt?: DateTimeNullableFilter<"BillSplitMember"> | Date | string | null
    paidAmount?: IntFilter<"BillSplitMember"> | number
  }

  export type UserCreateWithoutSentTransfersInput = {
    email?: string | null
    name?: string | null
    number: string
    password: string
    sessionToken?: string | null
    image?: string | null
    userpin: string
    resetOtp?: string | null
    resetExpires?: Date | string | null
    OnRampTransaction?: OnRampTransactionCreateNestedManyWithoutUserInput
    Balance?: BalanceCreateNestedManyWithoutUserInput
    receivedTransfers?: p2pTransferCreateNestedManyWithoutToUserInput
    sentRequests?: P2PRequestCreateNestedManyWithoutSenderInput
    receivedRequests?: P2PRequestCreateNestedManyWithoutReceiverInput
    billSchedules?: BillScheduleCreateNestedManyWithoutUserInput
    merchantPayments?: MerchantPaymentCreateNestedManyWithoutUserInput
    rechargeOrders?: RechargeOrderCreateNestedManyWithoutUserInput
    rewards?: RewardCreateNestedManyWithoutUserInput
    referralsAsReferrer?: ReferralCreateNestedManyWithoutReferrerInput
    referralsAsReferred?: ReferralCreateNestedManyWithoutReferredInput
    wrongSendRequests?: WrongSendRequestCreateNestedManyWithoutSenderInput
    createdGroups?: BillSplitGroupCreateNestedManyWithoutCreatedByInput
    billSplitMembers?: BillSplitMemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSentTransfersInput = {
    id?: number
    email?: string | null
    name?: string | null
    number: string
    password: string
    sessionToken?: string | null
    image?: string | null
    userpin: string
    resetOtp?: string | null
    resetExpires?: Date | string | null
    OnRampTransaction?: OnRampTransactionUncheckedCreateNestedManyWithoutUserInput
    Balance?: BalanceUncheckedCreateNestedManyWithoutUserInput
    receivedTransfers?: p2pTransferUncheckedCreateNestedManyWithoutToUserInput
    sentRequests?: P2PRequestUncheckedCreateNestedManyWithoutSenderInput
    receivedRequests?: P2PRequestUncheckedCreateNestedManyWithoutReceiverInput
    billSchedules?: BillScheduleUncheckedCreateNestedManyWithoutUserInput
    merchantPayments?: MerchantPaymentUncheckedCreateNestedManyWithoutUserInput
    rechargeOrders?: RechargeOrderUncheckedCreateNestedManyWithoutUserInput
    rewards?: RewardUncheckedCreateNestedManyWithoutUserInput
    referralsAsReferrer?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referralsAsReferred?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    wrongSendRequests?: WrongSendRequestUncheckedCreateNestedManyWithoutSenderInput
    createdGroups?: BillSplitGroupUncheckedCreateNestedManyWithoutCreatedByInput
    billSplitMembers?: BillSplitMemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSentTransfersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentTransfersInput, UserUncheckedCreateWithoutSentTransfersInput>
  }

  export type UserCreateWithoutReceivedTransfersInput = {
    email?: string | null
    name?: string | null
    number: string
    password: string
    sessionToken?: string | null
    image?: string | null
    userpin: string
    resetOtp?: string | null
    resetExpires?: Date | string | null
    OnRampTransaction?: OnRampTransactionCreateNestedManyWithoutUserInput
    Balance?: BalanceCreateNestedManyWithoutUserInput
    sentTransfers?: p2pTransferCreateNestedManyWithoutFromUserInput
    sentRequests?: P2PRequestCreateNestedManyWithoutSenderInput
    receivedRequests?: P2PRequestCreateNestedManyWithoutReceiverInput
    billSchedules?: BillScheduleCreateNestedManyWithoutUserInput
    merchantPayments?: MerchantPaymentCreateNestedManyWithoutUserInput
    rechargeOrders?: RechargeOrderCreateNestedManyWithoutUserInput
    rewards?: RewardCreateNestedManyWithoutUserInput
    referralsAsReferrer?: ReferralCreateNestedManyWithoutReferrerInput
    referralsAsReferred?: ReferralCreateNestedManyWithoutReferredInput
    wrongSendRequests?: WrongSendRequestCreateNestedManyWithoutSenderInput
    createdGroups?: BillSplitGroupCreateNestedManyWithoutCreatedByInput
    billSplitMembers?: BillSplitMemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReceivedTransfersInput = {
    id?: number
    email?: string | null
    name?: string | null
    number: string
    password: string
    sessionToken?: string | null
    image?: string | null
    userpin: string
    resetOtp?: string | null
    resetExpires?: Date | string | null
    OnRampTransaction?: OnRampTransactionUncheckedCreateNestedManyWithoutUserInput
    Balance?: BalanceUncheckedCreateNestedManyWithoutUserInput
    sentTransfers?: p2pTransferUncheckedCreateNestedManyWithoutFromUserInput
    sentRequests?: P2PRequestUncheckedCreateNestedManyWithoutSenderInput
    receivedRequests?: P2PRequestUncheckedCreateNestedManyWithoutReceiverInput
    billSchedules?: BillScheduleUncheckedCreateNestedManyWithoutUserInput
    merchantPayments?: MerchantPaymentUncheckedCreateNestedManyWithoutUserInput
    rechargeOrders?: RechargeOrderUncheckedCreateNestedManyWithoutUserInput
    rewards?: RewardUncheckedCreateNestedManyWithoutUserInput
    referralsAsReferrer?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referralsAsReferred?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    wrongSendRequests?: WrongSendRequestUncheckedCreateNestedManyWithoutSenderInput
    createdGroups?: BillSplitGroupUncheckedCreateNestedManyWithoutCreatedByInput
    billSplitMembers?: BillSplitMemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReceivedTransfersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedTransfersInput, UserUncheckedCreateWithoutReceivedTransfersInput>
  }

  export type WrongSendRequestCreateWithoutTransactionInput = {
    receiverNumber: string
    amount: bigint | number
    status?: $Enums.WrongSendStatus
    expiresAt: Date | string
    penaltyPaid?: boolean
    razorpayRefundId?: string | null
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutWrongSendRequestsInput
  }

  export type WrongSendRequestUncheckedCreateWithoutTransactionInput = {
    id?: number
    senderId: number
    receiverNumber: string
    amount: bigint | number
    status?: $Enums.WrongSendStatus
    expiresAt: Date | string
    penaltyPaid?: boolean
    razorpayRefundId?: string | null
    createdAt?: Date | string
  }

  export type WrongSendRequestCreateOrConnectWithoutTransactionInput = {
    where: WrongSendRequestWhereUniqueInput
    create: XOR<WrongSendRequestCreateWithoutTransactionInput, WrongSendRequestUncheckedCreateWithoutTransactionInput>
  }

  export type BillSplitPaymentCreateWithoutP2pTransferInput = {
    amount: number
    paidAt?: Date | string
    group: BillSplitGroupCreateNestedOneWithoutPaymentsInput
    member: BillSplitMemberCreateNestedOneWithoutPaymentsInput
  }

  export type BillSplitPaymentUncheckedCreateWithoutP2pTransferInput = {
    id?: number
    groupId: number
    memberId: number
    amount: number
    paidAt?: Date | string
  }

  export type BillSplitPaymentCreateOrConnectWithoutP2pTransferInput = {
    where: BillSplitPaymentWhereUniqueInput
    create: XOR<BillSplitPaymentCreateWithoutP2pTransferInput, BillSplitPaymentUncheckedCreateWithoutP2pTransferInput>
  }

  export type UserUpsertWithoutSentTransfersInput = {
    update: XOR<UserUpdateWithoutSentTransfersInput, UserUncheckedUpdateWithoutSentTransfersInput>
    create: XOR<UserCreateWithoutSentTransfersInput, UserUncheckedCreateWithoutSentTransfersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentTransfersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentTransfersInput, UserUncheckedUpdateWithoutSentTransfersInput>
  }

  export type UserUpdateWithoutSentTransfersInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    userpin?: StringFieldUpdateOperationsInput | string
    resetOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OnRampTransaction?: OnRampTransactionUpdateManyWithoutUserNestedInput
    Balance?: BalanceUpdateManyWithoutUserNestedInput
    receivedTransfers?: p2pTransferUpdateManyWithoutToUserNestedInput
    sentRequests?: P2PRequestUpdateManyWithoutSenderNestedInput
    receivedRequests?: P2PRequestUpdateManyWithoutReceiverNestedInput
    billSchedules?: BillScheduleUpdateManyWithoutUserNestedInput
    merchantPayments?: MerchantPaymentUpdateManyWithoutUserNestedInput
    rechargeOrders?: RechargeOrderUpdateManyWithoutUserNestedInput
    rewards?: RewardUpdateManyWithoutUserNestedInput
    referralsAsReferrer?: ReferralUpdateManyWithoutReferrerNestedInput
    referralsAsReferred?: ReferralUpdateManyWithoutReferredNestedInput
    wrongSendRequests?: WrongSendRequestUpdateManyWithoutSenderNestedInput
    createdGroups?: BillSplitGroupUpdateManyWithoutCreatedByNestedInput
    billSplitMembers?: BillSplitMemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSentTransfersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    userpin?: StringFieldUpdateOperationsInput | string
    resetOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OnRampTransaction?: OnRampTransactionUncheckedUpdateManyWithoutUserNestedInput
    Balance?: BalanceUncheckedUpdateManyWithoutUserNestedInput
    receivedTransfers?: p2pTransferUncheckedUpdateManyWithoutToUserNestedInput
    sentRequests?: P2PRequestUncheckedUpdateManyWithoutSenderNestedInput
    receivedRequests?: P2PRequestUncheckedUpdateManyWithoutReceiverNestedInput
    billSchedules?: BillScheduleUncheckedUpdateManyWithoutUserNestedInput
    merchantPayments?: MerchantPaymentUncheckedUpdateManyWithoutUserNestedInput
    rechargeOrders?: RechargeOrderUncheckedUpdateManyWithoutUserNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutUserNestedInput
    referralsAsReferrer?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referralsAsReferred?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    wrongSendRequests?: WrongSendRequestUncheckedUpdateManyWithoutSenderNestedInput
    createdGroups?: BillSplitGroupUncheckedUpdateManyWithoutCreatedByNestedInput
    billSplitMembers?: BillSplitMemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutReceivedTransfersInput = {
    update: XOR<UserUpdateWithoutReceivedTransfersInput, UserUncheckedUpdateWithoutReceivedTransfersInput>
    create: XOR<UserCreateWithoutReceivedTransfersInput, UserUncheckedCreateWithoutReceivedTransfersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedTransfersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedTransfersInput, UserUncheckedUpdateWithoutReceivedTransfersInput>
  }

  export type UserUpdateWithoutReceivedTransfersInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    userpin?: StringFieldUpdateOperationsInput | string
    resetOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OnRampTransaction?: OnRampTransactionUpdateManyWithoutUserNestedInput
    Balance?: BalanceUpdateManyWithoutUserNestedInput
    sentTransfers?: p2pTransferUpdateManyWithoutFromUserNestedInput
    sentRequests?: P2PRequestUpdateManyWithoutSenderNestedInput
    receivedRequests?: P2PRequestUpdateManyWithoutReceiverNestedInput
    billSchedules?: BillScheduleUpdateManyWithoutUserNestedInput
    merchantPayments?: MerchantPaymentUpdateManyWithoutUserNestedInput
    rechargeOrders?: RechargeOrderUpdateManyWithoutUserNestedInput
    rewards?: RewardUpdateManyWithoutUserNestedInput
    referralsAsReferrer?: ReferralUpdateManyWithoutReferrerNestedInput
    referralsAsReferred?: ReferralUpdateManyWithoutReferredNestedInput
    wrongSendRequests?: WrongSendRequestUpdateManyWithoutSenderNestedInput
    createdGroups?: BillSplitGroupUpdateManyWithoutCreatedByNestedInput
    billSplitMembers?: BillSplitMemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedTransfersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    userpin?: StringFieldUpdateOperationsInput | string
    resetOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OnRampTransaction?: OnRampTransactionUncheckedUpdateManyWithoutUserNestedInput
    Balance?: BalanceUncheckedUpdateManyWithoutUserNestedInput
    sentTransfers?: p2pTransferUncheckedUpdateManyWithoutFromUserNestedInput
    sentRequests?: P2PRequestUncheckedUpdateManyWithoutSenderNestedInput
    receivedRequests?: P2PRequestUncheckedUpdateManyWithoutReceiverNestedInput
    billSchedules?: BillScheduleUncheckedUpdateManyWithoutUserNestedInput
    merchantPayments?: MerchantPaymentUncheckedUpdateManyWithoutUserNestedInput
    rechargeOrders?: RechargeOrderUncheckedUpdateManyWithoutUserNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutUserNestedInput
    referralsAsReferrer?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referralsAsReferred?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    wrongSendRequests?: WrongSendRequestUncheckedUpdateManyWithoutSenderNestedInput
    createdGroups?: BillSplitGroupUncheckedUpdateManyWithoutCreatedByNestedInput
    billSplitMembers?: BillSplitMemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WrongSendRequestUpsertWithoutTransactionInput = {
    update: XOR<WrongSendRequestUpdateWithoutTransactionInput, WrongSendRequestUncheckedUpdateWithoutTransactionInput>
    create: XOR<WrongSendRequestCreateWithoutTransactionInput, WrongSendRequestUncheckedCreateWithoutTransactionInput>
    where?: WrongSendRequestWhereInput
  }

  export type WrongSendRequestUpdateToOneWithWhereWithoutTransactionInput = {
    where?: WrongSendRequestWhereInput
    data: XOR<WrongSendRequestUpdateWithoutTransactionInput, WrongSendRequestUncheckedUpdateWithoutTransactionInput>
  }

  export type WrongSendRequestUpdateWithoutTransactionInput = {
    receiverNumber?: StringFieldUpdateOperationsInput | string
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumWrongSendStatusFieldUpdateOperationsInput | $Enums.WrongSendStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    penaltyPaid?: BoolFieldUpdateOperationsInput | boolean
    razorpayRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutWrongSendRequestsNestedInput
  }

  export type WrongSendRequestUncheckedUpdateWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    receiverNumber?: StringFieldUpdateOperationsInput | string
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumWrongSendStatusFieldUpdateOperationsInput | $Enums.WrongSendStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    penaltyPaid?: BoolFieldUpdateOperationsInput | boolean
    razorpayRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillSplitPaymentUpsertWithoutP2pTransferInput = {
    update: XOR<BillSplitPaymentUpdateWithoutP2pTransferInput, BillSplitPaymentUncheckedUpdateWithoutP2pTransferInput>
    create: XOR<BillSplitPaymentCreateWithoutP2pTransferInput, BillSplitPaymentUncheckedCreateWithoutP2pTransferInput>
    where?: BillSplitPaymentWhereInput
  }

  export type BillSplitPaymentUpdateToOneWithWhereWithoutP2pTransferInput = {
    where?: BillSplitPaymentWhereInput
    data: XOR<BillSplitPaymentUpdateWithoutP2pTransferInput, BillSplitPaymentUncheckedUpdateWithoutP2pTransferInput>
  }

  export type BillSplitPaymentUpdateWithoutP2pTransferInput = {
    amount?: IntFieldUpdateOperationsInput | number
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: BillSplitGroupUpdateOneRequiredWithoutPaymentsNestedInput
    member?: BillSplitMemberUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type BillSplitPaymentUncheckedUpdateWithoutP2pTransferInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    memberId?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillScheduleCreateWithoutMerchantInput = {
    billType: string
    provider: string
    accountNo: string
    amount: number
    dueDate: Date | string
    nextPayment?: Date | string | null
    createdAt?: Date | string
    paymentMethod?: string
    status?: string
    token?: string | null
    user: UserCreateNestedOneWithoutBillSchedulesInput
  }

  export type BillScheduleUncheckedCreateWithoutMerchantInput = {
    id?: number
    userId: number
    billType: string
    provider: string
    accountNo: string
    amount: number
    dueDate: Date | string
    nextPayment?: Date | string | null
    createdAt?: Date | string
    paymentMethod?: string
    status?: string
    token?: string | null
  }

  export type BillScheduleCreateOrConnectWithoutMerchantInput = {
    where: BillScheduleWhereUniqueInput
    create: XOR<BillScheduleCreateWithoutMerchantInput, BillScheduleUncheckedCreateWithoutMerchantInput>
  }

  export type BillScheduleCreateManyMerchantInputEnvelope = {
    data: BillScheduleCreateManyMerchantInput | BillScheduleCreateManyMerchantInput[]
    skipDuplicates?: boolean
  }

  export type MerchantPaymentCreateWithoutMerchantInput = {
    qrId: string
    amount: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionId?: string | null
    user?: UserCreateNestedOneWithoutMerchantPaymentsInput
  }

  export type MerchantPaymentUncheckedCreateWithoutMerchantInput = {
    id?: number
    qrId: string
    amount: number
    status: string
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionId?: string | null
  }

  export type MerchantPaymentCreateOrConnectWithoutMerchantInput = {
    where: MerchantPaymentWhereUniqueInput
    create: XOR<MerchantPaymentCreateWithoutMerchantInput, MerchantPaymentUncheckedCreateWithoutMerchantInput>
  }

  export type MerchantPaymentCreateManyMerchantInputEnvelope = {
    data: MerchantPaymentCreateManyMerchantInput | MerchantPaymentCreateManyMerchantInput[]
    skipDuplicates?: boolean
  }

  export type BillScheduleUpsertWithWhereUniqueWithoutMerchantInput = {
    where: BillScheduleWhereUniqueInput
    update: XOR<BillScheduleUpdateWithoutMerchantInput, BillScheduleUncheckedUpdateWithoutMerchantInput>
    create: XOR<BillScheduleCreateWithoutMerchantInput, BillScheduleUncheckedCreateWithoutMerchantInput>
  }

  export type BillScheduleUpdateWithWhereUniqueWithoutMerchantInput = {
    where: BillScheduleWhereUniqueInput
    data: XOR<BillScheduleUpdateWithoutMerchantInput, BillScheduleUncheckedUpdateWithoutMerchantInput>
  }

  export type BillScheduleUpdateManyWithWhereWithoutMerchantInput = {
    where: BillScheduleScalarWhereInput
    data: XOR<BillScheduleUpdateManyMutationInput, BillScheduleUncheckedUpdateManyWithoutMerchantInput>
  }

  export type MerchantPaymentUpsertWithWhereUniqueWithoutMerchantInput = {
    where: MerchantPaymentWhereUniqueInput
    update: XOR<MerchantPaymentUpdateWithoutMerchantInput, MerchantPaymentUncheckedUpdateWithoutMerchantInput>
    create: XOR<MerchantPaymentCreateWithoutMerchantInput, MerchantPaymentUncheckedCreateWithoutMerchantInput>
  }

  export type MerchantPaymentUpdateWithWhereUniqueWithoutMerchantInput = {
    where: MerchantPaymentWhereUniqueInput
    data: XOR<MerchantPaymentUpdateWithoutMerchantInput, MerchantPaymentUncheckedUpdateWithoutMerchantInput>
  }

  export type MerchantPaymentUpdateManyWithWhereWithoutMerchantInput = {
    where: MerchantPaymentScalarWhereInput
    data: XOR<MerchantPaymentUpdateManyMutationInput, MerchantPaymentUncheckedUpdateManyWithoutMerchantInput>
  }

  export type MerchantCreateWithoutPaymentsInput = {
    email: string
    name?: string | null
    upiId?: string | null
    auth_type: $Enums.AuthType
    billSchedules?: BillScheduleCreateNestedManyWithoutMerchantInput
  }

  export type MerchantUncheckedCreateWithoutPaymentsInput = {
    id?: number
    email: string
    name?: string | null
    upiId?: string | null
    auth_type: $Enums.AuthType
    billSchedules?: BillScheduleUncheckedCreateNestedManyWithoutMerchantInput
  }

  export type MerchantCreateOrConnectWithoutPaymentsInput = {
    where: MerchantWhereUniqueInput
    create: XOR<MerchantCreateWithoutPaymentsInput, MerchantUncheckedCreateWithoutPaymentsInput>
  }

  export type UserCreateWithoutMerchantPaymentsInput = {
    email?: string | null
    name?: string | null
    number: string
    password: string
    sessionToken?: string | null
    image?: string | null
    userpin: string
    resetOtp?: string | null
    resetExpires?: Date | string | null
    OnRampTransaction?: OnRampTransactionCreateNestedManyWithoutUserInput
    Balance?: BalanceCreateNestedManyWithoutUserInput
    sentTransfers?: p2pTransferCreateNestedManyWithoutFromUserInput
    receivedTransfers?: p2pTransferCreateNestedManyWithoutToUserInput
    sentRequests?: P2PRequestCreateNestedManyWithoutSenderInput
    receivedRequests?: P2PRequestCreateNestedManyWithoutReceiverInput
    billSchedules?: BillScheduleCreateNestedManyWithoutUserInput
    rechargeOrders?: RechargeOrderCreateNestedManyWithoutUserInput
    rewards?: RewardCreateNestedManyWithoutUserInput
    referralsAsReferrer?: ReferralCreateNestedManyWithoutReferrerInput
    referralsAsReferred?: ReferralCreateNestedManyWithoutReferredInput
    wrongSendRequests?: WrongSendRequestCreateNestedManyWithoutSenderInput
    createdGroups?: BillSplitGroupCreateNestedManyWithoutCreatedByInput
    billSplitMembers?: BillSplitMemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMerchantPaymentsInput = {
    id?: number
    email?: string | null
    name?: string | null
    number: string
    password: string
    sessionToken?: string | null
    image?: string | null
    userpin: string
    resetOtp?: string | null
    resetExpires?: Date | string | null
    OnRampTransaction?: OnRampTransactionUncheckedCreateNestedManyWithoutUserInput
    Balance?: BalanceUncheckedCreateNestedManyWithoutUserInput
    sentTransfers?: p2pTransferUncheckedCreateNestedManyWithoutFromUserInput
    receivedTransfers?: p2pTransferUncheckedCreateNestedManyWithoutToUserInput
    sentRequests?: P2PRequestUncheckedCreateNestedManyWithoutSenderInput
    receivedRequests?: P2PRequestUncheckedCreateNestedManyWithoutReceiverInput
    billSchedules?: BillScheduleUncheckedCreateNestedManyWithoutUserInput
    rechargeOrders?: RechargeOrderUncheckedCreateNestedManyWithoutUserInput
    rewards?: RewardUncheckedCreateNestedManyWithoutUserInput
    referralsAsReferrer?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referralsAsReferred?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    wrongSendRequests?: WrongSendRequestUncheckedCreateNestedManyWithoutSenderInput
    createdGroups?: BillSplitGroupUncheckedCreateNestedManyWithoutCreatedByInput
    billSplitMembers?: BillSplitMemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMerchantPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMerchantPaymentsInput, UserUncheckedCreateWithoutMerchantPaymentsInput>
  }

  export type MerchantUpsertWithoutPaymentsInput = {
    update: XOR<MerchantUpdateWithoutPaymentsInput, MerchantUncheckedUpdateWithoutPaymentsInput>
    create: XOR<MerchantCreateWithoutPaymentsInput, MerchantUncheckedCreateWithoutPaymentsInput>
    where?: MerchantWhereInput
  }

  export type MerchantUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: MerchantWhereInput
    data: XOR<MerchantUpdateWithoutPaymentsInput, MerchantUncheckedUpdateWithoutPaymentsInput>
  }

  export type MerchantUpdateWithoutPaymentsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    auth_type?: EnumAuthTypeFieldUpdateOperationsInput | $Enums.AuthType
    billSchedules?: BillScheduleUpdateManyWithoutMerchantNestedInput
  }

  export type MerchantUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    auth_type?: EnumAuthTypeFieldUpdateOperationsInput | $Enums.AuthType
    billSchedules?: BillScheduleUncheckedUpdateManyWithoutMerchantNestedInput
  }

  export type UserUpsertWithoutMerchantPaymentsInput = {
    update: XOR<UserUpdateWithoutMerchantPaymentsInput, UserUncheckedUpdateWithoutMerchantPaymentsInput>
    create: XOR<UserCreateWithoutMerchantPaymentsInput, UserUncheckedCreateWithoutMerchantPaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMerchantPaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMerchantPaymentsInput, UserUncheckedUpdateWithoutMerchantPaymentsInput>
  }

  export type UserUpdateWithoutMerchantPaymentsInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    userpin?: StringFieldUpdateOperationsInput | string
    resetOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OnRampTransaction?: OnRampTransactionUpdateManyWithoutUserNestedInput
    Balance?: BalanceUpdateManyWithoutUserNestedInput
    sentTransfers?: p2pTransferUpdateManyWithoutFromUserNestedInput
    receivedTransfers?: p2pTransferUpdateManyWithoutToUserNestedInput
    sentRequests?: P2PRequestUpdateManyWithoutSenderNestedInput
    receivedRequests?: P2PRequestUpdateManyWithoutReceiverNestedInput
    billSchedules?: BillScheduleUpdateManyWithoutUserNestedInput
    rechargeOrders?: RechargeOrderUpdateManyWithoutUserNestedInput
    rewards?: RewardUpdateManyWithoutUserNestedInput
    referralsAsReferrer?: ReferralUpdateManyWithoutReferrerNestedInput
    referralsAsReferred?: ReferralUpdateManyWithoutReferredNestedInput
    wrongSendRequests?: WrongSendRequestUpdateManyWithoutSenderNestedInput
    createdGroups?: BillSplitGroupUpdateManyWithoutCreatedByNestedInput
    billSplitMembers?: BillSplitMemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMerchantPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    userpin?: StringFieldUpdateOperationsInput | string
    resetOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OnRampTransaction?: OnRampTransactionUncheckedUpdateManyWithoutUserNestedInput
    Balance?: BalanceUncheckedUpdateManyWithoutUserNestedInput
    sentTransfers?: p2pTransferUncheckedUpdateManyWithoutFromUserNestedInput
    receivedTransfers?: p2pTransferUncheckedUpdateManyWithoutToUserNestedInput
    sentRequests?: P2PRequestUncheckedUpdateManyWithoutSenderNestedInput
    receivedRequests?: P2PRequestUncheckedUpdateManyWithoutReceiverNestedInput
    billSchedules?: BillScheduleUncheckedUpdateManyWithoutUserNestedInput
    rechargeOrders?: RechargeOrderUncheckedUpdateManyWithoutUserNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutUserNestedInput
    referralsAsReferrer?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referralsAsReferred?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    wrongSendRequests?: WrongSendRequestUncheckedUpdateManyWithoutSenderNestedInput
    createdGroups?: BillSplitGroupUncheckedUpdateManyWithoutCreatedByNestedInput
    billSplitMembers?: BillSplitMemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutOnRampTransactionInput = {
    email?: string | null
    name?: string | null
    number: string
    password: string
    sessionToken?: string | null
    image?: string | null
    userpin: string
    resetOtp?: string | null
    resetExpires?: Date | string | null
    Balance?: BalanceCreateNestedManyWithoutUserInput
    sentTransfers?: p2pTransferCreateNestedManyWithoutFromUserInput
    receivedTransfers?: p2pTransferCreateNestedManyWithoutToUserInput
    sentRequests?: P2PRequestCreateNestedManyWithoutSenderInput
    receivedRequests?: P2PRequestCreateNestedManyWithoutReceiverInput
    billSchedules?: BillScheduleCreateNestedManyWithoutUserInput
    merchantPayments?: MerchantPaymentCreateNestedManyWithoutUserInput
    rechargeOrders?: RechargeOrderCreateNestedManyWithoutUserInput
    rewards?: RewardCreateNestedManyWithoutUserInput
    referralsAsReferrer?: ReferralCreateNestedManyWithoutReferrerInput
    referralsAsReferred?: ReferralCreateNestedManyWithoutReferredInput
    wrongSendRequests?: WrongSendRequestCreateNestedManyWithoutSenderInput
    createdGroups?: BillSplitGroupCreateNestedManyWithoutCreatedByInput
    billSplitMembers?: BillSplitMemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOnRampTransactionInput = {
    id?: number
    email?: string | null
    name?: string | null
    number: string
    password: string
    sessionToken?: string | null
    image?: string | null
    userpin: string
    resetOtp?: string | null
    resetExpires?: Date | string | null
    Balance?: BalanceUncheckedCreateNestedManyWithoutUserInput
    sentTransfers?: p2pTransferUncheckedCreateNestedManyWithoutFromUserInput
    receivedTransfers?: p2pTransferUncheckedCreateNestedManyWithoutToUserInput
    sentRequests?: P2PRequestUncheckedCreateNestedManyWithoutSenderInput
    receivedRequests?: P2PRequestUncheckedCreateNestedManyWithoutReceiverInput
    billSchedules?: BillScheduleUncheckedCreateNestedManyWithoutUserInput
    merchantPayments?: MerchantPaymentUncheckedCreateNestedManyWithoutUserInput
    rechargeOrders?: RechargeOrderUncheckedCreateNestedManyWithoutUserInput
    rewards?: RewardUncheckedCreateNestedManyWithoutUserInput
    referralsAsReferrer?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referralsAsReferred?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    wrongSendRequests?: WrongSendRequestUncheckedCreateNestedManyWithoutSenderInput
    createdGroups?: BillSplitGroupUncheckedCreateNestedManyWithoutCreatedByInput
    billSplitMembers?: BillSplitMemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOnRampTransactionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOnRampTransactionInput, UserUncheckedCreateWithoutOnRampTransactionInput>
  }

  export type UserUpsertWithoutOnRampTransactionInput = {
    update: XOR<UserUpdateWithoutOnRampTransactionInput, UserUncheckedUpdateWithoutOnRampTransactionInput>
    create: XOR<UserCreateWithoutOnRampTransactionInput, UserUncheckedCreateWithoutOnRampTransactionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOnRampTransactionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOnRampTransactionInput, UserUncheckedUpdateWithoutOnRampTransactionInput>
  }

  export type UserUpdateWithoutOnRampTransactionInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    userpin?: StringFieldUpdateOperationsInput | string
    resetOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Balance?: BalanceUpdateManyWithoutUserNestedInput
    sentTransfers?: p2pTransferUpdateManyWithoutFromUserNestedInput
    receivedTransfers?: p2pTransferUpdateManyWithoutToUserNestedInput
    sentRequests?: P2PRequestUpdateManyWithoutSenderNestedInput
    receivedRequests?: P2PRequestUpdateManyWithoutReceiverNestedInput
    billSchedules?: BillScheduleUpdateManyWithoutUserNestedInput
    merchantPayments?: MerchantPaymentUpdateManyWithoutUserNestedInput
    rechargeOrders?: RechargeOrderUpdateManyWithoutUserNestedInput
    rewards?: RewardUpdateManyWithoutUserNestedInput
    referralsAsReferrer?: ReferralUpdateManyWithoutReferrerNestedInput
    referralsAsReferred?: ReferralUpdateManyWithoutReferredNestedInput
    wrongSendRequests?: WrongSendRequestUpdateManyWithoutSenderNestedInput
    createdGroups?: BillSplitGroupUpdateManyWithoutCreatedByNestedInput
    billSplitMembers?: BillSplitMemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOnRampTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    userpin?: StringFieldUpdateOperationsInput | string
    resetOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Balance?: BalanceUncheckedUpdateManyWithoutUserNestedInput
    sentTransfers?: p2pTransferUncheckedUpdateManyWithoutFromUserNestedInput
    receivedTransfers?: p2pTransferUncheckedUpdateManyWithoutToUserNestedInput
    sentRequests?: P2PRequestUncheckedUpdateManyWithoutSenderNestedInput
    receivedRequests?: P2PRequestUncheckedUpdateManyWithoutReceiverNestedInput
    billSchedules?: BillScheduleUncheckedUpdateManyWithoutUserNestedInput
    merchantPayments?: MerchantPaymentUncheckedUpdateManyWithoutUserNestedInput
    rechargeOrders?: RechargeOrderUncheckedUpdateManyWithoutUserNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutUserNestedInput
    referralsAsReferrer?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referralsAsReferred?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    wrongSendRequests?: WrongSendRequestUncheckedUpdateManyWithoutSenderNestedInput
    createdGroups?: BillSplitGroupUncheckedUpdateManyWithoutCreatedByNestedInput
    billSplitMembers?: BillSplitMemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSentRequestsInput = {
    email?: string | null
    name?: string | null
    number: string
    password: string
    sessionToken?: string | null
    image?: string | null
    userpin: string
    resetOtp?: string | null
    resetExpires?: Date | string | null
    OnRampTransaction?: OnRampTransactionCreateNestedManyWithoutUserInput
    Balance?: BalanceCreateNestedManyWithoutUserInput
    sentTransfers?: p2pTransferCreateNestedManyWithoutFromUserInput
    receivedTransfers?: p2pTransferCreateNestedManyWithoutToUserInput
    receivedRequests?: P2PRequestCreateNestedManyWithoutReceiverInput
    billSchedules?: BillScheduleCreateNestedManyWithoutUserInput
    merchantPayments?: MerchantPaymentCreateNestedManyWithoutUserInput
    rechargeOrders?: RechargeOrderCreateNestedManyWithoutUserInput
    rewards?: RewardCreateNestedManyWithoutUserInput
    referralsAsReferrer?: ReferralCreateNestedManyWithoutReferrerInput
    referralsAsReferred?: ReferralCreateNestedManyWithoutReferredInput
    wrongSendRequests?: WrongSendRequestCreateNestedManyWithoutSenderInput
    createdGroups?: BillSplitGroupCreateNestedManyWithoutCreatedByInput
    billSplitMembers?: BillSplitMemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSentRequestsInput = {
    id?: number
    email?: string | null
    name?: string | null
    number: string
    password: string
    sessionToken?: string | null
    image?: string | null
    userpin: string
    resetOtp?: string | null
    resetExpires?: Date | string | null
    OnRampTransaction?: OnRampTransactionUncheckedCreateNestedManyWithoutUserInput
    Balance?: BalanceUncheckedCreateNestedManyWithoutUserInput
    sentTransfers?: p2pTransferUncheckedCreateNestedManyWithoutFromUserInput
    receivedTransfers?: p2pTransferUncheckedCreateNestedManyWithoutToUserInput
    receivedRequests?: P2PRequestUncheckedCreateNestedManyWithoutReceiverInput
    billSchedules?: BillScheduleUncheckedCreateNestedManyWithoutUserInput
    merchantPayments?: MerchantPaymentUncheckedCreateNestedManyWithoutUserInput
    rechargeOrders?: RechargeOrderUncheckedCreateNestedManyWithoutUserInput
    rewards?: RewardUncheckedCreateNestedManyWithoutUserInput
    referralsAsReferrer?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referralsAsReferred?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    wrongSendRequests?: WrongSendRequestUncheckedCreateNestedManyWithoutSenderInput
    createdGroups?: BillSplitGroupUncheckedCreateNestedManyWithoutCreatedByInput
    billSplitMembers?: BillSplitMemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSentRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentRequestsInput, UserUncheckedCreateWithoutSentRequestsInput>
  }

  export type UserCreateWithoutReceivedRequestsInput = {
    email?: string | null
    name?: string | null
    number: string
    password: string
    sessionToken?: string | null
    image?: string | null
    userpin: string
    resetOtp?: string | null
    resetExpires?: Date | string | null
    OnRampTransaction?: OnRampTransactionCreateNestedManyWithoutUserInput
    Balance?: BalanceCreateNestedManyWithoutUserInput
    sentTransfers?: p2pTransferCreateNestedManyWithoutFromUserInput
    receivedTransfers?: p2pTransferCreateNestedManyWithoutToUserInput
    sentRequests?: P2PRequestCreateNestedManyWithoutSenderInput
    billSchedules?: BillScheduleCreateNestedManyWithoutUserInput
    merchantPayments?: MerchantPaymentCreateNestedManyWithoutUserInput
    rechargeOrders?: RechargeOrderCreateNestedManyWithoutUserInput
    rewards?: RewardCreateNestedManyWithoutUserInput
    referralsAsReferrer?: ReferralCreateNestedManyWithoutReferrerInput
    referralsAsReferred?: ReferralCreateNestedManyWithoutReferredInput
    wrongSendRequests?: WrongSendRequestCreateNestedManyWithoutSenderInput
    createdGroups?: BillSplitGroupCreateNestedManyWithoutCreatedByInput
    billSplitMembers?: BillSplitMemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReceivedRequestsInput = {
    id?: number
    email?: string | null
    name?: string | null
    number: string
    password: string
    sessionToken?: string | null
    image?: string | null
    userpin: string
    resetOtp?: string | null
    resetExpires?: Date | string | null
    OnRampTransaction?: OnRampTransactionUncheckedCreateNestedManyWithoutUserInput
    Balance?: BalanceUncheckedCreateNestedManyWithoutUserInput
    sentTransfers?: p2pTransferUncheckedCreateNestedManyWithoutFromUserInput
    receivedTransfers?: p2pTransferUncheckedCreateNestedManyWithoutToUserInput
    sentRequests?: P2PRequestUncheckedCreateNestedManyWithoutSenderInput
    billSchedules?: BillScheduleUncheckedCreateNestedManyWithoutUserInput
    merchantPayments?: MerchantPaymentUncheckedCreateNestedManyWithoutUserInput
    rechargeOrders?: RechargeOrderUncheckedCreateNestedManyWithoutUserInput
    rewards?: RewardUncheckedCreateNestedManyWithoutUserInput
    referralsAsReferrer?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referralsAsReferred?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    wrongSendRequests?: WrongSendRequestUncheckedCreateNestedManyWithoutSenderInput
    createdGroups?: BillSplitGroupUncheckedCreateNestedManyWithoutCreatedByInput
    billSplitMembers?: BillSplitMemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReceivedRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedRequestsInput, UserUncheckedCreateWithoutReceivedRequestsInput>
  }

  export type BillSplitMemberCreateWithoutRequestInput = {
    phone?: string | null
    name: string
    share: number
    paid?: boolean
    paidAt?: Date | string | null
    paidAmount?: number
    group: BillSplitGroupCreateNestedOneWithoutMembersInput
    user?: UserCreateNestedOneWithoutBillSplitMembersInput
    payments?: BillSplitPaymentCreateNestedManyWithoutMemberInput
  }

  export type BillSplitMemberUncheckedCreateWithoutRequestInput = {
    id?: number
    groupId: number
    userId?: number | null
    phone?: string | null
    name: string
    share: number
    paid?: boolean
    paidAt?: Date | string | null
    paidAmount?: number
    payments?: BillSplitPaymentUncheckedCreateNestedManyWithoutMemberInput
  }

  export type BillSplitMemberCreateOrConnectWithoutRequestInput = {
    where: BillSplitMemberWhereUniqueInput
    create: XOR<BillSplitMemberCreateWithoutRequestInput, BillSplitMemberUncheckedCreateWithoutRequestInput>
  }

  export type UserUpsertWithoutSentRequestsInput = {
    update: XOR<UserUpdateWithoutSentRequestsInput, UserUncheckedUpdateWithoutSentRequestsInput>
    create: XOR<UserCreateWithoutSentRequestsInput, UserUncheckedCreateWithoutSentRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentRequestsInput, UserUncheckedUpdateWithoutSentRequestsInput>
  }

  export type UserUpdateWithoutSentRequestsInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    userpin?: StringFieldUpdateOperationsInput | string
    resetOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OnRampTransaction?: OnRampTransactionUpdateManyWithoutUserNestedInput
    Balance?: BalanceUpdateManyWithoutUserNestedInput
    sentTransfers?: p2pTransferUpdateManyWithoutFromUserNestedInput
    receivedTransfers?: p2pTransferUpdateManyWithoutToUserNestedInput
    receivedRequests?: P2PRequestUpdateManyWithoutReceiverNestedInput
    billSchedules?: BillScheduleUpdateManyWithoutUserNestedInput
    merchantPayments?: MerchantPaymentUpdateManyWithoutUserNestedInput
    rechargeOrders?: RechargeOrderUpdateManyWithoutUserNestedInput
    rewards?: RewardUpdateManyWithoutUserNestedInput
    referralsAsReferrer?: ReferralUpdateManyWithoutReferrerNestedInput
    referralsAsReferred?: ReferralUpdateManyWithoutReferredNestedInput
    wrongSendRequests?: WrongSendRequestUpdateManyWithoutSenderNestedInput
    createdGroups?: BillSplitGroupUpdateManyWithoutCreatedByNestedInput
    billSplitMembers?: BillSplitMemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSentRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    userpin?: StringFieldUpdateOperationsInput | string
    resetOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OnRampTransaction?: OnRampTransactionUncheckedUpdateManyWithoutUserNestedInput
    Balance?: BalanceUncheckedUpdateManyWithoutUserNestedInput
    sentTransfers?: p2pTransferUncheckedUpdateManyWithoutFromUserNestedInput
    receivedTransfers?: p2pTransferUncheckedUpdateManyWithoutToUserNestedInput
    receivedRequests?: P2PRequestUncheckedUpdateManyWithoutReceiverNestedInput
    billSchedules?: BillScheduleUncheckedUpdateManyWithoutUserNestedInput
    merchantPayments?: MerchantPaymentUncheckedUpdateManyWithoutUserNestedInput
    rechargeOrders?: RechargeOrderUncheckedUpdateManyWithoutUserNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutUserNestedInput
    referralsAsReferrer?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referralsAsReferred?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    wrongSendRequests?: WrongSendRequestUncheckedUpdateManyWithoutSenderNestedInput
    createdGroups?: BillSplitGroupUncheckedUpdateManyWithoutCreatedByNestedInput
    billSplitMembers?: BillSplitMemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutReceivedRequestsInput = {
    update: XOR<UserUpdateWithoutReceivedRequestsInput, UserUncheckedUpdateWithoutReceivedRequestsInput>
    create: XOR<UserCreateWithoutReceivedRequestsInput, UserUncheckedCreateWithoutReceivedRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedRequestsInput, UserUncheckedUpdateWithoutReceivedRequestsInput>
  }

  export type UserUpdateWithoutReceivedRequestsInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    userpin?: StringFieldUpdateOperationsInput | string
    resetOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OnRampTransaction?: OnRampTransactionUpdateManyWithoutUserNestedInput
    Balance?: BalanceUpdateManyWithoutUserNestedInput
    sentTransfers?: p2pTransferUpdateManyWithoutFromUserNestedInput
    receivedTransfers?: p2pTransferUpdateManyWithoutToUserNestedInput
    sentRequests?: P2PRequestUpdateManyWithoutSenderNestedInput
    billSchedules?: BillScheduleUpdateManyWithoutUserNestedInput
    merchantPayments?: MerchantPaymentUpdateManyWithoutUserNestedInput
    rechargeOrders?: RechargeOrderUpdateManyWithoutUserNestedInput
    rewards?: RewardUpdateManyWithoutUserNestedInput
    referralsAsReferrer?: ReferralUpdateManyWithoutReferrerNestedInput
    referralsAsReferred?: ReferralUpdateManyWithoutReferredNestedInput
    wrongSendRequests?: WrongSendRequestUpdateManyWithoutSenderNestedInput
    createdGroups?: BillSplitGroupUpdateManyWithoutCreatedByNestedInput
    billSplitMembers?: BillSplitMemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    userpin?: StringFieldUpdateOperationsInput | string
    resetOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OnRampTransaction?: OnRampTransactionUncheckedUpdateManyWithoutUserNestedInput
    Balance?: BalanceUncheckedUpdateManyWithoutUserNestedInput
    sentTransfers?: p2pTransferUncheckedUpdateManyWithoutFromUserNestedInput
    receivedTransfers?: p2pTransferUncheckedUpdateManyWithoutToUserNestedInput
    sentRequests?: P2PRequestUncheckedUpdateManyWithoutSenderNestedInput
    billSchedules?: BillScheduleUncheckedUpdateManyWithoutUserNestedInput
    merchantPayments?: MerchantPaymentUncheckedUpdateManyWithoutUserNestedInput
    rechargeOrders?: RechargeOrderUncheckedUpdateManyWithoutUserNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutUserNestedInput
    referralsAsReferrer?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referralsAsReferred?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    wrongSendRequests?: WrongSendRequestUncheckedUpdateManyWithoutSenderNestedInput
    createdGroups?: BillSplitGroupUncheckedUpdateManyWithoutCreatedByNestedInput
    billSplitMembers?: BillSplitMemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BillSplitMemberUpsertWithoutRequestInput = {
    update: XOR<BillSplitMemberUpdateWithoutRequestInput, BillSplitMemberUncheckedUpdateWithoutRequestInput>
    create: XOR<BillSplitMemberCreateWithoutRequestInput, BillSplitMemberUncheckedCreateWithoutRequestInput>
    where?: BillSplitMemberWhereInput
  }

  export type BillSplitMemberUpdateToOneWithWhereWithoutRequestInput = {
    where?: BillSplitMemberWhereInput
    data: XOR<BillSplitMemberUpdateWithoutRequestInput, BillSplitMemberUncheckedUpdateWithoutRequestInput>
  }

  export type BillSplitMemberUpdateWithoutRequestInput = {
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    share?: IntFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAmount?: IntFieldUpdateOperationsInput | number
    group?: BillSplitGroupUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneWithoutBillSplitMembersNestedInput
    payments?: BillSplitPaymentUpdateManyWithoutMemberNestedInput
  }

  export type BillSplitMemberUncheckedUpdateWithoutRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    share?: IntFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAmount?: IntFieldUpdateOperationsInput | number
    payments?: BillSplitPaymentUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type UserCreateWithoutBillSchedulesInput = {
    email?: string | null
    name?: string | null
    number: string
    password: string
    sessionToken?: string | null
    image?: string | null
    userpin: string
    resetOtp?: string | null
    resetExpires?: Date | string | null
    OnRampTransaction?: OnRampTransactionCreateNestedManyWithoutUserInput
    Balance?: BalanceCreateNestedManyWithoutUserInput
    sentTransfers?: p2pTransferCreateNestedManyWithoutFromUserInput
    receivedTransfers?: p2pTransferCreateNestedManyWithoutToUserInput
    sentRequests?: P2PRequestCreateNestedManyWithoutSenderInput
    receivedRequests?: P2PRequestCreateNestedManyWithoutReceiverInput
    merchantPayments?: MerchantPaymentCreateNestedManyWithoutUserInput
    rechargeOrders?: RechargeOrderCreateNestedManyWithoutUserInput
    rewards?: RewardCreateNestedManyWithoutUserInput
    referralsAsReferrer?: ReferralCreateNestedManyWithoutReferrerInput
    referralsAsReferred?: ReferralCreateNestedManyWithoutReferredInput
    wrongSendRequests?: WrongSendRequestCreateNestedManyWithoutSenderInput
    createdGroups?: BillSplitGroupCreateNestedManyWithoutCreatedByInput
    billSplitMembers?: BillSplitMemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBillSchedulesInput = {
    id?: number
    email?: string | null
    name?: string | null
    number: string
    password: string
    sessionToken?: string | null
    image?: string | null
    userpin: string
    resetOtp?: string | null
    resetExpires?: Date | string | null
    OnRampTransaction?: OnRampTransactionUncheckedCreateNestedManyWithoutUserInput
    Balance?: BalanceUncheckedCreateNestedManyWithoutUserInput
    sentTransfers?: p2pTransferUncheckedCreateNestedManyWithoutFromUserInput
    receivedTransfers?: p2pTransferUncheckedCreateNestedManyWithoutToUserInput
    sentRequests?: P2PRequestUncheckedCreateNestedManyWithoutSenderInput
    receivedRequests?: P2PRequestUncheckedCreateNestedManyWithoutReceiverInput
    merchantPayments?: MerchantPaymentUncheckedCreateNestedManyWithoutUserInput
    rechargeOrders?: RechargeOrderUncheckedCreateNestedManyWithoutUserInput
    rewards?: RewardUncheckedCreateNestedManyWithoutUserInput
    referralsAsReferrer?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referralsAsReferred?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    wrongSendRequests?: WrongSendRequestUncheckedCreateNestedManyWithoutSenderInput
    createdGroups?: BillSplitGroupUncheckedCreateNestedManyWithoutCreatedByInput
    billSplitMembers?: BillSplitMemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBillSchedulesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBillSchedulesInput, UserUncheckedCreateWithoutBillSchedulesInput>
  }

  export type MerchantCreateWithoutBillSchedulesInput = {
    email: string
    name?: string | null
    upiId?: string | null
    auth_type: $Enums.AuthType
    payments?: MerchantPaymentCreateNestedManyWithoutMerchantInput
  }

  export type MerchantUncheckedCreateWithoutBillSchedulesInput = {
    id?: number
    email: string
    name?: string | null
    upiId?: string | null
    auth_type: $Enums.AuthType
    payments?: MerchantPaymentUncheckedCreateNestedManyWithoutMerchantInput
  }

  export type MerchantCreateOrConnectWithoutBillSchedulesInput = {
    where: MerchantWhereUniqueInput
    create: XOR<MerchantCreateWithoutBillSchedulesInput, MerchantUncheckedCreateWithoutBillSchedulesInput>
  }

  export type UserUpsertWithoutBillSchedulesInput = {
    update: XOR<UserUpdateWithoutBillSchedulesInput, UserUncheckedUpdateWithoutBillSchedulesInput>
    create: XOR<UserCreateWithoutBillSchedulesInput, UserUncheckedCreateWithoutBillSchedulesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBillSchedulesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBillSchedulesInput, UserUncheckedUpdateWithoutBillSchedulesInput>
  }

  export type UserUpdateWithoutBillSchedulesInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    userpin?: StringFieldUpdateOperationsInput | string
    resetOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OnRampTransaction?: OnRampTransactionUpdateManyWithoutUserNestedInput
    Balance?: BalanceUpdateManyWithoutUserNestedInput
    sentTransfers?: p2pTransferUpdateManyWithoutFromUserNestedInput
    receivedTransfers?: p2pTransferUpdateManyWithoutToUserNestedInput
    sentRequests?: P2PRequestUpdateManyWithoutSenderNestedInput
    receivedRequests?: P2PRequestUpdateManyWithoutReceiverNestedInput
    merchantPayments?: MerchantPaymentUpdateManyWithoutUserNestedInput
    rechargeOrders?: RechargeOrderUpdateManyWithoutUserNestedInput
    rewards?: RewardUpdateManyWithoutUserNestedInput
    referralsAsReferrer?: ReferralUpdateManyWithoutReferrerNestedInput
    referralsAsReferred?: ReferralUpdateManyWithoutReferredNestedInput
    wrongSendRequests?: WrongSendRequestUpdateManyWithoutSenderNestedInput
    createdGroups?: BillSplitGroupUpdateManyWithoutCreatedByNestedInput
    billSplitMembers?: BillSplitMemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBillSchedulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    userpin?: StringFieldUpdateOperationsInput | string
    resetOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OnRampTransaction?: OnRampTransactionUncheckedUpdateManyWithoutUserNestedInput
    Balance?: BalanceUncheckedUpdateManyWithoutUserNestedInput
    sentTransfers?: p2pTransferUncheckedUpdateManyWithoutFromUserNestedInput
    receivedTransfers?: p2pTransferUncheckedUpdateManyWithoutToUserNestedInput
    sentRequests?: P2PRequestUncheckedUpdateManyWithoutSenderNestedInput
    receivedRequests?: P2PRequestUncheckedUpdateManyWithoutReceiverNestedInput
    merchantPayments?: MerchantPaymentUncheckedUpdateManyWithoutUserNestedInput
    rechargeOrders?: RechargeOrderUncheckedUpdateManyWithoutUserNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutUserNestedInput
    referralsAsReferrer?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referralsAsReferred?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    wrongSendRequests?: WrongSendRequestUncheckedUpdateManyWithoutSenderNestedInput
    createdGroups?: BillSplitGroupUncheckedUpdateManyWithoutCreatedByNestedInput
    billSplitMembers?: BillSplitMemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MerchantUpsertWithoutBillSchedulesInput = {
    update: XOR<MerchantUpdateWithoutBillSchedulesInput, MerchantUncheckedUpdateWithoutBillSchedulesInput>
    create: XOR<MerchantCreateWithoutBillSchedulesInput, MerchantUncheckedCreateWithoutBillSchedulesInput>
    where?: MerchantWhereInput
  }

  export type MerchantUpdateToOneWithWhereWithoutBillSchedulesInput = {
    where?: MerchantWhereInput
    data: XOR<MerchantUpdateWithoutBillSchedulesInput, MerchantUncheckedUpdateWithoutBillSchedulesInput>
  }

  export type MerchantUpdateWithoutBillSchedulesInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    auth_type?: EnumAuthTypeFieldUpdateOperationsInput | $Enums.AuthType
    payments?: MerchantPaymentUpdateManyWithoutMerchantNestedInput
  }

  export type MerchantUncheckedUpdateWithoutBillSchedulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    auth_type?: EnumAuthTypeFieldUpdateOperationsInput | $Enums.AuthType
    payments?: MerchantPaymentUncheckedUpdateManyWithoutMerchantNestedInput
  }

  export type RechargeOrderCreateWithoutPlanInput = {
    mobileNumber: string
    operator: string
    circle: string
    amount: number
    status?: string
    providerTxnId?: string | null
    orderId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRechargeOrdersInput
  }

  export type RechargeOrderUncheckedCreateWithoutPlanInput = {
    id?: number
    userId: number
    mobileNumber: string
    operator: string
    circle: string
    amount: number
    status?: string
    providerTxnId?: string | null
    orderId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RechargeOrderCreateOrConnectWithoutPlanInput = {
    where: RechargeOrderWhereUniqueInput
    create: XOR<RechargeOrderCreateWithoutPlanInput, RechargeOrderUncheckedCreateWithoutPlanInput>
  }

  export type RechargeOrderCreateManyPlanInputEnvelope = {
    data: RechargeOrderCreateManyPlanInput | RechargeOrderCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type RechargeOrderUpsertWithWhereUniqueWithoutPlanInput = {
    where: RechargeOrderWhereUniqueInput
    update: XOR<RechargeOrderUpdateWithoutPlanInput, RechargeOrderUncheckedUpdateWithoutPlanInput>
    create: XOR<RechargeOrderCreateWithoutPlanInput, RechargeOrderUncheckedCreateWithoutPlanInput>
  }

  export type RechargeOrderUpdateWithWhereUniqueWithoutPlanInput = {
    where: RechargeOrderWhereUniqueInput
    data: XOR<RechargeOrderUpdateWithoutPlanInput, RechargeOrderUncheckedUpdateWithoutPlanInput>
  }

  export type RechargeOrderUpdateManyWithWhereWithoutPlanInput = {
    where: RechargeOrderScalarWhereInput
    data: XOR<RechargeOrderUpdateManyMutationInput, RechargeOrderUncheckedUpdateManyWithoutPlanInput>
  }

  export type UserCreateWithoutRechargeOrdersInput = {
    email?: string | null
    name?: string | null
    number: string
    password: string
    sessionToken?: string | null
    image?: string | null
    userpin: string
    resetOtp?: string | null
    resetExpires?: Date | string | null
    OnRampTransaction?: OnRampTransactionCreateNestedManyWithoutUserInput
    Balance?: BalanceCreateNestedManyWithoutUserInput
    sentTransfers?: p2pTransferCreateNestedManyWithoutFromUserInput
    receivedTransfers?: p2pTransferCreateNestedManyWithoutToUserInput
    sentRequests?: P2PRequestCreateNestedManyWithoutSenderInput
    receivedRequests?: P2PRequestCreateNestedManyWithoutReceiverInput
    billSchedules?: BillScheduleCreateNestedManyWithoutUserInput
    merchantPayments?: MerchantPaymentCreateNestedManyWithoutUserInput
    rewards?: RewardCreateNestedManyWithoutUserInput
    referralsAsReferrer?: ReferralCreateNestedManyWithoutReferrerInput
    referralsAsReferred?: ReferralCreateNestedManyWithoutReferredInput
    wrongSendRequests?: WrongSendRequestCreateNestedManyWithoutSenderInput
    createdGroups?: BillSplitGroupCreateNestedManyWithoutCreatedByInput
    billSplitMembers?: BillSplitMemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRechargeOrdersInput = {
    id?: number
    email?: string | null
    name?: string | null
    number: string
    password: string
    sessionToken?: string | null
    image?: string | null
    userpin: string
    resetOtp?: string | null
    resetExpires?: Date | string | null
    OnRampTransaction?: OnRampTransactionUncheckedCreateNestedManyWithoutUserInput
    Balance?: BalanceUncheckedCreateNestedManyWithoutUserInput
    sentTransfers?: p2pTransferUncheckedCreateNestedManyWithoutFromUserInput
    receivedTransfers?: p2pTransferUncheckedCreateNestedManyWithoutToUserInput
    sentRequests?: P2PRequestUncheckedCreateNestedManyWithoutSenderInput
    receivedRequests?: P2PRequestUncheckedCreateNestedManyWithoutReceiverInput
    billSchedules?: BillScheduleUncheckedCreateNestedManyWithoutUserInput
    merchantPayments?: MerchantPaymentUncheckedCreateNestedManyWithoutUserInput
    rewards?: RewardUncheckedCreateNestedManyWithoutUserInput
    referralsAsReferrer?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referralsAsReferred?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    wrongSendRequests?: WrongSendRequestUncheckedCreateNestedManyWithoutSenderInput
    createdGroups?: BillSplitGroupUncheckedCreateNestedManyWithoutCreatedByInput
    billSplitMembers?: BillSplitMemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRechargeOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRechargeOrdersInput, UserUncheckedCreateWithoutRechargeOrdersInput>
  }

  export type RechargePlanCreateWithoutRechargeOrdersInput = {
    operator: string
    circle: string
    planCode: string
    amount: number
    planType: string
    validity?: string | null
    data?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RechargePlanUncheckedCreateWithoutRechargeOrdersInput = {
    id?: number
    operator: string
    circle: string
    planCode: string
    amount: number
    planType: string
    validity?: string | null
    data?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RechargePlanCreateOrConnectWithoutRechargeOrdersInput = {
    where: RechargePlanWhereUniqueInput
    create: XOR<RechargePlanCreateWithoutRechargeOrdersInput, RechargePlanUncheckedCreateWithoutRechargeOrdersInput>
  }

  export type UserUpsertWithoutRechargeOrdersInput = {
    update: XOR<UserUpdateWithoutRechargeOrdersInput, UserUncheckedUpdateWithoutRechargeOrdersInput>
    create: XOR<UserCreateWithoutRechargeOrdersInput, UserUncheckedCreateWithoutRechargeOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRechargeOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRechargeOrdersInput, UserUncheckedUpdateWithoutRechargeOrdersInput>
  }

  export type UserUpdateWithoutRechargeOrdersInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    userpin?: StringFieldUpdateOperationsInput | string
    resetOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OnRampTransaction?: OnRampTransactionUpdateManyWithoutUserNestedInput
    Balance?: BalanceUpdateManyWithoutUserNestedInput
    sentTransfers?: p2pTransferUpdateManyWithoutFromUserNestedInput
    receivedTransfers?: p2pTransferUpdateManyWithoutToUserNestedInput
    sentRequests?: P2PRequestUpdateManyWithoutSenderNestedInput
    receivedRequests?: P2PRequestUpdateManyWithoutReceiverNestedInput
    billSchedules?: BillScheduleUpdateManyWithoutUserNestedInput
    merchantPayments?: MerchantPaymentUpdateManyWithoutUserNestedInput
    rewards?: RewardUpdateManyWithoutUserNestedInput
    referralsAsReferrer?: ReferralUpdateManyWithoutReferrerNestedInput
    referralsAsReferred?: ReferralUpdateManyWithoutReferredNestedInput
    wrongSendRequests?: WrongSendRequestUpdateManyWithoutSenderNestedInput
    createdGroups?: BillSplitGroupUpdateManyWithoutCreatedByNestedInput
    billSplitMembers?: BillSplitMemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRechargeOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    userpin?: StringFieldUpdateOperationsInput | string
    resetOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OnRampTransaction?: OnRampTransactionUncheckedUpdateManyWithoutUserNestedInput
    Balance?: BalanceUncheckedUpdateManyWithoutUserNestedInput
    sentTransfers?: p2pTransferUncheckedUpdateManyWithoutFromUserNestedInput
    receivedTransfers?: p2pTransferUncheckedUpdateManyWithoutToUserNestedInput
    sentRequests?: P2PRequestUncheckedUpdateManyWithoutSenderNestedInput
    receivedRequests?: P2PRequestUncheckedUpdateManyWithoutReceiverNestedInput
    billSchedules?: BillScheduleUncheckedUpdateManyWithoutUserNestedInput
    merchantPayments?: MerchantPaymentUncheckedUpdateManyWithoutUserNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutUserNestedInput
    referralsAsReferrer?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referralsAsReferred?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    wrongSendRequests?: WrongSendRequestUncheckedUpdateManyWithoutSenderNestedInput
    createdGroups?: BillSplitGroupUncheckedUpdateManyWithoutCreatedByNestedInput
    billSplitMembers?: BillSplitMemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RechargePlanUpsertWithoutRechargeOrdersInput = {
    update: XOR<RechargePlanUpdateWithoutRechargeOrdersInput, RechargePlanUncheckedUpdateWithoutRechargeOrdersInput>
    create: XOR<RechargePlanCreateWithoutRechargeOrdersInput, RechargePlanUncheckedCreateWithoutRechargeOrdersInput>
    where?: RechargePlanWhereInput
  }

  export type RechargePlanUpdateToOneWithWhereWithoutRechargeOrdersInput = {
    where?: RechargePlanWhereInput
    data: XOR<RechargePlanUpdateWithoutRechargeOrdersInput, RechargePlanUncheckedUpdateWithoutRechargeOrdersInput>
  }

  export type RechargePlanUpdateWithoutRechargeOrdersInput = {
    operator?: StringFieldUpdateOperationsInput | string
    circle?: StringFieldUpdateOperationsInput | string
    planCode?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    planType?: StringFieldUpdateOperationsInput | string
    validity?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RechargePlanUncheckedUpdateWithoutRechargeOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    operator?: StringFieldUpdateOperationsInput | string
    circle?: StringFieldUpdateOperationsInput | string
    planCode?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    planType?: StringFieldUpdateOperationsInput | string
    validity?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutRewardsInput = {
    email?: string | null
    name?: string | null
    number: string
    password: string
    sessionToken?: string | null
    image?: string | null
    userpin: string
    resetOtp?: string | null
    resetExpires?: Date | string | null
    OnRampTransaction?: OnRampTransactionCreateNestedManyWithoutUserInput
    Balance?: BalanceCreateNestedManyWithoutUserInput
    sentTransfers?: p2pTransferCreateNestedManyWithoutFromUserInput
    receivedTransfers?: p2pTransferCreateNestedManyWithoutToUserInput
    sentRequests?: P2PRequestCreateNestedManyWithoutSenderInput
    receivedRequests?: P2PRequestCreateNestedManyWithoutReceiverInput
    billSchedules?: BillScheduleCreateNestedManyWithoutUserInput
    merchantPayments?: MerchantPaymentCreateNestedManyWithoutUserInput
    rechargeOrders?: RechargeOrderCreateNestedManyWithoutUserInput
    referralsAsReferrer?: ReferralCreateNestedManyWithoutReferrerInput
    referralsAsReferred?: ReferralCreateNestedManyWithoutReferredInput
    wrongSendRequests?: WrongSendRequestCreateNestedManyWithoutSenderInput
    createdGroups?: BillSplitGroupCreateNestedManyWithoutCreatedByInput
    billSplitMembers?: BillSplitMemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRewardsInput = {
    id?: number
    email?: string | null
    name?: string | null
    number: string
    password: string
    sessionToken?: string | null
    image?: string | null
    userpin: string
    resetOtp?: string | null
    resetExpires?: Date | string | null
    OnRampTransaction?: OnRampTransactionUncheckedCreateNestedManyWithoutUserInput
    Balance?: BalanceUncheckedCreateNestedManyWithoutUserInput
    sentTransfers?: p2pTransferUncheckedCreateNestedManyWithoutFromUserInput
    receivedTransfers?: p2pTransferUncheckedCreateNestedManyWithoutToUserInput
    sentRequests?: P2PRequestUncheckedCreateNestedManyWithoutSenderInput
    receivedRequests?: P2PRequestUncheckedCreateNestedManyWithoutReceiverInput
    billSchedules?: BillScheduleUncheckedCreateNestedManyWithoutUserInput
    merchantPayments?: MerchantPaymentUncheckedCreateNestedManyWithoutUserInput
    rechargeOrders?: RechargeOrderUncheckedCreateNestedManyWithoutUserInput
    referralsAsReferrer?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referralsAsReferred?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    wrongSendRequests?: WrongSendRequestUncheckedCreateNestedManyWithoutSenderInput
    createdGroups?: BillSplitGroupUncheckedCreateNestedManyWithoutCreatedByInput
    billSplitMembers?: BillSplitMemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRewardsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRewardsInput, UserUncheckedCreateWithoutRewardsInput>
  }

  export type BillSplitGroupCreateWithoutRewardsInput = {
    name: string
    description?: string | null
    totalAmount: number
    currency?: string
    createdAt?: Date | string
    settledAt?: Date | string | null
    status?: string
    createdBy: UserCreateNestedOneWithoutCreatedGroupsInput
    members?: BillSplitMemberCreateNestedManyWithoutGroupInput
    payments?: BillSplitPaymentCreateNestedManyWithoutGroupInput
  }

  export type BillSplitGroupUncheckedCreateWithoutRewardsInput = {
    id?: number
    name: string
    description?: string | null
    totalAmount: number
    currency?: string
    createdById: number
    createdAt?: Date | string
    settledAt?: Date | string | null
    status?: string
    members?: BillSplitMemberUncheckedCreateNestedManyWithoutGroupInput
    payments?: BillSplitPaymentUncheckedCreateNestedManyWithoutGroupInput
  }

  export type BillSplitGroupCreateOrConnectWithoutRewardsInput = {
    where: BillSplitGroupWhereUniqueInput
    create: XOR<BillSplitGroupCreateWithoutRewardsInput, BillSplitGroupUncheckedCreateWithoutRewardsInput>
  }

  export type UserUpsertWithoutRewardsInput = {
    update: XOR<UserUpdateWithoutRewardsInput, UserUncheckedUpdateWithoutRewardsInput>
    create: XOR<UserCreateWithoutRewardsInput, UserUncheckedCreateWithoutRewardsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRewardsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRewardsInput, UserUncheckedUpdateWithoutRewardsInput>
  }

  export type UserUpdateWithoutRewardsInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    userpin?: StringFieldUpdateOperationsInput | string
    resetOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OnRampTransaction?: OnRampTransactionUpdateManyWithoutUserNestedInput
    Balance?: BalanceUpdateManyWithoutUserNestedInput
    sentTransfers?: p2pTransferUpdateManyWithoutFromUserNestedInput
    receivedTransfers?: p2pTransferUpdateManyWithoutToUserNestedInput
    sentRequests?: P2PRequestUpdateManyWithoutSenderNestedInput
    receivedRequests?: P2PRequestUpdateManyWithoutReceiverNestedInput
    billSchedules?: BillScheduleUpdateManyWithoutUserNestedInput
    merchantPayments?: MerchantPaymentUpdateManyWithoutUserNestedInput
    rechargeOrders?: RechargeOrderUpdateManyWithoutUserNestedInput
    referralsAsReferrer?: ReferralUpdateManyWithoutReferrerNestedInput
    referralsAsReferred?: ReferralUpdateManyWithoutReferredNestedInput
    wrongSendRequests?: WrongSendRequestUpdateManyWithoutSenderNestedInput
    createdGroups?: BillSplitGroupUpdateManyWithoutCreatedByNestedInput
    billSplitMembers?: BillSplitMemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRewardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    userpin?: StringFieldUpdateOperationsInput | string
    resetOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OnRampTransaction?: OnRampTransactionUncheckedUpdateManyWithoutUserNestedInput
    Balance?: BalanceUncheckedUpdateManyWithoutUserNestedInput
    sentTransfers?: p2pTransferUncheckedUpdateManyWithoutFromUserNestedInput
    receivedTransfers?: p2pTransferUncheckedUpdateManyWithoutToUserNestedInput
    sentRequests?: P2PRequestUncheckedUpdateManyWithoutSenderNestedInput
    receivedRequests?: P2PRequestUncheckedUpdateManyWithoutReceiverNestedInput
    billSchedules?: BillScheduleUncheckedUpdateManyWithoutUserNestedInput
    merchantPayments?: MerchantPaymentUncheckedUpdateManyWithoutUserNestedInput
    rechargeOrders?: RechargeOrderUncheckedUpdateManyWithoutUserNestedInput
    referralsAsReferrer?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referralsAsReferred?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    wrongSendRequests?: WrongSendRequestUncheckedUpdateManyWithoutSenderNestedInput
    createdGroups?: BillSplitGroupUncheckedUpdateManyWithoutCreatedByNestedInput
    billSplitMembers?: BillSplitMemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BillSplitGroupUpsertWithoutRewardsInput = {
    update: XOR<BillSplitGroupUpdateWithoutRewardsInput, BillSplitGroupUncheckedUpdateWithoutRewardsInput>
    create: XOR<BillSplitGroupCreateWithoutRewardsInput, BillSplitGroupUncheckedCreateWithoutRewardsInput>
    where?: BillSplitGroupWhereInput
  }

  export type BillSplitGroupUpdateToOneWithWhereWithoutRewardsInput = {
    where?: BillSplitGroupWhereInput
    data: XOR<BillSplitGroupUpdateWithoutRewardsInput, BillSplitGroupUncheckedUpdateWithoutRewardsInput>
  }

  export type BillSplitGroupUpdateWithoutRewardsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedGroupsNestedInput
    members?: BillSplitMemberUpdateManyWithoutGroupNestedInput
    payments?: BillSplitPaymentUpdateManyWithoutGroupNestedInput
  }

  export type BillSplitGroupUncheckedUpdateWithoutRewardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    members?: BillSplitMemberUncheckedUpdateManyWithoutGroupNestedInput
    payments?: BillSplitPaymentUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type UserCreateWithoutReferralsAsReferrerInput = {
    email?: string | null
    name?: string | null
    number: string
    password: string
    sessionToken?: string | null
    image?: string | null
    userpin: string
    resetOtp?: string | null
    resetExpires?: Date | string | null
    OnRampTransaction?: OnRampTransactionCreateNestedManyWithoutUserInput
    Balance?: BalanceCreateNestedManyWithoutUserInput
    sentTransfers?: p2pTransferCreateNestedManyWithoutFromUserInput
    receivedTransfers?: p2pTransferCreateNestedManyWithoutToUserInput
    sentRequests?: P2PRequestCreateNestedManyWithoutSenderInput
    receivedRequests?: P2PRequestCreateNestedManyWithoutReceiverInput
    billSchedules?: BillScheduleCreateNestedManyWithoutUserInput
    merchantPayments?: MerchantPaymentCreateNestedManyWithoutUserInput
    rechargeOrders?: RechargeOrderCreateNestedManyWithoutUserInput
    rewards?: RewardCreateNestedManyWithoutUserInput
    referralsAsReferred?: ReferralCreateNestedManyWithoutReferredInput
    wrongSendRequests?: WrongSendRequestCreateNestedManyWithoutSenderInput
    createdGroups?: BillSplitGroupCreateNestedManyWithoutCreatedByInput
    billSplitMembers?: BillSplitMemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReferralsAsReferrerInput = {
    id?: number
    email?: string | null
    name?: string | null
    number: string
    password: string
    sessionToken?: string | null
    image?: string | null
    userpin: string
    resetOtp?: string | null
    resetExpires?: Date | string | null
    OnRampTransaction?: OnRampTransactionUncheckedCreateNestedManyWithoutUserInput
    Balance?: BalanceUncheckedCreateNestedManyWithoutUserInput
    sentTransfers?: p2pTransferUncheckedCreateNestedManyWithoutFromUserInput
    receivedTransfers?: p2pTransferUncheckedCreateNestedManyWithoutToUserInput
    sentRequests?: P2PRequestUncheckedCreateNestedManyWithoutSenderInput
    receivedRequests?: P2PRequestUncheckedCreateNestedManyWithoutReceiverInput
    billSchedules?: BillScheduleUncheckedCreateNestedManyWithoutUserInput
    merchantPayments?: MerchantPaymentUncheckedCreateNestedManyWithoutUserInput
    rechargeOrders?: RechargeOrderUncheckedCreateNestedManyWithoutUserInput
    rewards?: RewardUncheckedCreateNestedManyWithoutUserInput
    referralsAsReferred?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    wrongSendRequests?: WrongSendRequestUncheckedCreateNestedManyWithoutSenderInput
    createdGroups?: BillSplitGroupUncheckedCreateNestedManyWithoutCreatedByInput
    billSplitMembers?: BillSplitMemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReferralsAsReferrerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferralsAsReferrerInput, UserUncheckedCreateWithoutReferralsAsReferrerInput>
  }

  export type UserCreateWithoutReferralsAsReferredInput = {
    email?: string | null
    name?: string | null
    number: string
    password: string
    sessionToken?: string | null
    image?: string | null
    userpin: string
    resetOtp?: string | null
    resetExpires?: Date | string | null
    OnRampTransaction?: OnRampTransactionCreateNestedManyWithoutUserInput
    Balance?: BalanceCreateNestedManyWithoutUserInput
    sentTransfers?: p2pTransferCreateNestedManyWithoutFromUserInput
    receivedTransfers?: p2pTransferCreateNestedManyWithoutToUserInput
    sentRequests?: P2PRequestCreateNestedManyWithoutSenderInput
    receivedRequests?: P2PRequestCreateNestedManyWithoutReceiverInput
    billSchedules?: BillScheduleCreateNestedManyWithoutUserInput
    merchantPayments?: MerchantPaymentCreateNestedManyWithoutUserInput
    rechargeOrders?: RechargeOrderCreateNestedManyWithoutUserInput
    rewards?: RewardCreateNestedManyWithoutUserInput
    referralsAsReferrer?: ReferralCreateNestedManyWithoutReferrerInput
    wrongSendRequests?: WrongSendRequestCreateNestedManyWithoutSenderInput
    createdGroups?: BillSplitGroupCreateNestedManyWithoutCreatedByInput
    billSplitMembers?: BillSplitMemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReferralsAsReferredInput = {
    id?: number
    email?: string | null
    name?: string | null
    number: string
    password: string
    sessionToken?: string | null
    image?: string | null
    userpin: string
    resetOtp?: string | null
    resetExpires?: Date | string | null
    OnRampTransaction?: OnRampTransactionUncheckedCreateNestedManyWithoutUserInput
    Balance?: BalanceUncheckedCreateNestedManyWithoutUserInput
    sentTransfers?: p2pTransferUncheckedCreateNestedManyWithoutFromUserInput
    receivedTransfers?: p2pTransferUncheckedCreateNestedManyWithoutToUserInput
    sentRequests?: P2PRequestUncheckedCreateNestedManyWithoutSenderInput
    receivedRequests?: P2PRequestUncheckedCreateNestedManyWithoutReceiverInput
    billSchedules?: BillScheduleUncheckedCreateNestedManyWithoutUserInput
    merchantPayments?: MerchantPaymentUncheckedCreateNestedManyWithoutUserInput
    rechargeOrders?: RechargeOrderUncheckedCreateNestedManyWithoutUserInput
    rewards?: RewardUncheckedCreateNestedManyWithoutUserInput
    referralsAsReferrer?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    wrongSendRequests?: WrongSendRequestUncheckedCreateNestedManyWithoutSenderInput
    createdGroups?: BillSplitGroupUncheckedCreateNestedManyWithoutCreatedByInput
    billSplitMembers?: BillSplitMemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReferralsAsReferredInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferralsAsReferredInput, UserUncheckedCreateWithoutReferralsAsReferredInput>
  }

  export type UserUpsertWithoutReferralsAsReferrerInput = {
    update: XOR<UserUpdateWithoutReferralsAsReferrerInput, UserUncheckedUpdateWithoutReferralsAsReferrerInput>
    create: XOR<UserCreateWithoutReferralsAsReferrerInput, UserUncheckedCreateWithoutReferralsAsReferrerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferralsAsReferrerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferralsAsReferrerInput, UserUncheckedUpdateWithoutReferralsAsReferrerInput>
  }

  export type UserUpdateWithoutReferralsAsReferrerInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    userpin?: StringFieldUpdateOperationsInput | string
    resetOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OnRampTransaction?: OnRampTransactionUpdateManyWithoutUserNestedInput
    Balance?: BalanceUpdateManyWithoutUserNestedInput
    sentTransfers?: p2pTransferUpdateManyWithoutFromUserNestedInput
    receivedTransfers?: p2pTransferUpdateManyWithoutToUserNestedInput
    sentRequests?: P2PRequestUpdateManyWithoutSenderNestedInput
    receivedRequests?: P2PRequestUpdateManyWithoutReceiverNestedInput
    billSchedules?: BillScheduleUpdateManyWithoutUserNestedInput
    merchantPayments?: MerchantPaymentUpdateManyWithoutUserNestedInput
    rechargeOrders?: RechargeOrderUpdateManyWithoutUserNestedInput
    rewards?: RewardUpdateManyWithoutUserNestedInput
    referralsAsReferred?: ReferralUpdateManyWithoutReferredNestedInput
    wrongSendRequests?: WrongSendRequestUpdateManyWithoutSenderNestedInput
    createdGroups?: BillSplitGroupUpdateManyWithoutCreatedByNestedInput
    billSplitMembers?: BillSplitMemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReferralsAsReferrerInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    userpin?: StringFieldUpdateOperationsInput | string
    resetOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OnRampTransaction?: OnRampTransactionUncheckedUpdateManyWithoutUserNestedInput
    Balance?: BalanceUncheckedUpdateManyWithoutUserNestedInput
    sentTransfers?: p2pTransferUncheckedUpdateManyWithoutFromUserNestedInput
    receivedTransfers?: p2pTransferUncheckedUpdateManyWithoutToUserNestedInput
    sentRequests?: P2PRequestUncheckedUpdateManyWithoutSenderNestedInput
    receivedRequests?: P2PRequestUncheckedUpdateManyWithoutReceiverNestedInput
    billSchedules?: BillScheduleUncheckedUpdateManyWithoutUserNestedInput
    merchantPayments?: MerchantPaymentUncheckedUpdateManyWithoutUserNestedInput
    rechargeOrders?: RechargeOrderUncheckedUpdateManyWithoutUserNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutUserNestedInput
    referralsAsReferred?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    wrongSendRequests?: WrongSendRequestUncheckedUpdateManyWithoutSenderNestedInput
    createdGroups?: BillSplitGroupUncheckedUpdateManyWithoutCreatedByNestedInput
    billSplitMembers?: BillSplitMemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutReferralsAsReferredInput = {
    update: XOR<UserUpdateWithoutReferralsAsReferredInput, UserUncheckedUpdateWithoutReferralsAsReferredInput>
    create: XOR<UserCreateWithoutReferralsAsReferredInput, UserUncheckedCreateWithoutReferralsAsReferredInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferralsAsReferredInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferralsAsReferredInput, UserUncheckedUpdateWithoutReferralsAsReferredInput>
  }

  export type UserUpdateWithoutReferralsAsReferredInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    userpin?: StringFieldUpdateOperationsInput | string
    resetOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OnRampTransaction?: OnRampTransactionUpdateManyWithoutUserNestedInput
    Balance?: BalanceUpdateManyWithoutUserNestedInput
    sentTransfers?: p2pTransferUpdateManyWithoutFromUserNestedInput
    receivedTransfers?: p2pTransferUpdateManyWithoutToUserNestedInput
    sentRequests?: P2PRequestUpdateManyWithoutSenderNestedInput
    receivedRequests?: P2PRequestUpdateManyWithoutReceiverNestedInput
    billSchedules?: BillScheduleUpdateManyWithoutUserNestedInput
    merchantPayments?: MerchantPaymentUpdateManyWithoutUserNestedInput
    rechargeOrders?: RechargeOrderUpdateManyWithoutUserNestedInput
    rewards?: RewardUpdateManyWithoutUserNestedInput
    referralsAsReferrer?: ReferralUpdateManyWithoutReferrerNestedInput
    wrongSendRequests?: WrongSendRequestUpdateManyWithoutSenderNestedInput
    createdGroups?: BillSplitGroupUpdateManyWithoutCreatedByNestedInput
    billSplitMembers?: BillSplitMemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReferralsAsReferredInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    userpin?: StringFieldUpdateOperationsInput | string
    resetOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OnRampTransaction?: OnRampTransactionUncheckedUpdateManyWithoutUserNestedInput
    Balance?: BalanceUncheckedUpdateManyWithoutUserNestedInput
    sentTransfers?: p2pTransferUncheckedUpdateManyWithoutFromUserNestedInput
    receivedTransfers?: p2pTransferUncheckedUpdateManyWithoutToUserNestedInput
    sentRequests?: P2PRequestUncheckedUpdateManyWithoutSenderNestedInput
    receivedRequests?: P2PRequestUncheckedUpdateManyWithoutReceiverNestedInput
    billSchedules?: BillScheduleUncheckedUpdateManyWithoutUserNestedInput
    merchantPayments?: MerchantPaymentUncheckedUpdateManyWithoutUserNestedInput
    rechargeOrders?: RechargeOrderUncheckedUpdateManyWithoutUserNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutUserNestedInput
    referralsAsReferrer?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    wrongSendRequests?: WrongSendRequestUncheckedUpdateManyWithoutSenderNestedInput
    createdGroups?: BillSplitGroupUncheckedUpdateManyWithoutCreatedByNestedInput
    billSplitMembers?: BillSplitMemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutWrongSendRequestsInput = {
    email?: string | null
    name?: string | null
    number: string
    password: string
    sessionToken?: string | null
    image?: string | null
    userpin: string
    resetOtp?: string | null
    resetExpires?: Date | string | null
    OnRampTransaction?: OnRampTransactionCreateNestedManyWithoutUserInput
    Balance?: BalanceCreateNestedManyWithoutUserInput
    sentTransfers?: p2pTransferCreateNestedManyWithoutFromUserInput
    receivedTransfers?: p2pTransferCreateNestedManyWithoutToUserInput
    sentRequests?: P2PRequestCreateNestedManyWithoutSenderInput
    receivedRequests?: P2PRequestCreateNestedManyWithoutReceiverInput
    billSchedules?: BillScheduleCreateNestedManyWithoutUserInput
    merchantPayments?: MerchantPaymentCreateNestedManyWithoutUserInput
    rechargeOrders?: RechargeOrderCreateNestedManyWithoutUserInput
    rewards?: RewardCreateNestedManyWithoutUserInput
    referralsAsReferrer?: ReferralCreateNestedManyWithoutReferrerInput
    referralsAsReferred?: ReferralCreateNestedManyWithoutReferredInput
    createdGroups?: BillSplitGroupCreateNestedManyWithoutCreatedByInput
    billSplitMembers?: BillSplitMemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWrongSendRequestsInput = {
    id?: number
    email?: string | null
    name?: string | null
    number: string
    password: string
    sessionToken?: string | null
    image?: string | null
    userpin: string
    resetOtp?: string | null
    resetExpires?: Date | string | null
    OnRampTransaction?: OnRampTransactionUncheckedCreateNestedManyWithoutUserInput
    Balance?: BalanceUncheckedCreateNestedManyWithoutUserInput
    sentTransfers?: p2pTransferUncheckedCreateNestedManyWithoutFromUserInput
    receivedTransfers?: p2pTransferUncheckedCreateNestedManyWithoutToUserInput
    sentRequests?: P2PRequestUncheckedCreateNestedManyWithoutSenderInput
    receivedRequests?: P2PRequestUncheckedCreateNestedManyWithoutReceiverInput
    billSchedules?: BillScheduleUncheckedCreateNestedManyWithoutUserInput
    merchantPayments?: MerchantPaymentUncheckedCreateNestedManyWithoutUserInput
    rechargeOrders?: RechargeOrderUncheckedCreateNestedManyWithoutUserInput
    rewards?: RewardUncheckedCreateNestedManyWithoutUserInput
    referralsAsReferrer?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referralsAsReferred?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    createdGroups?: BillSplitGroupUncheckedCreateNestedManyWithoutCreatedByInput
    billSplitMembers?: BillSplitMemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWrongSendRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWrongSendRequestsInput, UserUncheckedCreateWithoutWrongSendRequestsInput>
  }

  export type p2pTransferCreateWithoutWrongSendRequestInput = {
    amount: number
    timestamp: Date | string
    receiverNumber?: string | null
    status?: string
    razorpayPaymentId?: string | null
    paymentMethod?: string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    merchantId?: number | null
    latitude?: number | null
    longitude?: number | null
    isFraud?: boolean | null
    fraudScore?: number | null
    fraudReason?: string | null
    riskLevel?: string | null
    fromUser: UserCreateNestedOneWithoutSentTransfersInput
    toUser?: UserCreateNestedOneWithoutReceivedTransfersInput
    billSplitPayment?: BillSplitPaymentCreateNestedOneWithoutP2pTransferInput
  }

  export type p2pTransferUncheckedCreateWithoutWrongSendRequestInput = {
    id?: number
    amount: number
    timestamp: Date | string
    fromUserId: number
    toUserId?: number | null
    receiverNumber?: string | null
    status?: string
    razorpayPaymentId?: string | null
    paymentMethod?: string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    merchantId?: number | null
    latitude?: number | null
    longitude?: number | null
    isFraud?: boolean | null
    fraudScore?: number | null
    fraudReason?: string | null
    riskLevel?: string | null
    billSplitPayment?: BillSplitPaymentUncheckedCreateNestedOneWithoutP2pTransferInput
  }

  export type p2pTransferCreateOrConnectWithoutWrongSendRequestInput = {
    where: p2pTransferWhereUniqueInput
    create: XOR<p2pTransferCreateWithoutWrongSendRequestInput, p2pTransferUncheckedCreateWithoutWrongSendRequestInput>
  }

  export type UserUpsertWithoutWrongSendRequestsInput = {
    update: XOR<UserUpdateWithoutWrongSendRequestsInput, UserUncheckedUpdateWithoutWrongSendRequestsInput>
    create: XOR<UserCreateWithoutWrongSendRequestsInput, UserUncheckedCreateWithoutWrongSendRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWrongSendRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWrongSendRequestsInput, UserUncheckedUpdateWithoutWrongSendRequestsInput>
  }

  export type UserUpdateWithoutWrongSendRequestsInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    userpin?: StringFieldUpdateOperationsInput | string
    resetOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OnRampTransaction?: OnRampTransactionUpdateManyWithoutUserNestedInput
    Balance?: BalanceUpdateManyWithoutUserNestedInput
    sentTransfers?: p2pTransferUpdateManyWithoutFromUserNestedInput
    receivedTransfers?: p2pTransferUpdateManyWithoutToUserNestedInput
    sentRequests?: P2PRequestUpdateManyWithoutSenderNestedInput
    receivedRequests?: P2PRequestUpdateManyWithoutReceiverNestedInput
    billSchedules?: BillScheduleUpdateManyWithoutUserNestedInput
    merchantPayments?: MerchantPaymentUpdateManyWithoutUserNestedInput
    rechargeOrders?: RechargeOrderUpdateManyWithoutUserNestedInput
    rewards?: RewardUpdateManyWithoutUserNestedInput
    referralsAsReferrer?: ReferralUpdateManyWithoutReferrerNestedInput
    referralsAsReferred?: ReferralUpdateManyWithoutReferredNestedInput
    createdGroups?: BillSplitGroupUpdateManyWithoutCreatedByNestedInput
    billSplitMembers?: BillSplitMemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWrongSendRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    userpin?: StringFieldUpdateOperationsInput | string
    resetOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OnRampTransaction?: OnRampTransactionUncheckedUpdateManyWithoutUserNestedInput
    Balance?: BalanceUncheckedUpdateManyWithoutUserNestedInput
    sentTransfers?: p2pTransferUncheckedUpdateManyWithoutFromUserNestedInput
    receivedTransfers?: p2pTransferUncheckedUpdateManyWithoutToUserNestedInput
    sentRequests?: P2PRequestUncheckedUpdateManyWithoutSenderNestedInput
    receivedRequests?: P2PRequestUncheckedUpdateManyWithoutReceiverNestedInput
    billSchedules?: BillScheduleUncheckedUpdateManyWithoutUserNestedInput
    merchantPayments?: MerchantPaymentUncheckedUpdateManyWithoutUserNestedInput
    rechargeOrders?: RechargeOrderUncheckedUpdateManyWithoutUserNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutUserNestedInput
    referralsAsReferrer?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referralsAsReferred?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    createdGroups?: BillSplitGroupUncheckedUpdateManyWithoutCreatedByNestedInput
    billSplitMembers?: BillSplitMemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type p2pTransferUpsertWithoutWrongSendRequestInput = {
    update: XOR<p2pTransferUpdateWithoutWrongSendRequestInput, p2pTransferUncheckedUpdateWithoutWrongSendRequestInput>
    create: XOR<p2pTransferCreateWithoutWrongSendRequestInput, p2pTransferUncheckedCreateWithoutWrongSendRequestInput>
    where?: p2pTransferWhereInput
  }

  export type p2pTransferUpdateToOneWithWhereWithoutWrongSendRequestInput = {
    where?: p2pTransferWhereInput
    data: XOR<p2pTransferUpdateWithoutWrongSendRequestInput, p2pTransferUncheckedUpdateWithoutWrongSendRequestInput>
  }

  export type p2pTransferUpdateWithoutWrongSendRequestInput = {
    amount?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    isFraud?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fraudScore?: NullableFloatFieldUpdateOperationsInput | number | null
    fraudReason?: NullableStringFieldUpdateOperationsInput | string | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    fromUser?: UserUpdateOneRequiredWithoutSentTransfersNestedInput
    toUser?: UserUpdateOneWithoutReceivedTransfersNestedInput
    billSplitPayment?: BillSplitPaymentUpdateOneWithoutP2pTransferNestedInput
  }

  export type p2pTransferUncheckedUpdateWithoutWrongSendRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    fromUserId?: IntFieldUpdateOperationsInput | number
    toUserId?: NullableIntFieldUpdateOperationsInput | number | null
    receiverNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    isFraud?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fraudScore?: NullableFloatFieldUpdateOperationsInput | number | null
    fraudReason?: NullableStringFieldUpdateOperationsInput | string | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    billSplitPayment?: BillSplitPaymentUncheckedUpdateOneWithoutP2pTransferNestedInput
  }

  export type UserCreateWithoutCreatedGroupsInput = {
    email?: string | null
    name?: string | null
    number: string
    password: string
    sessionToken?: string | null
    image?: string | null
    userpin: string
    resetOtp?: string | null
    resetExpires?: Date | string | null
    OnRampTransaction?: OnRampTransactionCreateNestedManyWithoutUserInput
    Balance?: BalanceCreateNestedManyWithoutUserInput
    sentTransfers?: p2pTransferCreateNestedManyWithoutFromUserInput
    receivedTransfers?: p2pTransferCreateNestedManyWithoutToUserInput
    sentRequests?: P2PRequestCreateNestedManyWithoutSenderInput
    receivedRequests?: P2PRequestCreateNestedManyWithoutReceiverInput
    billSchedules?: BillScheduleCreateNestedManyWithoutUserInput
    merchantPayments?: MerchantPaymentCreateNestedManyWithoutUserInput
    rechargeOrders?: RechargeOrderCreateNestedManyWithoutUserInput
    rewards?: RewardCreateNestedManyWithoutUserInput
    referralsAsReferrer?: ReferralCreateNestedManyWithoutReferrerInput
    referralsAsReferred?: ReferralCreateNestedManyWithoutReferredInput
    wrongSendRequests?: WrongSendRequestCreateNestedManyWithoutSenderInput
    billSplitMembers?: BillSplitMemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedGroupsInput = {
    id?: number
    email?: string | null
    name?: string | null
    number: string
    password: string
    sessionToken?: string | null
    image?: string | null
    userpin: string
    resetOtp?: string | null
    resetExpires?: Date | string | null
    OnRampTransaction?: OnRampTransactionUncheckedCreateNestedManyWithoutUserInput
    Balance?: BalanceUncheckedCreateNestedManyWithoutUserInput
    sentTransfers?: p2pTransferUncheckedCreateNestedManyWithoutFromUserInput
    receivedTransfers?: p2pTransferUncheckedCreateNestedManyWithoutToUserInput
    sentRequests?: P2PRequestUncheckedCreateNestedManyWithoutSenderInput
    receivedRequests?: P2PRequestUncheckedCreateNestedManyWithoutReceiverInput
    billSchedules?: BillScheduleUncheckedCreateNestedManyWithoutUserInput
    merchantPayments?: MerchantPaymentUncheckedCreateNestedManyWithoutUserInput
    rechargeOrders?: RechargeOrderUncheckedCreateNestedManyWithoutUserInput
    rewards?: RewardUncheckedCreateNestedManyWithoutUserInput
    referralsAsReferrer?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referralsAsReferred?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    wrongSendRequests?: WrongSendRequestUncheckedCreateNestedManyWithoutSenderInput
    billSplitMembers?: BillSplitMemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedGroupsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedGroupsInput, UserUncheckedCreateWithoutCreatedGroupsInput>
  }

  export type BillSplitMemberCreateWithoutGroupInput = {
    phone?: string | null
    name: string
    share: number
    paid?: boolean
    paidAt?: Date | string | null
    paidAmount?: number
    user?: UserCreateNestedOneWithoutBillSplitMembersInput
    request?: P2PRequestCreateNestedOneWithoutBillSplitMemberInput
    payments?: BillSplitPaymentCreateNestedManyWithoutMemberInput
  }

  export type BillSplitMemberUncheckedCreateWithoutGroupInput = {
    id?: number
    userId?: number | null
    phone?: string | null
    name: string
    share: number
    paid?: boolean
    paidAt?: Date | string | null
    paidAmount?: number
    request?: P2PRequestUncheckedCreateNestedOneWithoutBillSplitMemberInput
    payments?: BillSplitPaymentUncheckedCreateNestedManyWithoutMemberInput
  }

  export type BillSplitMemberCreateOrConnectWithoutGroupInput = {
    where: BillSplitMemberWhereUniqueInput
    create: XOR<BillSplitMemberCreateWithoutGroupInput, BillSplitMemberUncheckedCreateWithoutGroupInput>
  }

  export type BillSplitMemberCreateManyGroupInputEnvelope = {
    data: BillSplitMemberCreateManyGroupInput | BillSplitMemberCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type BillSplitPaymentCreateWithoutGroupInput = {
    amount: number
    paidAt?: Date | string
    member: BillSplitMemberCreateNestedOneWithoutPaymentsInput
    p2pTransfer?: p2pTransferCreateNestedOneWithoutBillSplitPaymentInput
  }

  export type BillSplitPaymentUncheckedCreateWithoutGroupInput = {
    id?: number
    memberId: number
    p2pTransferId?: number | null
    amount: number
    paidAt?: Date | string
  }

  export type BillSplitPaymentCreateOrConnectWithoutGroupInput = {
    where: BillSplitPaymentWhereUniqueInput
    create: XOR<BillSplitPaymentCreateWithoutGroupInput, BillSplitPaymentUncheckedCreateWithoutGroupInput>
  }

  export type BillSplitPaymentCreateManyGroupInputEnvelope = {
    data: BillSplitPaymentCreateManyGroupInput | BillSplitPaymentCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type RewardCreateWithoutBillSplitGroupInput = {
    type: $Enums.RewardType
    amount: bigint | number
    status?: $Enums.RewardStatus
    earnedAt?: Date | string
    expiresAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutRewardsInput
  }

  export type RewardUncheckedCreateWithoutBillSplitGroupInput = {
    id?: number
    userId: number
    type: $Enums.RewardType
    amount: bigint | number
    status?: $Enums.RewardStatus
    earnedAt?: Date | string
    expiresAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RewardCreateOrConnectWithoutBillSplitGroupInput = {
    where: RewardWhereUniqueInput
    create: XOR<RewardCreateWithoutBillSplitGroupInput, RewardUncheckedCreateWithoutBillSplitGroupInput>
  }

  export type RewardCreateManyBillSplitGroupInputEnvelope = {
    data: RewardCreateManyBillSplitGroupInput | RewardCreateManyBillSplitGroupInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatedGroupsInput = {
    update: XOR<UserUpdateWithoutCreatedGroupsInput, UserUncheckedUpdateWithoutCreatedGroupsInput>
    create: XOR<UserCreateWithoutCreatedGroupsInput, UserUncheckedCreateWithoutCreatedGroupsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedGroupsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedGroupsInput, UserUncheckedUpdateWithoutCreatedGroupsInput>
  }

  export type UserUpdateWithoutCreatedGroupsInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    userpin?: StringFieldUpdateOperationsInput | string
    resetOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OnRampTransaction?: OnRampTransactionUpdateManyWithoutUserNestedInput
    Balance?: BalanceUpdateManyWithoutUserNestedInput
    sentTransfers?: p2pTransferUpdateManyWithoutFromUserNestedInput
    receivedTransfers?: p2pTransferUpdateManyWithoutToUserNestedInput
    sentRequests?: P2PRequestUpdateManyWithoutSenderNestedInput
    receivedRequests?: P2PRequestUpdateManyWithoutReceiverNestedInput
    billSchedules?: BillScheduleUpdateManyWithoutUserNestedInput
    merchantPayments?: MerchantPaymentUpdateManyWithoutUserNestedInput
    rechargeOrders?: RechargeOrderUpdateManyWithoutUserNestedInput
    rewards?: RewardUpdateManyWithoutUserNestedInput
    referralsAsReferrer?: ReferralUpdateManyWithoutReferrerNestedInput
    referralsAsReferred?: ReferralUpdateManyWithoutReferredNestedInput
    wrongSendRequests?: WrongSendRequestUpdateManyWithoutSenderNestedInput
    billSplitMembers?: BillSplitMemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    userpin?: StringFieldUpdateOperationsInput | string
    resetOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OnRampTransaction?: OnRampTransactionUncheckedUpdateManyWithoutUserNestedInput
    Balance?: BalanceUncheckedUpdateManyWithoutUserNestedInput
    sentTransfers?: p2pTransferUncheckedUpdateManyWithoutFromUserNestedInput
    receivedTransfers?: p2pTransferUncheckedUpdateManyWithoutToUserNestedInput
    sentRequests?: P2PRequestUncheckedUpdateManyWithoutSenderNestedInput
    receivedRequests?: P2PRequestUncheckedUpdateManyWithoutReceiverNestedInput
    billSchedules?: BillScheduleUncheckedUpdateManyWithoutUserNestedInput
    merchantPayments?: MerchantPaymentUncheckedUpdateManyWithoutUserNestedInput
    rechargeOrders?: RechargeOrderUncheckedUpdateManyWithoutUserNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutUserNestedInput
    referralsAsReferrer?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referralsAsReferred?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    wrongSendRequests?: WrongSendRequestUncheckedUpdateManyWithoutSenderNestedInput
    billSplitMembers?: BillSplitMemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BillSplitMemberUpsertWithWhereUniqueWithoutGroupInput = {
    where: BillSplitMemberWhereUniqueInput
    update: XOR<BillSplitMemberUpdateWithoutGroupInput, BillSplitMemberUncheckedUpdateWithoutGroupInput>
    create: XOR<BillSplitMemberCreateWithoutGroupInput, BillSplitMemberUncheckedCreateWithoutGroupInput>
  }

  export type BillSplitMemberUpdateWithWhereUniqueWithoutGroupInput = {
    where: BillSplitMemberWhereUniqueInput
    data: XOR<BillSplitMemberUpdateWithoutGroupInput, BillSplitMemberUncheckedUpdateWithoutGroupInput>
  }

  export type BillSplitMemberUpdateManyWithWhereWithoutGroupInput = {
    where: BillSplitMemberScalarWhereInput
    data: XOR<BillSplitMemberUpdateManyMutationInput, BillSplitMemberUncheckedUpdateManyWithoutGroupInput>
  }

  export type BillSplitPaymentUpsertWithWhereUniqueWithoutGroupInput = {
    where: BillSplitPaymentWhereUniqueInput
    update: XOR<BillSplitPaymentUpdateWithoutGroupInput, BillSplitPaymentUncheckedUpdateWithoutGroupInput>
    create: XOR<BillSplitPaymentCreateWithoutGroupInput, BillSplitPaymentUncheckedCreateWithoutGroupInput>
  }

  export type BillSplitPaymentUpdateWithWhereUniqueWithoutGroupInput = {
    where: BillSplitPaymentWhereUniqueInput
    data: XOR<BillSplitPaymentUpdateWithoutGroupInput, BillSplitPaymentUncheckedUpdateWithoutGroupInput>
  }

  export type BillSplitPaymentUpdateManyWithWhereWithoutGroupInput = {
    where: BillSplitPaymentScalarWhereInput
    data: XOR<BillSplitPaymentUpdateManyMutationInput, BillSplitPaymentUncheckedUpdateManyWithoutGroupInput>
  }

  export type BillSplitPaymentScalarWhereInput = {
    AND?: BillSplitPaymentScalarWhereInput | BillSplitPaymentScalarWhereInput[]
    OR?: BillSplitPaymentScalarWhereInput[]
    NOT?: BillSplitPaymentScalarWhereInput | BillSplitPaymentScalarWhereInput[]
    id?: IntFilter<"BillSplitPayment"> | number
    groupId?: IntFilter<"BillSplitPayment"> | number
    memberId?: IntFilter<"BillSplitPayment"> | number
    p2pTransferId?: IntNullableFilter<"BillSplitPayment"> | number | null
    amount?: IntFilter<"BillSplitPayment"> | number
    paidAt?: DateTimeFilter<"BillSplitPayment"> | Date | string
  }

  export type RewardUpsertWithWhereUniqueWithoutBillSplitGroupInput = {
    where: RewardWhereUniqueInput
    update: XOR<RewardUpdateWithoutBillSplitGroupInput, RewardUncheckedUpdateWithoutBillSplitGroupInput>
    create: XOR<RewardCreateWithoutBillSplitGroupInput, RewardUncheckedCreateWithoutBillSplitGroupInput>
  }

  export type RewardUpdateWithWhereUniqueWithoutBillSplitGroupInput = {
    where: RewardWhereUniqueInput
    data: XOR<RewardUpdateWithoutBillSplitGroupInput, RewardUncheckedUpdateWithoutBillSplitGroupInput>
  }

  export type RewardUpdateManyWithWhereWithoutBillSplitGroupInput = {
    where: RewardScalarWhereInput
    data: XOR<RewardUpdateManyMutationInput, RewardUncheckedUpdateManyWithoutBillSplitGroupInput>
  }

  export type BillSplitGroupCreateWithoutMembersInput = {
    name: string
    description?: string | null
    totalAmount: number
    currency?: string
    createdAt?: Date | string
    settledAt?: Date | string | null
    status?: string
    createdBy: UserCreateNestedOneWithoutCreatedGroupsInput
    payments?: BillSplitPaymentCreateNestedManyWithoutGroupInput
    rewards?: RewardCreateNestedManyWithoutBillSplitGroupInput
  }

  export type BillSplitGroupUncheckedCreateWithoutMembersInput = {
    id?: number
    name: string
    description?: string | null
    totalAmount: number
    currency?: string
    createdById: number
    createdAt?: Date | string
    settledAt?: Date | string | null
    status?: string
    payments?: BillSplitPaymentUncheckedCreateNestedManyWithoutGroupInput
    rewards?: RewardUncheckedCreateNestedManyWithoutBillSplitGroupInput
  }

  export type BillSplitGroupCreateOrConnectWithoutMembersInput = {
    where: BillSplitGroupWhereUniqueInput
    create: XOR<BillSplitGroupCreateWithoutMembersInput, BillSplitGroupUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutBillSplitMembersInput = {
    email?: string | null
    name?: string | null
    number: string
    password: string
    sessionToken?: string | null
    image?: string | null
    userpin: string
    resetOtp?: string | null
    resetExpires?: Date | string | null
    OnRampTransaction?: OnRampTransactionCreateNestedManyWithoutUserInput
    Balance?: BalanceCreateNestedManyWithoutUserInput
    sentTransfers?: p2pTransferCreateNestedManyWithoutFromUserInput
    receivedTransfers?: p2pTransferCreateNestedManyWithoutToUserInput
    sentRequests?: P2PRequestCreateNestedManyWithoutSenderInput
    receivedRequests?: P2PRequestCreateNestedManyWithoutReceiverInput
    billSchedules?: BillScheduleCreateNestedManyWithoutUserInput
    merchantPayments?: MerchantPaymentCreateNestedManyWithoutUserInput
    rechargeOrders?: RechargeOrderCreateNestedManyWithoutUserInput
    rewards?: RewardCreateNestedManyWithoutUserInput
    referralsAsReferrer?: ReferralCreateNestedManyWithoutReferrerInput
    referralsAsReferred?: ReferralCreateNestedManyWithoutReferredInput
    wrongSendRequests?: WrongSendRequestCreateNestedManyWithoutSenderInput
    createdGroups?: BillSplitGroupCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutBillSplitMembersInput = {
    id?: number
    email?: string | null
    name?: string | null
    number: string
    password: string
    sessionToken?: string | null
    image?: string | null
    userpin: string
    resetOtp?: string | null
    resetExpires?: Date | string | null
    OnRampTransaction?: OnRampTransactionUncheckedCreateNestedManyWithoutUserInput
    Balance?: BalanceUncheckedCreateNestedManyWithoutUserInput
    sentTransfers?: p2pTransferUncheckedCreateNestedManyWithoutFromUserInput
    receivedTransfers?: p2pTransferUncheckedCreateNestedManyWithoutToUserInput
    sentRequests?: P2PRequestUncheckedCreateNestedManyWithoutSenderInput
    receivedRequests?: P2PRequestUncheckedCreateNestedManyWithoutReceiverInput
    billSchedules?: BillScheduleUncheckedCreateNestedManyWithoutUserInput
    merchantPayments?: MerchantPaymentUncheckedCreateNestedManyWithoutUserInput
    rechargeOrders?: RechargeOrderUncheckedCreateNestedManyWithoutUserInput
    rewards?: RewardUncheckedCreateNestedManyWithoutUserInput
    referralsAsReferrer?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referralsAsReferred?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    wrongSendRequests?: WrongSendRequestUncheckedCreateNestedManyWithoutSenderInput
    createdGroups?: BillSplitGroupUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutBillSplitMembersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBillSplitMembersInput, UserUncheckedCreateWithoutBillSplitMembersInput>
  }

  export type P2PRequestCreateWithoutBillSplitMemberInput = {
    receiverNumber: string
    amount: number
    message?: string | null
    status?: $Enums.P2PRequestStatus
    createdAt?: Date | string
    settledAt?: Date | string | null
    sender: UserCreateNestedOneWithoutSentRequestsInput
    receiver?: UserCreateNestedOneWithoutReceivedRequestsInput
  }

  export type P2PRequestUncheckedCreateWithoutBillSplitMemberInput = {
    id?: number
    senderId: number
    receiverId?: number | null
    receiverNumber: string
    amount: number
    message?: string | null
    status?: $Enums.P2PRequestStatus
    createdAt?: Date | string
    settledAt?: Date | string | null
  }

  export type P2PRequestCreateOrConnectWithoutBillSplitMemberInput = {
    where: P2PRequestWhereUniqueInput
    create: XOR<P2PRequestCreateWithoutBillSplitMemberInput, P2PRequestUncheckedCreateWithoutBillSplitMemberInput>
  }

  export type BillSplitPaymentCreateWithoutMemberInput = {
    amount: number
    paidAt?: Date | string
    group: BillSplitGroupCreateNestedOneWithoutPaymentsInput
    p2pTransfer?: p2pTransferCreateNestedOneWithoutBillSplitPaymentInput
  }

  export type BillSplitPaymentUncheckedCreateWithoutMemberInput = {
    id?: number
    groupId: number
    p2pTransferId?: number | null
    amount: number
    paidAt?: Date | string
  }

  export type BillSplitPaymentCreateOrConnectWithoutMemberInput = {
    where: BillSplitPaymentWhereUniqueInput
    create: XOR<BillSplitPaymentCreateWithoutMemberInput, BillSplitPaymentUncheckedCreateWithoutMemberInput>
  }

  export type BillSplitPaymentCreateManyMemberInputEnvelope = {
    data: BillSplitPaymentCreateManyMemberInput | BillSplitPaymentCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type BillSplitGroupUpsertWithoutMembersInput = {
    update: XOR<BillSplitGroupUpdateWithoutMembersInput, BillSplitGroupUncheckedUpdateWithoutMembersInput>
    create: XOR<BillSplitGroupCreateWithoutMembersInput, BillSplitGroupUncheckedCreateWithoutMembersInput>
    where?: BillSplitGroupWhereInput
  }

  export type BillSplitGroupUpdateToOneWithWhereWithoutMembersInput = {
    where?: BillSplitGroupWhereInput
    data: XOR<BillSplitGroupUpdateWithoutMembersInput, BillSplitGroupUncheckedUpdateWithoutMembersInput>
  }

  export type BillSplitGroupUpdateWithoutMembersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedGroupsNestedInput
    payments?: BillSplitPaymentUpdateManyWithoutGroupNestedInput
    rewards?: RewardUpdateManyWithoutBillSplitGroupNestedInput
  }

  export type BillSplitGroupUncheckedUpdateWithoutMembersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    payments?: BillSplitPaymentUncheckedUpdateManyWithoutGroupNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutBillSplitGroupNestedInput
  }

  export type UserUpsertWithoutBillSplitMembersInput = {
    update: XOR<UserUpdateWithoutBillSplitMembersInput, UserUncheckedUpdateWithoutBillSplitMembersInput>
    create: XOR<UserCreateWithoutBillSplitMembersInput, UserUncheckedCreateWithoutBillSplitMembersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBillSplitMembersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBillSplitMembersInput, UserUncheckedUpdateWithoutBillSplitMembersInput>
  }

  export type UserUpdateWithoutBillSplitMembersInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    userpin?: StringFieldUpdateOperationsInput | string
    resetOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OnRampTransaction?: OnRampTransactionUpdateManyWithoutUserNestedInput
    Balance?: BalanceUpdateManyWithoutUserNestedInput
    sentTransfers?: p2pTransferUpdateManyWithoutFromUserNestedInput
    receivedTransfers?: p2pTransferUpdateManyWithoutToUserNestedInput
    sentRequests?: P2PRequestUpdateManyWithoutSenderNestedInput
    receivedRequests?: P2PRequestUpdateManyWithoutReceiverNestedInput
    billSchedules?: BillScheduleUpdateManyWithoutUserNestedInput
    merchantPayments?: MerchantPaymentUpdateManyWithoutUserNestedInput
    rechargeOrders?: RechargeOrderUpdateManyWithoutUserNestedInput
    rewards?: RewardUpdateManyWithoutUserNestedInput
    referralsAsReferrer?: ReferralUpdateManyWithoutReferrerNestedInput
    referralsAsReferred?: ReferralUpdateManyWithoutReferredNestedInput
    wrongSendRequests?: WrongSendRequestUpdateManyWithoutSenderNestedInput
    createdGroups?: BillSplitGroupUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutBillSplitMembersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    userpin?: StringFieldUpdateOperationsInput | string
    resetOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OnRampTransaction?: OnRampTransactionUncheckedUpdateManyWithoutUserNestedInput
    Balance?: BalanceUncheckedUpdateManyWithoutUserNestedInput
    sentTransfers?: p2pTransferUncheckedUpdateManyWithoutFromUserNestedInput
    receivedTransfers?: p2pTransferUncheckedUpdateManyWithoutToUserNestedInput
    sentRequests?: P2PRequestUncheckedUpdateManyWithoutSenderNestedInput
    receivedRequests?: P2PRequestUncheckedUpdateManyWithoutReceiverNestedInput
    billSchedules?: BillScheduleUncheckedUpdateManyWithoutUserNestedInput
    merchantPayments?: MerchantPaymentUncheckedUpdateManyWithoutUserNestedInput
    rechargeOrders?: RechargeOrderUncheckedUpdateManyWithoutUserNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutUserNestedInput
    referralsAsReferrer?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referralsAsReferred?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    wrongSendRequests?: WrongSendRequestUncheckedUpdateManyWithoutSenderNestedInput
    createdGroups?: BillSplitGroupUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type P2PRequestUpsertWithoutBillSplitMemberInput = {
    update: XOR<P2PRequestUpdateWithoutBillSplitMemberInput, P2PRequestUncheckedUpdateWithoutBillSplitMemberInput>
    create: XOR<P2PRequestCreateWithoutBillSplitMemberInput, P2PRequestUncheckedCreateWithoutBillSplitMemberInput>
    where?: P2PRequestWhereInput
  }

  export type P2PRequestUpdateToOneWithWhereWithoutBillSplitMemberInput = {
    where?: P2PRequestWhereInput
    data: XOR<P2PRequestUpdateWithoutBillSplitMemberInput, P2PRequestUncheckedUpdateWithoutBillSplitMemberInput>
  }

  export type P2PRequestUpdateWithoutBillSplitMemberInput = {
    receiverNumber?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumP2PRequestStatusFieldUpdateOperationsInput | $Enums.P2PRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sender?: UserUpdateOneRequiredWithoutSentRequestsNestedInput
    receiver?: UserUpdateOneWithoutReceivedRequestsNestedInput
  }

  export type P2PRequestUncheckedUpdateWithoutBillSplitMemberInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    receiverId?: NullableIntFieldUpdateOperationsInput | number | null
    receiverNumber?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumP2PRequestStatusFieldUpdateOperationsInput | $Enums.P2PRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BillSplitPaymentUpsertWithWhereUniqueWithoutMemberInput = {
    where: BillSplitPaymentWhereUniqueInput
    update: XOR<BillSplitPaymentUpdateWithoutMemberInput, BillSplitPaymentUncheckedUpdateWithoutMemberInput>
    create: XOR<BillSplitPaymentCreateWithoutMemberInput, BillSplitPaymentUncheckedCreateWithoutMemberInput>
  }

  export type BillSplitPaymentUpdateWithWhereUniqueWithoutMemberInput = {
    where: BillSplitPaymentWhereUniqueInput
    data: XOR<BillSplitPaymentUpdateWithoutMemberInput, BillSplitPaymentUncheckedUpdateWithoutMemberInput>
  }

  export type BillSplitPaymentUpdateManyWithWhereWithoutMemberInput = {
    where: BillSplitPaymentScalarWhereInput
    data: XOR<BillSplitPaymentUpdateManyMutationInput, BillSplitPaymentUncheckedUpdateManyWithoutMemberInput>
  }

  export type BillSplitGroupCreateWithoutPaymentsInput = {
    name: string
    description?: string | null
    totalAmount: number
    currency?: string
    createdAt?: Date | string
    settledAt?: Date | string | null
    status?: string
    createdBy: UserCreateNestedOneWithoutCreatedGroupsInput
    members?: BillSplitMemberCreateNestedManyWithoutGroupInput
    rewards?: RewardCreateNestedManyWithoutBillSplitGroupInput
  }

  export type BillSplitGroupUncheckedCreateWithoutPaymentsInput = {
    id?: number
    name: string
    description?: string | null
    totalAmount: number
    currency?: string
    createdById: number
    createdAt?: Date | string
    settledAt?: Date | string | null
    status?: string
    members?: BillSplitMemberUncheckedCreateNestedManyWithoutGroupInput
    rewards?: RewardUncheckedCreateNestedManyWithoutBillSplitGroupInput
  }

  export type BillSplitGroupCreateOrConnectWithoutPaymentsInput = {
    where: BillSplitGroupWhereUniqueInput
    create: XOR<BillSplitGroupCreateWithoutPaymentsInput, BillSplitGroupUncheckedCreateWithoutPaymentsInput>
  }

  export type BillSplitMemberCreateWithoutPaymentsInput = {
    phone?: string | null
    name: string
    share: number
    paid?: boolean
    paidAt?: Date | string | null
    paidAmount?: number
    group: BillSplitGroupCreateNestedOneWithoutMembersInput
    user?: UserCreateNestedOneWithoutBillSplitMembersInput
    request?: P2PRequestCreateNestedOneWithoutBillSplitMemberInput
  }

  export type BillSplitMemberUncheckedCreateWithoutPaymentsInput = {
    id?: number
    groupId: number
    userId?: number | null
    phone?: string | null
    name: string
    share: number
    paid?: boolean
    paidAt?: Date | string | null
    paidAmount?: number
    request?: P2PRequestUncheckedCreateNestedOneWithoutBillSplitMemberInput
  }

  export type BillSplitMemberCreateOrConnectWithoutPaymentsInput = {
    where: BillSplitMemberWhereUniqueInput
    create: XOR<BillSplitMemberCreateWithoutPaymentsInput, BillSplitMemberUncheckedCreateWithoutPaymentsInput>
  }

  export type p2pTransferCreateWithoutBillSplitPaymentInput = {
    amount: number
    timestamp: Date | string
    receiverNumber?: string | null
    status?: string
    razorpayPaymentId?: string | null
    paymentMethod?: string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    merchantId?: number | null
    latitude?: number | null
    longitude?: number | null
    isFraud?: boolean | null
    fraudScore?: number | null
    fraudReason?: string | null
    riskLevel?: string | null
    fromUser: UserCreateNestedOneWithoutSentTransfersInput
    toUser?: UserCreateNestedOneWithoutReceivedTransfersInput
    wrongSendRequest?: WrongSendRequestCreateNestedOneWithoutTransactionInput
  }

  export type p2pTransferUncheckedCreateWithoutBillSplitPaymentInput = {
    id?: number
    amount: number
    timestamp: Date | string
    fromUserId: number
    toUserId?: number | null
    receiverNumber?: string | null
    status?: string
    razorpayPaymentId?: string | null
    paymentMethod?: string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    merchantId?: number | null
    latitude?: number | null
    longitude?: number | null
    isFraud?: boolean | null
    fraudScore?: number | null
    fraudReason?: string | null
    riskLevel?: string | null
    wrongSendRequest?: WrongSendRequestUncheckedCreateNestedOneWithoutTransactionInput
  }

  export type p2pTransferCreateOrConnectWithoutBillSplitPaymentInput = {
    where: p2pTransferWhereUniqueInput
    create: XOR<p2pTransferCreateWithoutBillSplitPaymentInput, p2pTransferUncheckedCreateWithoutBillSplitPaymentInput>
  }

  export type BillSplitGroupUpsertWithoutPaymentsInput = {
    update: XOR<BillSplitGroupUpdateWithoutPaymentsInput, BillSplitGroupUncheckedUpdateWithoutPaymentsInput>
    create: XOR<BillSplitGroupCreateWithoutPaymentsInput, BillSplitGroupUncheckedCreateWithoutPaymentsInput>
    where?: BillSplitGroupWhereInput
  }

  export type BillSplitGroupUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: BillSplitGroupWhereInput
    data: XOR<BillSplitGroupUpdateWithoutPaymentsInput, BillSplitGroupUncheckedUpdateWithoutPaymentsInput>
  }

  export type BillSplitGroupUpdateWithoutPaymentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedGroupsNestedInput
    members?: BillSplitMemberUpdateManyWithoutGroupNestedInput
    rewards?: RewardUpdateManyWithoutBillSplitGroupNestedInput
  }

  export type BillSplitGroupUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    members?: BillSplitMemberUncheckedUpdateManyWithoutGroupNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutBillSplitGroupNestedInput
  }

  export type BillSplitMemberUpsertWithoutPaymentsInput = {
    update: XOR<BillSplitMemberUpdateWithoutPaymentsInput, BillSplitMemberUncheckedUpdateWithoutPaymentsInput>
    create: XOR<BillSplitMemberCreateWithoutPaymentsInput, BillSplitMemberUncheckedCreateWithoutPaymentsInput>
    where?: BillSplitMemberWhereInput
  }

  export type BillSplitMemberUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: BillSplitMemberWhereInput
    data: XOR<BillSplitMemberUpdateWithoutPaymentsInput, BillSplitMemberUncheckedUpdateWithoutPaymentsInput>
  }

  export type BillSplitMemberUpdateWithoutPaymentsInput = {
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    share?: IntFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAmount?: IntFieldUpdateOperationsInput | number
    group?: BillSplitGroupUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneWithoutBillSplitMembersNestedInput
    request?: P2PRequestUpdateOneWithoutBillSplitMemberNestedInput
  }

  export type BillSplitMemberUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    share?: IntFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAmount?: IntFieldUpdateOperationsInput | number
    request?: P2PRequestUncheckedUpdateOneWithoutBillSplitMemberNestedInput
  }

  export type p2pTransferUpsertWithoutBillSplitPaymentInput = {
    update: XOR<p2pTransferUpdateWithoutBillSplitPaymentInput, p2pTransferUncheckedUpdateWithoutBillSplitPaymentInput>
    create: XOR<p2pTransferCreateWithoutBillSplitPaymentInput, p2pTransferUncheckedCreateWithoutBillSplitPaymentInput>
    where?: p2pTransferWhereInput
  }

  export type p2pTransferUpdateToOneWithWhereWithoutBillSplitPaymentInput = {
    where?: p2pTransferWhereInput
    data: XOR<p2pTransferUpdateWithoutBillSplitPaymentInput, p2pTransferUncheckedUpdateWithoutBillSplitPaymentInput>
  }

  export type p2pTransferUpdateWithoutBillSplitPaymentInput = {
    amount?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    isFraud?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fraudScore?: NullableFloatFieldUpdateOperationsInput | number | null
    fraudReason?: NullableStringFieldUpdateOperationsInput | string | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    fromUser?: UserUpdateOneRequiredWithoutSentTransfersNestedInput
    toUser?: UserUpdateOneWithoutReceivedTransfersNestedInput
    wrongSendRequest?: WrongSendRequestUpdateOneWithoutTransactionNestedInput
  }

  export type p2pTransferUncheckedUpdateWithoutBillSplitPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    fromUserId?: IntFieldUpdateOperationsInput | number
    toUserId?: NullableIntFieldUpdateOperationsInput | number | null
    receiverNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    isFraud?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fraudScore?: NullableFloatFieldUpdateOperationsInput | number | null
    fraudReason?: NullableStringFieldUpdateOperationsInput | string | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    wrongSendRequest?: WrongSendRequestUncheckedUpdateOneWithoutTransactionNestedInput
  }

  export type UserCreateWithoutBalanceInput = {
    email?: string | null
    name?: string | null
    number: string
    password: string
    sessionToken?: string | null
    image?: string | null
    userpin: string
    resetOtp?: string | null
    resetExpires?: Date | string | null
    OnRampTransaction?: OnRampTransactionCreateNestedManyWithoutUserInput
    sentTransfers?: p2pTransferCreateNestedManyWithoutFromUserInput
    receivedTransfers?: p2pTransferCreateNestedManyWithoutToUserInput
    sentRequests?: P2PRequestCreateNestedManyWithoutSenderInput
    receivedRequests?: P2PRequestCreateNestedManyWithoutReceiverInput
    billSchedules?: BillScheduleCreateNestedManyWithoutUserInput
    merchantPayments?: MerchantPaymentCreateNestedManyWithoutUserInput
    rechargeOrders?: RechargeOrderCreateNestedManyWithoutUserInput
    rewards?: RewardCreateNestedManyWithoutUserInput
    referralsAsReferrer?: ReferralCreateNestedManyWithoutReferrerInput
    referralsAsReferred?: ReferralCreateNestedManyWithoutReferredInput
    wrongSendRequests?: WrongSendRequestCreateNestedManyWithoutSenderInput
    createdGroups?: BillSplitGroupCreateNestedManyWithoutCreatedByInput
    billSplitMembers?: BillSplitMemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBalanceInput = {
    id?: number
    email?: string | null
    name?: string | null
    number: string
    password: string
    sessionToken?: string | null
    image?: string | null
    userpin: string
    resetOtp?: string | null
    resetExpires?: Date | string | null
    OnRampTransaction?: OnRampTransactionUncheckedCreateNestedManyWithoutUserInput
    sentTransfers?: p2pTransferUncheckedCreateNestedManyWithoutFromUserInput
    receivedTransfers?: p2pTransferUncheckedCreateNestedManyWithoutToUserInput
    sentRequests?: P2PRequestUncheckedCreateNestedManyWithoutSenderInput
    receivedRequests?: P2PRequestUncheckedCreateNestedManyWithoutReceiverInput
    billSchedules?: BillScheduleUncheckedCreateNestedManyWithoutUserInput
    merchantPayments?: MerchantPaymentUncheckedCreateNestedManyWithoutUserInput
    rechargeOrders?: RechargeOrderUncheckedCreateNestedManyWithoutUserInput
    rewards?: RewardUncheckedCreateNestedManyWithoutUserInput
    referralsAsReferrer?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referralsAsReferred?: ReferralUncheckedCreateNestedManyWithoutReferredInput
    wrongSendRequests?: WrongSendRequestUncheckedCreateNestedManyWithoutSenderInput
    createdGroups?: BillSplitGroupUncheckedCreateNestedManyWithoutCreatedByInput
    billSplitMembers?: BillSplitMemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBalanceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBalanceInput, UserUncheckedCreateWithoutBalanceInput>
  }

  export type UserUpsertWithoutBalanceInput = {
    update: XOR<UserUpdateWithoutBalanceInput, UserUncheckedUpdateWithoutBalanceInput>
    create: XOR<UserCreateWithoutBalanceInput, UserUncheckedCreateWithoutBalanceInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBalanceInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBalanceInput, UserUncheckedUpdateWithoutBalanceInput>
  }

  export type UserUpdateWithoutBalanceInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    userpin?: StringFieldUpdateOperationsInput | string
    resetOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OnRampTransaction?: OnRampTransactionUpdateManyWithoutUserNestedInput
    sentTransfers?: p2pTransferUpdateManyWithoutFromUserNestedInput
    receivedTransfers?: p2pTransferUpdateManyWithoutToUserNestedInput
    sentRequests?: P2PRequestUpdateManyWithoutSenderNestedInput
    receivedRequests?: P2PRequestUpdateManyWithoutReceiverNestedInput
    billSchedules?: BillScheduleUpdateManyWithoutUserNestedInput
    merchantPayments?: MerchantPaymentUpdateManyWithoutUserNestedInput
    rechargeOrders?: RechargeOrderUpdateManyWithoutUserNestedInput
    rewards?: RewardUpdateManyWithoutUserNestedInput
    referralsAsReferrer?: ReferralUpdateManyWithoutReferrerNestedInput
    referralsAsReferred?: ReferralUpdateManyWithoutReferredNestedInput
    wrongSendRequests?: WrongSendRequestUpdateManyWithoutSenderNestedInput
    createdGroups?: BillSplitGroupUpdateManyWithoutCreatedByNestedInput
    billSplitMembers?: BillSplitMemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBalanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    userpin?: StringFieldUpdateOperationsInput | string
    resetOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OnRampTransaction?: OnRampTransactionUncheckedUpdateManyWithoutUserNestedInput
    sentTransfers?: p2pTransferUncheckedUpdateManyWithoutFromUserNestedInput
    receivedTransfers?: p2pTransferUncheckedUpdateManyWithoutToUserNestedInput
    sentRequests?: P2PRequestUncheckedUpdateManyWithoutSenderNestedInput
    receivedRequests?: P2PRequestUncheckedUpdateManyWithoutReceiverNestedInput
    billSchedules?: BillScheduleUncheckedUpdateManyWithoutUserNestedInput
    merchantPayments?: MerchantPaymentUncheckedUpdateManyWithoutUserNestedInput
    rechargeOrders?: RechargeOrderUncheckedUpdateManyWithoutUserNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutUserNestedInput
    referralsAsReferrer?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referralsAsReferred?: ReferralUncheckedUpdateManyWithoutReferredNestedInput
    wrongSendRequests?: WrongSendRequestUncheckedUpdateManyWithoutSenderNestedInput
    createdGroups?: BillSplitGroupUncheckedUpdateManyWithoutCreatedByNestedInput
    billSplitMembers?: BillSplitMemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OnRampTransactionCreateManyUserInput = {
    id?: number
    status: $Enums.OnRampStatus
    token: string
    provider: string
    amount: number
    startTime?: Date | string
    transactionId?: string | null
  }

  export type BalanceCreateManyUserInput = {
    id?: number
    amount: number
    locked: number
  }

  export type p2pTransferCreateManyFromUserInput = {
    id?: number
    amount: number
    timestamp: Date | string
    toUserId?: number | null
    receiverNumber?: string | null
    status?: string
    razorpayPaymentId?: string | null
    paymentMethod?: string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    merchantId?: number | null
    latitude?: number | null
    longitude?: number | null
    isFraud?: boolean | null
    fraudScore?: number | null
    fraudReason?: string | null
    riskLevel?: string | null
  }

  export type p2pTransferCreateManyToUserInput = {
    id?: number
    amount: number
    timestamp: Date | string
    fromUserId: number
    receiverNumber?: string | null
    status?: string
    razorpayPaymentId?: string | null
    paymentMethod?: string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    merchantId?: number | null
    latitude?: number | null
    longitude?: number | null
    isFraud?: boolean | null
    fraudScore?: number | null
    fraudReason?: string | null
    riskLevel?: string | null
  }

  export type P2PRequestCreateManySenderInput = {
    id?: number
    receiverId?: number | null
    receiverNumber: string
    amount: number
    message?: string | null
    status?: $Enums.P2PRequestStatus
    createdAt?: Date | string
    settledAt?: Date | string | null
    billSplitMemberId?: number | null
  }

  export type P2PRequestCreateManyReceiverInput = {
    id?: number
    senderId: number
    receiverNumber: string
    amount: number
    message?: string | null
    status?: $Enums.P2PRequestStatus
    createdAt?: Date | string
    settledAt?: Date | string | null
    billSplitMemberId?: number | null
  }

  export type BillScheduleCreateManyUserInput = {
    id?: number
    merchantId?: number | null
    billType: string
    provider: string
    accountNo: string
    amount: number
    dueDate: Date | string
    nextPayment?: Date | string | null
    createdAt?: Date | string
    paymentMethod?: string
    status?: string
    token?: string | null
  }

  export type MerchantPaymentCreateManyUserInput = {
    id?: number
    merchantId: number
    qrId: string
    amount: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionId?: string | null
  }

  export type RechargeOrderCreateManyUserInput = {
    id?: number
    planId?: number | null
    mobileNumber: string
    operator: string
    circle: string
    amount: number
    status?: string
    providerTxnId?: string | null
    orderId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RewardCreateManyUserInput = {
    id?: number
    type: $Enums.RewardType
    amount: bigint | number
    status?: $Enums.RewardStatus
    earnedAt?: Date | string
    expiresAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    billSplitGroupId?: number | null
  }

  export type ReferralCreateManyReferrerInput = {
    id?: number
    referredUserId?: number | null
    referralCode: string
  }

  export type ReferralCreateManyReferredInput = {
    id?: number
    referrerId: number
    referralCode: string
  }

  export type WrongSendRequestCreateManySenderInput = {
    id?: number
    txnId: number
    receiverNumber: string
    amount: bigint | number
    status?: $Enums.WrongSendStatus
    expiresAt: Date | string
    penaltyPaid?: boolean
    razorpayRefundId?: string | null
    createdAt?: Date | string
  }

  export type BillSplitGroupCreateManyCreatedByInput = {
    id?: number
    name: string
    description?: string | null
    totalAmount: number
    currency?: string
    createdAt?: Date | string
    settledAt?: Date | string | null
    status?: string
  }

  export type BillSplitMemberCreateManyUserInput = {
    id?: number
    groupId: number
    phone?: string | null
    name: string
    share: number
    paid?: boolean
    paidAt?: Date | string | null
    paidAmount?: number
  }

  export type OnRampTransactionUpdateWithoutUserInput = {
    status?: EnumOnRampStatusFieldUpdateOperationsInput | $Enums.OnRampStatus
    token?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OnRampTransactionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumOnRampStatusFieldUpdateOperationsInput | $Enums.OnRampStatus
    token?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OnRampTransactionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumOnRampStatusFieldUpdateOperationsInput | $Enums.OnRampStatus
    token?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BalanceUpdateWithoutUserInput = {
    amount?: IntFieldUpdateOperationsInput | number
    locked?: IntFieldUpdateOperationsInput | number
  }

  export type BalanceUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    locked?: IntFieldUpdateOperationsInput | number
  }

  export type BalanceUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    locked?: IntFieldUpdateOperationsInput | number
  }

  export type p2pTransferUpdateWithoutFromUserInput = {
    amount?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    isFraud?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fraudScore?: NullableFloatFieldUpdateOperationsInput | number | null
    fraudReason?: NullableStringFieldUpdateOperationsInput | string | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    toUser?: UserUpdateOneWithoutReceivedTransfersNestedInput
    wrongSendRequest?: WrongSendRequestUpdateOneWithoutTransactionNestedInput
    billSplitPayment?: BillSplitPaymentUpdateOneWithoutP2pTransferNestedInput
  }

  export type p2pTransferUncheckedUpdateWithoutFromUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    toUserId?: NullableIntFieldUpdateOperationsInput | number | null
    receiverNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    isFraud?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fraudScore?: NullableFloatFieldUpdateOperationsInput | number | null
    fraudReason?: NullableStringFieldUpdateOperationsInput | string | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    wrongSendRequest?: WrongSendRequestUncheckedUpdateOneWithoutTransactionNestedInput
    billSplitPayment?: BillSplitPaymentUncheckedUpdateOneWithoutP2pTransferNestedInput
  }

  export type p2pTransferUncheckedUpdateManyWithoutFromUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    toUserId?: NullableIntFieldUpdateOperationsInput | number | null
    receiverNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    isFraud?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fraudScore?: NullableFloatFieldUpdateOperationsInput | number | null
    fraudReason?: NullableStringFieldUpdateOperationsInput | string | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type p2pTransferUpdateWithoutToUserInput = {
    amount?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    isFraud?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fraudScore?: NullableFloatFieldUpdateOperationsInput | number | null
    fraudReason?: NullableStringFieldUpdateOperationsInput | string | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    fromUser?: UserUpdateOneRequiredWithoutSentTransfersNestedInput
    wrongSendRequest?: WrongSendRequestUpdateOneWithoutTransactionNestedInput
    billSplitPayment?: BillSplitPaymentUpdateOneWithoutP2pTransferNestedInput
  }

  export type p2pTransferUncheckedUpdateWithoutToUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    fromUserId?: IntFieldUpdateOperationsInput | number
    receiverNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    isFraud?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fraudScore?: NullableFloatFieldUpdateOperationsInput | number | null
    fraudReason?: NullableStringFieldUpdateOperationsInput | string | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    wrongSendRequest?: WrongSendRequestUncheckedUpdateOneWithoutTransactionNestedInput
    billSplitPayment?: BillSplitPaymentUncheckedUpdateOneWithoutP2pTransferNestedInput
  }

  export type p2pTransferUncheckedUpdateManyWithoutToUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    fromUserId?: IntFieldUpdateOperationsInput | number
    receiverNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    isFraud?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fraudScore?: NullableFloatFieldUpdateOperationsInput | number | null
    fraudReason?: NullableStringFieldUpdateOperationsInput | string | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type P2PRequestUpdateWithoutSenderInput = {
    receiverNumber?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumP2PRequestStatusFieldUpdateOperationsInput | $Enums.P2PRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiver?: UserUpdateOneWithoutReceivedRequestsNestedInput
    billSplitMember?: BillSplitMemberUpdateOneWithoutRequestNestedInput
  }

  export type P2PRequestUncheckedUpdateWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiverId?: NullableIntFieldUpdateOperationsInput | number | null
    receiverNumber?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumP2PRequestStatusFieldUpdateOperationsInput | $Enums.P2PRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billSplitMemberId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type P2PRequestUncheckedUpdateManyWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiverId?: NullableIntFieldUpdateOperationsInput | number | null
    receiverNumber?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumP2PRequestStatusFieldUpdateOperationsInput | $Enums.P2PRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billSplitMemberId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type P2PRequestUpdateWithoutReceiverInput = {
    receiverNumber?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumP2PRequestStatusFieldUpdateOperationsInput | $Enums.P2PRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sender?: UserUpdateOneRequiredWithoutSentRequestsNestedInput
    billSplitMember?: BillSplitMemberUpdateOneWithoutRequestNestedInput
  }

  export type P2PRequestUncheckedUpdateWithoutReceiverInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    receiverNumber?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumP2PRequestStatusFieldUpdateOperationsInput | $Enums.P2PRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billSplitMemberId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type P2PRequestUncheckedUpdateManyWithoutReceiverInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    receiverNumber?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumP2PRequestStatusFieldUpdateOperationsInput | $Enums.P2PRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billSplitMemberId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BillScheduleUpdateWithoutUserInput = {
    billType?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    accountNo?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextPayment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: MerchantUpdateOneWithoutBillSchedulesNestedInput
  }

  export type BillScheduleUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    merchantId?: NullableIntFieldUpdateOperationsInput | number | null
    billType?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    accountNo?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextPayment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BillScheduleUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    merchantId?: NullableIntFieldUpdateOperationsInput | number | null
    billType?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    accountNo?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextPayment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MerchantPaymentUpdateWithoutUserInput = {
    qrId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: MerchantUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type MerchantPaymentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    merchantId?: IntFieldUpdateOperationsInput | number
    qrId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MerchantPaymentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    merchantId?: IntFieldUpdateOperationsInput | number
    qrId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RechargeOrderUpdateWithoutUserInput = {
    mobileNumber?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    circle?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    providerTxnId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: RechargePlanUpdateOneWithoutRechargeOrdersNestedInput
  }

  export type RechargeOrderUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    planId?: NullableIntFieldUpdateOperationsInput | number | null
    mobileNumber?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    circle?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    providerTxnId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RechargeOrderUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    planId?: NullableIntFieldUpdateOperationsInput | number | null
    mobileNumber?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    circle?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    providerTxnId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardUpdateWithoutUserInput = {
    type?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumRewardStatusFieldUpdateOperationsInput | $Enums.RewardStatus
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    billSplitGroup?: BillSplitGroupUpdateOneWithoutRewardsNestedInput
  }

  export type RewardUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumRewardStatusFieldUpdateOperationsInput | $Enums.RewardStatus
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    billSplitGroupId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RewardUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumRewardStatusFieldUpdateOperationsInput | $Enums.RewardStatus
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    billSplitGroupId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReferralUpdateWithoutReferrerInput = {
    referralCode?: StringFieldUpdateOperationsInput | string
    referred?: UserUpdateOneWithoutReferralsAsReferredNestedInput
  }

  export type ReferralUncheckedUpdateWithoutReferrerInput = {
    id?: IntFieldUpdateOperationsInput | number
    referredUserId?: NullableIntFieldUpdateOperationsInput | number | null
    referralCode?: StringFieldUpdateOperationsInput | string
  }

  export type ReferralUncheckedUpdateManyWithoutReferrerInput = {
    id?: IntFieldUpdateOperationsInput | number
    referredUserId?: NullableIntFieldUpdateOperationsInput | number | null
    referralCode?: StringFieldUpdateOperationsInput | string
  }

  export type ReferralUpdateWithoutReferredInput = {
    referralCode?: StringFieldUpdateOperationsInput | string
    referrer?: UserUpdateOneRequiredWithoutReferralsAsReferrerNestedInput
  }

  export type ReferralUncheckedUpdateWithoutReferredInput = {
    id?: IntFieldUpdateOperationsInput | number
    referrerId?: IntFieldUpdateOperationsInput | number
    referralCode?: StringFieldUpdateOperationsInput | string
  }

  export type ReferralUncheckedUpdateManyWithoutReferredInput = {
    id?: IntFieldUpdateOperationsInput | number
    referrerId?: IntFieldUpdateOperationsInput | number
    referralCode?: StringFieldUpdateOperationsInput | string
  }

  export type WrongSendRequestUpdateWithoutSenderInput = {
    receiverNumber?: StringFieldUpdateOperationsInput | string
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumWrongSendStatusFieldUpdateOperationsInput | $Enums.WrongSendStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    penaltyPaid?: BoolFieldUpdateOperationsInput | boolean
    razorpayRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: p2pTransferUpdateOneRequiredWithoutWrongSendRequestNestedInput
  }

  export type WrongSendRequestUncheckedUpdateWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    txnId?: IntFieldUpdateOperationsInput | number
    receiverNumber?: StringFieldUpdateOperationsInput | string
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumWrongSendStatusFieldUpdateOperationsInput | $Enums.WrongSendStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    penaltyPaid?: BoolFieldUpdateOperationsInput | boolean
    razorpayRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WrongSendRequestUncheckedUpdateManyWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    txnId?: IntFieldUpdateOperationsInput | number
    receiverNumber?: StringFieldUpdateOperationsInput | string
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumWrongSendStatusFieldUpdateOperationsInput | $Enums.WrongSendStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    penaltyPaid?: BoolFieldUpdateOperationsInput | boolean
    razorpayRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillSplitGroupUpdateWithoutCreatedByInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    members?: BillSplitMemberUpdateManyWithoutGroupNestedInput
    payments?: BillSplitPaymentUpdateManyWithoutGroupNestedInput
    rewards?: RewardUpdateManyWithoutBillSplitGroupNestedInput
  }

  export type BillSplitGroupUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    members?: BillSplitMemberUncheckedUpdateManyWithoutGroupNestedInput
    payments?: BillSplitPaymentUncheckedUpdateManyWithoutGroupNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutBillSplitGroupNestedInput
  }

  export type BillSplitGroupUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type BillSplitMemberUpdateWithoutUserInput = {
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    share?: IntFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAmount?: IntFieldUpdateOperationsInput | number
    group?: BillSplitGroupUpdateOneRequiredWithoutMembersNestedInput
    request?: P2PRequestUpdateOneWithoutBillSplitMemberNestedInput
    payments?: BillSplitPaymentUpdateManyWithoutMemberNestedInput
  }

  export type BillSplitMemberUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    share?: IntFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAmount?: IntFieldUpdateOperationsInput | number
    request?: P2PRequestUncheckedUpdateOneWithoutBillSplitMemberNestedInput
    payments?: BillSplitPaymentUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type BillSplitMemberUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    share?: IntFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAmount?: IntFieldUpdateOperationsInput | number
  }

  export type BillScheduleCreateManyMerchantInput = {
    id?: number
    userId: number
    billType: string
    provider: string
    accountNo: string
    amount: number
    dueDate: Date | string
    nextPayment?: Date | string | null
    createdAt?: Date | string
    paymentMethod?: string
    status?: string
    token?: string | null
  }

  export type MerchantPaymentCreateManyMerchantInput = {
    id?: number
    qrId: string
    amount: number
    status: string
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionId?: string | null
  }

  export type BillScheduleUpdateWithoutMerchantInput = {
    billType?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    accountNo?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextPayment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutBillSchedulesNestedInput
  }

  export type BillScheduleUncheckedUpdateWithoutMerchantInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    billType?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    accountNo?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextPayment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BillScheduleUncheckedUpdateManyWithoutMerchantInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    billType?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    accountNo?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextPayment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MerchantPaymentUpdateWithoutMerchantInput = {
    qrId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutMerchantPaymentsNestedInput
  }

  export type MerchantPaymentUncheckedUpdateWithoutMerchantInput = {
    id?: IntFieldUpdateOperationsInput | number
    qrId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MerchantPaymentUncheckedUpdateManyWithoutMerchantInput = {
    id?: IntFieldUpdateOperationsInput | number
    qrId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RechargeOrderCreateManyPlanInput = {
    id?: number
    userId: number
    mobileNumber: string
    operator: string
    circle: string
    amount: number
    status?: string
    providerTxnId?: string | null
    orderId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RechargeOrderUpdateWithoutPlanInput = {
    mobileNumber?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    circle?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    providerTxnId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRechargeOrdersNestedInput
  }

  export type RechargeOrderUncheckedUpdateWithoutPlanInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    mobileNumber?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    circle?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    providerTxnId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RechargeOrderUncheckedUpdateManyWithoutPlanInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    mobileNumber?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    circle?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    providerTxnId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillSplitMemberCreateManyGroupInput = {
    id?: number
    userId?: number | null
    phone?: string | null
    name: string
    share: number
    paid?: boolean
    paidAt?: Date | string | null
    paidAmount?: number
  }

  export type BillSplitPaymentCreateManyGroupInput = {
    id?: number
    memberId: number
    p2pTransferId?: number | null
    amount: number
    paidAt?: Date | string
  }

  export type RewardCreateManyBillSplitGroupInput = {
    id?: number
    userId: number
    type: $Enums.RewardType
    amount: bigint | number
    status?: $Enums.RewardStatus
    earnedAt?: Date | string
    expiresAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BillSplitMemberUpdateWithoutGroupInput = {
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    share?: IntFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAmount?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneWithoutBillSplitMembersNestedInput
    request?: P2PRequestUpdateOneWithoutBillSplitMemberNestedInput
    payments?: BillSplitPaymentUpdateManyWithoutMemberNestedInput
  }

  export type BillSplitMemberUncheckedUpdateWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    share?: IntFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAmount?: IntFieldUpdateOperationsInput | number
    request?: P2PRequestUncheckedUpdateOneWithoutBillSplitMemberNestedInput
    payments?: BillSplitPaymentUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type BillSplitMemberUncheckedUpdateManyWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    share?: IntFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAmount?: IntFieldUpdateOperationsInput | number
  }

  export type BillSplitPaymentUpdateWithoutGroupInput = {
    amount?: IntFieldUpdateOperationsInput | number
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    member?: BillSplitMemberUpdateOneRequiredWithoutPaymentsNestedInput
    p2pTransfer?: p2pTransferUpdateOneWithoutBillSplitPaymentNestedInput
  }

  export type BillSplitPaymentUncheckedUpdateWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    memberId?: IntFieldUpdateOperationsInput | number
    p2pTransferId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: IntFieldUpdateOperationsInput | number
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillSplitPaymentUncheckedUpdateManyWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    memberId?: IntFieldUpdateOperationsInput | number
    p2pTransferId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: IntFieldUpdateOperationsInput | number
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardUpdateWithoutBillSplitGroupInput = {
    type?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumRewardStatusFieldUpdateOperationsInput | $Enums.RewardStatus
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutRewardsNestedInput
  }

  export type RewardUncheckedUpdateWithoutBillSplitGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumRewardStatusFieldUpdateOperationsInput | $Enums.RewardStatus
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RewardUncheckedUpdateManyWithoutBillSplitGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: EnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumRewardStatusFieldUpdateOperationsInput | $Enums.RewardStatus
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BillSplitPaymentCreateManyMemberInput = {
    id?: number
    groupId: number
    p2pTransferId?: number | null
    amount: number
    paidAt?: Date | string
  }

  export type BillSplitPaymentUpdateWithoutMemberInput = {
    amount?: IntFieldUpdateOperationsInput | number
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: BillSplitGroupUpdateOneRequiredWithoutPaymentsNestedInput
    p2pTransfer?: p2pTransferUpdateOneWithoutBillSplitPaymentNestedInput
  }

  export type BillSplitPaymentUncheckedUpdateWithoutMemberInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    p2pTransferId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: IntFieldUpdateOperationsInput | number
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillSplitPaymentUncheckedUpdateManyWithoutMemberInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    p2pTransferId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: IntFieldUpdateOperationsInput | number
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}